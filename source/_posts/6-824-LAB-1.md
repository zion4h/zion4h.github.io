---
title: 6.824 Lab1 MapReduce
date: 2022-12-01 12:00:00
cover: /img/cover/img264.jpg
categories:
    - 编程
    - 编程.Labs
    - 编程.Labs.6.824
toc: true
---

遵循[lab页](https://pdos.csail.mit.edu/6.824/labs/lab-mr.html)指导，并在本地部署好项目。我在观摩完mrsequential的代码后，再结合[MapReduce论文](https://static.googleusercontent.com/media/research.google.com/zh-CN//archive/mapreduce-osdi04.pdf)，理清了基本思路。
<!--more-->

首先，我们会有两个角色，worker负责处理任务，coordinator负责管理和分配任务，一般有一个coordinator和多个worker（现在先不考虑单点故障问题）。

单词计数任务的map阶段会将输入的多个文本转换成形如“hello，1”这样的键值数组，然后在reduce阶段会将这些键值数组整合并输出。另外，我们在代码设计过程中应注意：coordinator只负责分配和管理，而worker负责全部的计算。

针对lab1，我们的单个map任务会接受一个文本文件，然后将其转换成中间键值对后，由给定的nReduce个reduce任务去接收计算，lab中已经给定为10。也就是说，我们的一个map任务，假设其编号为2，会将一个文本文件转化成10个中间文件，也就是mr-2-0到mr-2-9。而每个reduce任务都会将属于自己那份文件输入，比如编号为4的reduce任务会将中间文件mr-x-4的全部文件输入，最终输出mr-out-4。我们不需要做更后面的合并，测试脚本会帮我们完善这一步（可以看test.sh代码）。

上面是对lab1的任务处理流程进行梳理，接下来我们需要针对coordinator按需求进行设计。为了方便管理reduce和map任务的执行进度，我们需要定义一个新的结构体task，它包含任务类型、任务编号、是否完成，之前有将任务状态分为初始化，处理中和已完成三种状态，但后面看了助教的QA后，用isDone简单管理两种状态。之所以这样改进，是因为我们要让coordinator负责任务调度，如果将inProcessing状态传输回worker，那么worker也将会参与调度工作，比如等待一段时间，这是不太完善的。

另一个需要设计的是Rpc，lab1中我们总共涉及两种通信场景，即worker向coordinator请求任务，以及worker向coordinator通知某个任务已完成。原本我是将整个task作为参数在RPC中进行传输的，现在分析整理了一下代码需求，发现我们只需要task类型、task编号、而map还需要reduce个数和map输入文件名、而reduce还需要map个数。而在任务完成时发送的信息，只包括task的类型和task的编号。

最后，我们还需要处理同步问题。后面是漫长的修改，我控制并发的手段很单一，就是将coordinator访问共享变量的代码都用mutex包起来，最后用test-mr脚本测试的时候，总是在map并行测试这里失败，后面发现我的worker在处理map和reduce时用了goroutine，当时为了效率加的。再引入cond，之前我的代码逻辑当检查完map任务发现有map任务没完成时会等待一段时间再检查，直到map完成后进入reduce，同理reduce完成后全部结束。引入cond可以让coordinator在处理完成任务时，再激活检查一下，而不再只是呆板的定时检查，这样更符合逻辑，当然定时检查同样不能少，这样当一个任务迟迟没有完成时coordinator也能及时发现。

Over！