---
title: B 树家族
date: 2023-04-01 16:06:46
cover: https://cdn.jsdelivr.net/gh/zion4h/picture-home@main/wallpaperimg1004.jpg
categories: [编程, 数据结构]
toc: true
tags: 
    - btree
---
探讨 B 树族相关的数据结构，比如 **B 树**、**B+ 树**、**红黑树**等。
<!--more-->
## 起源

人类是无法平地起高楼的，**B 树**的诞生本身参考了 **2-3 树**和 **2-3-4 树**。

### 2-3 tree

一棵 **2-3 树**由 **2-node** 节点或 **3-node** 节点构成，由 John Hopcroft 于 1970 年发明。

![2-3-tree.png](https://cdn.jsdelivr.net/gh/zion4h/picture-home@main/2-3-tree.png)

为了保持平衡，2-3 树的所有叶节点放在同一层，节点元素值也是有序排放的。

### 2-3-4 tree

由 **2-3 树**推广，**2-3-4 树**的内部节点还包含 **4-node** 节点。

![2-3-4-tree.png](https://cdn.jsdelivr.net/gh/zion4h/picture-home@main/2-3-4-tree.png)

同样为了保持平衡，**2-3-4 树**所有叶节点也放在同一层，节点元素内部有序排列。

值的注意的是，**2-3-4 树**其实可以看作一棵 **4 阶 B 树**。

## 背景

B 树起源于二叉搜索树，由波音研究所的两名科学家 Rudolf Bayer 和 Edward M. McCreight 发明 (1970s)，应用于数据库和文件系统。B 树的 B 其实包含了多重意思，比如波音，而不是我们通常简单认为的 Balance 平衡。

## 定义

可以参考 Knuth 定义，一棵 m 阶的 B 树有以下属性：

1. 每个节点最多 m 个子节点
2. 每个内部节点至少有 `⌈m/2⌉` 个节点
3. 每个非叶子节点至少有 2 个节点
4. 叶子节点在同一层
5. 含 k 个子节点的非叶节点包含 k-1 个数据元素

这里插一嘴，[Donald Knuth](https://en.wikipedia.org/wiki/Donald_Knuth) 这位大佬在计算机学习道路上会和我们如影相随，建议查查维基，提前打个照面认个熟脸。

## 插入和删除

有利自然有弊，虽然我们访问记录的速度快了，但维护这样一个有序结构也变得麻烦起来。因此，当我们删除时，我们只是将其标记为已删除而暂时不动它，等访问效率降低到一定程度后再整理。同理，插入时，我们直接替换掉那些已删除的元素。而为了让删除和插入的代价尽量小，我们也需要尽量让 B 树维持在一个半满的状态。

## 实现数据库索引

我们的数据库一般都放在磁盘上，而从磁盘上读取一条记录的时间大约是 10 毫秒，假设我们从一百万条数据中找到一条记录，即使用二分法也要访存 20 次即 0.2 秒。当然由于我们访存时会按块存取，而一个块可能包含连续一百条记录，这样后续的几次比较实际上并不需要访存。因此，访存时间缩短为 0.14 秒左右。

这时候，采用 B 树作为数据库索引结构意义出现了。假设我们构建一个 100 阶的 B 树，并让它保存*一百万条数据，那么我们访问一条记录只需要 3 次*，也就是 0.03 秒。

![btree.png](https://cdn.jsdelivr.net/gh/zion4h/picture-home@main/btree.png)

B 树用在数据库有这样几点优势：

1. 有序存储键值，便于**顺序遍历**。
2. **使用分层索引，最大限度地减少磁盘读取次数。**
3. 使用部分填充块来加快插入和删除的速度。
4. 通过递归算法保持索引平衡。

此外，B 树通过确保内部节点至少半满，最小化浪费，B 树能够处理任意数量的插入和删除操作。

## ⭐衍生数据结构

### B+-Tree

MySQL 的 InnoDB 采用 B+树存储索引，相较于 B 树，由于元素都放到了叶子节点所以树会变矮查询速度变快，另一方面 B+树的叶子节点是有序串联的，因此范围查询起来也比较方便。

### 红黑树 Red–black tree

红黑树是由 Leonidas J. Guibas 和 Robert Sedgewick 在 2-3-4 树上发展而来，增删查改节点的时间都是$O(log n)$。

红黑树保证根和叶子节点都是黑色，红色节点不相邻，且任意路径的黑色节点数相等，这使得最长路径和最短路径只有两倍差。

### 跳表 Skip list

[跳表](https://en.wikipedia.org/wiki/Skip_list)是一个概率数据结构，最大亮点是能够以${\mathcal {O}}(\log n)$复杂进行查询和增删。它实现快速查询的原理其实很简单，在维持更少元素的子序列上查找即可，这样就能跳过非目标的元素了。

![跳表添加元素](https://cdn.jsdelivr.net/gh/zion4h/picture-home@main/Skip_list_add_element-en.gif)
